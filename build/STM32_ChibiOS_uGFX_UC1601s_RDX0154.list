
build/STM32_ChibiOS_uGFX_UC1601s_RDX0154.elf:     file format elf32-littlearm


Disassembly of section .text:

08000160 <Reset_Handler>:
 8000160:	b672      	cpsid	i
 8000162:	4826      	ldr	r0, [pc, #152]	; (80001fc <endfiniloop+0x6>)
 8000164:	f380 8809 	msr	PSP, r0
 8000168:	4825      	ldr	r0, [pc, #148]	; (8000200 <endfiniloop+0xa>)
 800016a:	f64e 5108 	movw	r1, #60680	; 0xed08
 800016e:	f2ce 0100 	movt	r1, #57344	; 0xe000
 8000172:	6008      	str	r0, [r1, #0]
 8000174:	2002      	movs	r0, #2
 8000176:	f380 8814 	msr	CONTROL, r0
 800017a:	f3bf 8f6f 	isb	sy
 800017e:	f001 ff4f 	bl	8002020 <__core_init>
 8000182:	f000 fdd5 	bl	8000d30 <__early_init>
 8000186:	f04f 3055 	mov.w	r0, #1431655765	; 0x55555555
 800018a:	491e      	ldr	r1, [pc, #120]	; (8000204 <endfiniloop+0xe>)
 800018c:	4a1e      	ldr	r2, [pc, #120]	; (8000208 <endfiniloop+0x12>)

0800018e <msloop>:
 800018e:	4291      	cmp	r1, r2
 8000190:	bf3c      	itt	cc
 8000192:	f841 0b04 	strcc.w	r0, [r1], #4
 8000196:	e7fa      	bcc.n	800018e <msloop>
 8000198:	491c      	ldr	r1, [pc, #112]	; (800020c <endfiniloop+0x16>)
 800019a:	4a18      	ldr	r2, [pc, #96]	; (80001fc <endfiniloop+0x6>)

0800019c <psloop>:
 800019c:	4291      	cmp	r1, r2
 800019e:	bf3c      	itt	cc
 80001a0:	f841 0b04 	strcc.w	r0, [r1], #4
 80001a4:	e7fa      	bcc.n	800019c <psloop>
 80001a6:	491a      	ldr	r1, [pc, #104]	; (8000210 <endfiniloop+0x1a>)
 80001a8:	4a1a      	ldr	r2, [pc, #104]	; (8000214 <endfiniloop+0x1e>)
 80001aa:	4b1b      	ldr	r3, [pc, #108]	; (8000218 <endfiniloop+0x22>)

080001ac <dloop>:
 80001ac:	429a      	cmp	r2, r3
 80001ae:	bf3e      	ittt	cc
 80001b0:	f851 0b04 	ldrcc.w	r0, [r1], #4
 80001b4:	f842 0b04 	strcc.w	r0, [r2], #4
 80001b8:	e7f8      	bcc.n	80001ac <dloop>
 80001ba:	2000      	movs	r0, #0
 80001bc:	4917      	ldr	r1, [pc, #92]	; (800021c <endfiniloop+0x26>)
 80001be:	4a18      	ldr	r2, [pc, #96]	; (8000220 <endfiniloop+0x2a>)

080001c0 <bloop>:
 80001c0:	4291      	cmp	r1, r2
 80001c2:	bf3c      	itt	cc
 80001c4:	f841 0b04 	strcc.w	r0, [r1], #4
 80001c8:	e7fa      	bcc.n	80001c0 <bloop>
 80001ca:	f001 fee1 	bl	8001f90 <__init_ram_areas>
 80001ce:	f001 ff1f 	bl	8002010 <__late_init>
 80001d2:	4c14      	ldr	r4, [pc, #80]	; (8000224 <endfiniloop+0x2e>)
 80001d4:	4d14      	ldr	r5, [pc, #80]	; (8000228 <endfiniloop+0x32>)

080001d6 <initloop>:
 80001d6:	42ac      	cmp	r4, r5
 80001d8:	da03      	bge.n	80001e2 <endinitloop>
 80001da:	f854 1b04 	ldr.w	r1, [r4], #4
 80001de:	4788      	blx	r1
 80001e0:	e7f9      	b.n	80001d6 <initloop>

080001e2 <endinitloop>:
 80001e2:	f001 f93d 	bl	8001460 <main>
 80001e6:	4c11      	ldr	r4, [pc, #68]	; (800022c <endfiniloop+0x36>)
 80001e8:	4d11      	ldr	r5, [pc, #68]	; (8000230 <endfiniloop+0x3a>)

080001ea <finiloop>:
 80001ea:	42ac      	cmp	r4, r5
 80001ec:	da03      	bge.n	80001f6 <endfiniloop>
 80001ee:	f854 1b04 	ldr.w	r1, [r4], #4
 80001f2:	4788      	blx	r1
 80001f4:	e7f9      	b.n	80001ea <finiloop>

080001f6 <endfiniloop>:
 80001f6:	f001 bf03 	b.w	8002000 <__default_exit>
 80001fa:	0000      	.short	0x0000
 80001fc:	20000800 	.word	0x20000800
 8000200:	08000000 	.word	0x08000000
 8000204:	20000000 	.word	0x20000000
 8000208:	20000400 	.word	0x20000400
 800020c:	20000400 	.word	0x20000400
 8000210:	080040d8 	.word	0x080040d8
 8000214:	20000800 	.word	0x20000800
 8000218:	20000800 	.word	0x20000800
 800021c:	20000800 	.word	0x20000800
 8000220:	20000a3c 	.word	0x20000a3c
 8000224:	08000160 	.word	0x08000160
 8000228:	08000160 	.word	0x08000160
 800022c:	08000160 	.word	0x08000160
 8000230:	08000160 	.word	0x08000160
	...

08000240 <_port_switch>:
 8000240:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8000244:	f8c1 d00c 	str.w	sp, [r1, #12]
 8000248:	68c3      	ldr	r3, [r0, #12]
 800024a:	469d      	mov	sp, r3
 800024c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

08000250 <_port_thread_start>:
 8000250:	2300      	movs	r3, #0
 8000252:	f383 8811 	msr	BASEPRI, r3
 8000256:	4628      	mov	r0, r5
 8000258:	47a0      	blx	r4
 800025a:	2000      	movs	r0, #0
 800025c:	f001 fda0 	bl	8001da0 <chThdExit>

08000260 <_port_switch_from_isr>:
 8000260:	f001 fb9e 	bl	80019a0 <chSchDoReschedule>

08000264 <_port_exit_from_isr>:
 8000264:	df00      	svc	0
 8000266:	e7fe      	b.n	8000266 <_port_exit_from_isr+0x2>
	...

08000270 <write_pixels>:

/* Call the callback to write one pixel to screen, and advance to next
 * pixel position. */
static void write_pixels(struct renderstate_r *rstate, uint16_t count,
                         uint8_t alpha)
{
 8000270:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8000274:	4605      	mov	r5, r0
    uint8_t rowlen;
    
    /* Write row-by-row if the run spans multiple rows. */
    while (rstate->x + count >= rstate->x_end)
 8000276:	f9b0 0004 	ldrsh.w	r0, [r0, #4]
 800027a:	f9b5 4002 	ldrsh.w	r4, [r5, #2]
 800027e:	180b      	adds	r3, r1, r0
 8000280:	42a3      	cmp	r3, r4

/* Call the callback to write one pixel to screen, and advance to next
 * pixel position. */
static void write_pixels(struct renderstate_r *rstate, uint16_t count,
                         uint8_t alpha)
{
 8000282:	b082      	sub	sp, #8
 8000284:	460e      	mov	r6, r1
 8000286:	4690      	mov	r8, r2
    uint8_t rowlen;
    
    /* Write row-by-row if the run spans multiple rows. */
    while (rstate->x + count >= rstate->x_end)
 8000288:	db17      	blt.n	80002ba <write_pixels+0x4a>
 800028a:	f9b5 1006 	ldrsh.w	r1, [r5, #6]
    {
        rowlen = rstate->x_end - rstate->x;
        rstate->callback(rstate->x, rstate->y, rowlen, alpha, rstate->state);
 800028e:	692b      	ldr	r3, [r5, #16]
    uint8_t rowlen;
    
    /* Write row-by-row if the run spans multiple rows. */
    while (rstate->x + count >= rstate->x_end)
    {
        rowlen = rstate->x_end - rstate->x;
 8000290:	1a24      	subs	r4, r4, r0
 8000292:	b2e4      	uxtb	r4, r4
        rstate->callback(rstate->x, rstate->y, rowlen, alpha, rstate->state);
 8000294:	9300      	str	r3, [sp, #0]
 8000296:	4622      	mov	r2, r4
 8000298:	4643      	mov	r3, r8
 800029a:	68ef      	ldr	r7, [r5, #12]
 800029c:	47b8      	blx	r7
        count -= rowlen;
 800029e:	1b36      	subs	r6, r6, r4
        rstate->x = rstate->x_begin;
        rstate->y++;
 80002a0:	88e9      	ldrh	r1, [r5, #6]
    while (rstate->x + count >= rstate->x_end)
    {
        rowlen = rstate->x_end - rstate->x;
        rstate->callback(rstate->x, rstate->y, rowlen, alpha, rstate->state);
        count -= rowlen;
        rstate->x = rstate->x_begin;
 80002a2:	f9b5 0000 	ldrsh.w	r0, [r5]
    /* Write row-by-row if the run spans multiple rows. */
    while (rstate->x + count >= rstate->x_end)
    {
        rowlen = rstate->x_end - rstate->x;
        rstate->callback(rstate->x, rstate->y, rowlen, alpha, rstate->state);
        count -= rowlen;
 80002a6:	b2b6      	uxth	r6, r6
                         uint8_t alpha)
{
    uint8_t rowlen;
    
    /* Write row-by-row if the run spans multiple rows. */
    while (rstate->x + count >= rstate->x_end)
 80002a8:	f9b5 4002 	ldrsh.w	r4, [r5, #2]
    {
        rowlen = rstate->x_end - rstate->x;
        rstate->callback(rstate->x, rstate->y, rowlen, alpha, rstate->state);
        count -= rowlen;
        rstate->x = rstate->x_begin;
        rstate->y++;
 80002ac:	3101      	adds	r1, #1
                         uint8_t alpha)
{
    uint8_t rowlen;
    
    /* Write row-by-row if the run spans multiple rows. */
    while (rstate->x + count >= rstate->x_end)
 80002ae:	1983      	adds	r3, r0, r6
    {
        rowlen = rstate->x_end - rstate->x;
        rstate->callback(rstate->x, rstate->y, rowlen, alpha, rstate->state);
        count -= rowlen;
        rstate->x = rstate->x_begin;
        rstate->y++;
 80002b0:	b209      	sxth	r1, r1
                         uint8_t alpha)
{
    uint8_t rowlen;
    
    /* Write row-by-row if the run spans multiple rows. */
    while (rstate->x + count >= rstate->x_end)
 80002b2:	42a3      	cmp	r3, r4
    {
        rowlen = rstate->x_end - rstate->x;
        rstate->callback(rstate->x, rstate->y, rowlen, alpha, rstate->state);
        count -= rowlen;
        rstate->x = rstate->x_begin;
 80002b4:	80a8      	strh	r0, [r5, #4]
        rstate->y++;
 80002b6:	80e9      	strh	r1, [r5, #6]
                         uint8_t alpha)
{
    uint8_t rowlen;
    
    /* Write row-by-row if the run spans multiple rows. */
    while (rstate->x + count >= rstate->x_end)
 80002b8:	dae9      	bge.n	800028e <write_pixels+0x1e>
        rstate->x = rstate->x_begin;
        rstate->y++;
    }
    
    /* Write the remaining part */
    if (count)
 80002ba:	b156      	cbz	r6, 80002d2 <write_pixels+0x62>
    {
        rstate->callback(rstate->x, rstate->y, count, alpha, rstate->state);
 80002bc:	692a      	ldr	r2, [r5, #16]
 80002be:	f9b5 1006 	ldrsh.w	r1, [r5, #6]
 80002c2:	9200      	str	r2, [sp, #0]
 80002c4:	4643      	mov	r3, r8
 80002c6:	b2f2      	uxtb	r2, r6
 80002c8:	68ec      	ldr	r4, [r5, #12]
 80002ca:	47a0      	blx	r4
        rstate->x += count;
 80002cc:	88ab      	ldrh	r3, [r5, #4]
 80002ce:	441e      	add	r6, r3
 80002d0:	80ae      	strh	r6, [r5, #4]
    }
}
 80002d2:	b002      	add	sp, #8
 80002d4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	...

080002e0 <write_ref_codeword>:
/* Decode and write out a reference codeword */
static void write_ref_codeword(const struct mf_rlefont_s *font,
                                struct renderstate_r *rstate,
                                uint8_t code)
{
    if (code <= 15)
 80002e0:	2a0f      	cmp	r2, #15

/* Decode and write out a reference codeword */
static void write_ref_codeword(const struct mf_rlefont_s *font,
                                struct renderstate_r *rstate,
                                uint8_t code)
{
 80002e2:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    if (code <= 15)
 80002e4:	d93f      	bls.n	8000366 <write_ref_codeword+0x86>
    {
        write_pixels(rstate, 1, 0x11 * code);
    }
    else if (code == REF_FILLZEROS)
 80002e6:	2a10      	cmp	r2, #16
 80002e8:	d056      	beq.n	8000398 <write_ref_codeword+0xb8>
    {
        /* Fill with zeroes to end */
        rstate->y = rstate->y_end;
    }
    else if (code < DICT_START)
 80002ea:	2a17      	cmp	r2, #23
 80002ec:	d93a      	bls.n	8000364 <write_ref_codeword+0x84>
    {
        /* Reserved */
    }
    else if (code < DICT_START + font->rle_entry_count)
 80002ee:	f890 3028 	ldrb.w	r3, [r0, #40]	; 0x28
 80002f2:	460c      	mov	r4, r1
 80002f4:	3317      	adds	r3, #23
 80002f6:	4293      	cmp	r3, r2
 80002f8:	4606      	mov	r6, r0
 80002fa:	da50      	bge.n	800039e <write_ref_codeword+0xbe>
}

/* Get bit count for the "fill entries" */
static uint8_t fillentry_bitcount(uint8_t index)
{
    if (index >= DICT_START2BIT)
 80002fc:	2afb      	cmp	r2, #251	; 0xfb
 80002fe:	d93b      	bls.n	8000378 <write_ref_codeword+0x98>
 8000300:	2601      	movs	r6, #1
static void write_bin_codeword(const struct mf_rlefont_s *font,
                                struct renderstate_r *rstate,
                                uint8_t code)
{
    uint8_t bitcount = fillentry_bitcount(code);
    uint8_t byte = code - DICT_START7BIT;
 8000302:	3a04      	subs	r2, #4
 8000304:	b2d5      	uxtb	r5, r2
 8000306:	2100      	movs	r1, #0
 8000308:	e006      	b.n	8000318 <write_ref_codeword+0x38>
    
    while (bitcount--)
    {
        if (byte & 1)
        {
            runlen++;
 800030a:	3101      	adds	r1, #1
    uint8_t bitcount = fillentry_bitcount(code);
    uint8_t byte = code - DICT_START7BIT;
    uint8_t runlen = 0;
    (void) font;
    
    while (bitcount--)
 800030c:	1e73      	subs	r3, r6, #1
    {
        if (byte & 1)
        {
            runlen++;
 800030e:	b2c9      	uxtb	r1, r1
            }
            
            skip_pixels(rstate, 1);
        }
        
        byte >>= 1;
 8000310:	086d      	lsrs	r5, r5, #1
    uint8_t bitcount = fillentry_bitcount(code);
    uint8_t byte = code - DICT_START7BIT;
    uint8_t runlen = 0;
    (void) font;
    
    while (bitcount--)
 8000312:	b2db      	uxtb	r3, r3
 8000314:	b1fe      	cbz	r6, 8000356 <write_ref_codeword+0x76>
 8000316:	461e      	mov	r6, r3
    {
        if (byte & 1)
 8000318:	07eb      	lsls	r3, r5, #31
 800031a:	d4f6      	bmi.n	800030a <write_ref_codeword+0x2a>
        {
            runlen++;
        }
        else 
        {
            if (runlen)
 800031c:	2900      	cmp	r1, #0
 800031e:	d136      	bne.n	800038e <write_ref_codeword+0xae>
}

/* Skip the given number of pixels (0 alpha) */
static void skip_pixels(struct renderstate_r *rstate, uint16_t count)
{
    rstate->x += count;
 8000320:	88a3      	ldrh	r3, [r4, #4]
    while (rstate->x >= rstate->x_end)
 8000322:	f9b4 1002 	ldrsh.w	r1, [r4, #2]
}

/* Skip the given number of pixels (0 alpha) */
static void skip_pixels(struct renderstate_r *rstate, uint16_t count)
{
    rstate->x += count;
 8000326:	3301      	adds	r3, #1
 8000328:	b21b      	sxth	r3, r3
    while (rstate->x >= rstate->x_end)
 800032a:	428b      	cmp	r3, r1
}

/* Skip the given number of pixels (0 alpha) */
static void skip_pixels(struct renderstate_r *rstate, uint16_t count)
{
    rstate->x += count;
 800032c:	80a3      	strh	r3, [r4, #4]
    while (rstate->x >= rstate->x_end)
 800032e:	db0c      	blt.n	800034a <write_ref_codeword+0x6a>
 8000330:	8827      	ldrh	r7, [r4, #0]
 8000332:	f9b4 2006 	ldrsh.w	r2, [r4, #6]
 8000336:	b288      	uxth	r0, r1
 8000338:	443b      	add	r3, r7
 800033a:	1a1b      	subs	r3, r3, r0
 800033c:	b21b      	sxth	r3, r3
 800033e:	3201      	adds	r2, #1
 8000340:	4299      	cmp	r1, r3
 8000342:	b212      	sxth	r2, r2
 8000344:	ddf8      	ble.n	8000338 <write_ref_codeword+0x58>
 8000346:	80a3      	strh	r3, [r4, #4]
 8000348:	80e2      	strh	r2, [r4, #6]
    uint8_t bitcount = fillentry_bitcount(code);
    uint8_t byte = code - DICT_START7BIT;
    uint8_t runlen = 0;
    (void) font;
    
    while (bitcount--)
 800034a:	1e73      	subs	r3, r6, #1
 800034c:	2100      	movs	r1, #0
            }
            
            skip_pixels(rstate, 1);
        }
        
        byte >>= 1;
 800034e:	086d      	lsrs	r5, r5, #1
    uint8_t bitcount = fillentry_bitcount(code);
    uint8_t byte = code - DICT_START7BIT;
    uint8_t runlen = 0;
    (void) font;
    
    while (bitcount--)
 8000350:	b2db      	uxtb	r3, r3
 8000352:	2e00      	cmp	r6, #0
 8000354:	d1df      	bne.n	8000316 <write_ref_codeword+0x36>
        }
        
        byte >>= 1;
    }
    
    if (runlen)
 8000356:	b129      	cbz	r1, 8000364 <write_ref_codeword+0x84>
        write_pixels(rstate, runlen, 255);
 8000358:	4620      	mov	r0, r4
    }
    else
    {
        write_bin_codeword(font, rstate, code);
    }
}
 800035a:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
        
        byte >>= 1;
    }
    
    if (runlen)
        write_pixels(rstate, runlen, 255);
 800035e:	22ff      	movs	r2, #255	; 0xff
 8000360:	f7ff bf86 	b.w	8000270 <write_pixels>
 8000364:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
                                struct renderstate_r *rstate,
                                uint8_t code)
{
    if (code <= 15)
    {
        write_pixels(rstate, 1, 0x11 * code);
 8000366:	eb02 1202 	add.w	r2, r2, r2, lsl #4
 800036a:	4608      	mov	r0, r1
    }
    else
    {
        write_bin_codeword(font, rstate, code);
    }
}
 800036c:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
                                struct renderstate_r *rstate,
                                uint8_t code)
{
    if (code <= 15)
    {
        write_pixels(rstate, 1, 0x11 * code);
 8000370:	b2d2      	uxtb	r2, r2
 8000372:	2101      	movs	r1, #1
 8000374:	f7ff bf7c 	b.w	8000270 <write_pixels>
/* Get bit count for the "fill entries" */
static uint8_t fillentry_bitcount(uint8_t index)
{
    if (index >= DICT_START2BIT)
        return 2;
    else if (index >= DICT_START3BIT)
 8000378:	2af3      	cmp	r2, #243	; 0xf3
 800037a:	d872      	bhi.n	8000462 <write_ref_codeword+0x182>
        return 3;
    else if (index >= DICT_START4BIT)
 800037c:	2ae3      	cmp	r2, #227	; 0xe3
 800037e:	d872      	bhi.n	8000466 <write_ref_codeword+0x186>
        return 4;
    else if (index >= DICT_START5BIT)
 8000380:	2ac3      	cmp	r2, #195	; 0xc3
 8000382:	d872      	bhi.n	800046a <write_ref_codeword+0x18a>
        return 5;
    else if (index >= DICT_START6BIT)
 8000384:	2a84      	cmp	r2, #132	; 0x84
 8000386:	bf34      	ite	cc
 8000388:	2606      	movcc	r6, #6
 800038a:	2605      	movcs	r6, #5
 800038c:	e7b9      	b.n	8000302 <write_ref_codeword+0x22>
        }
        else 
        {
            if (runlen)
            {
                write_pixels(rstate, runlen, 255);
 800038e:	22ff      	movs	r2, #255	; 0xff
 8000390:	4620      	mov	r0, r4
 8000392:	f7ff ff6d 	bl	8000270 <write_pixels>
 8000396:	e7c3      	b.n	8000320 <write_ref_codeword+0x40>
        write_pixels(rstate, 1, 0x11 * code);
    }
    else if (code == REF_FILLZEROS)
    {
        /* Fill with zeroes to end */
        rstate->y = rstate->y_end;
 8000398:	890b      	ldrh	r3, [r1, #8]
 800039a:	80cb      	strh	r3, [r1, #6]
 800039c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
/* Decode and write out a RLE-encoded dictionary entry. */
static void write_rle_dictentry(const struct mf_rlefont_s *font,
                                struct renderstate_r *rstate,
                                uint8_t index)
{
    uint16_t offset = font->dictionary_offsets[index];
 800039e:	3a18      	subs	r2, #24
 80003a0:	6a41      	ldr	r1, [r0, #36]	; 0x24
 80003a2:	b2d3      	uxtb	r3, r2
    uint16_t length = font->dictionary_offsets[index + 1] - offset;
 80003a4:	eb01 0243 	add.w	r2, r1, r3, lsl #1
 80003a8:	8852      	ldrh	r2, [r2, #2]
/* Decode and write out a RLE-encoded dictionary entry. */
static void write_rle_dictentry(const struct mf_rlefont_s *font,
                                struct renderstate_r *rstate,
                                uint8_t index)
{
    uint16_t offset = font->dictionary_offsets[index];
 80003aa:	f831 5013 	ldrh.w	r5, [r1, r3, lsl #1]
    uint16_t length = font->dictionary_offsets[index + 1] - offset;
 80003ae:	1b53      	subs	r3, r2, r5
 80003b0:	b29b      	uxth	r3, r3
    uint16_t i;
    
    for (i = 0; i < length; i++)
 80003b2:	2b00      	cmp	r3, #0
 80003b4:	d0d6      	beq.n	8000364 <write_ref_codeword+0x84>
 80003b6:	3b01      	subs	r3, #1
 80003b8:	b29b      	uxth	r3, r3
 80003ba:	1c6f      	adds	r7, r5, #1
 80003bc:	441f      	add	r7, r3
    {
        uint8_t code = font->dictionary_data[offset + i];
 80003be:	6a33      	ldr	r3, [r6, #32]
 80003c0:	5d58      	ldrb	r0, [r3, r5]
        if ((code & RLE_CODEMASK) == RLE_ZEROS)
 80003c2:	f010 03c0 	ands.w	r3, r0, #192	; 0xc0
 80003c6:	d119      	bne.n	80003fc <write_ref_codeword+0x11c>
}

/* Skip the given number of pixels (0 alpha) */
static void skip_pixels(struct renderstate_r *rstate, uint16_t count)
{
    rstate->x += count;
 80003c8:	88a3      	ldrh	r3, [r4, #4]
    while (rstate->x >= rstate->x_end)
 80003ca:	f9b4 1002 	ldrsh.w	r1, [r4, #2]
}

/* Skip the given number of pixels (0 alpha) */
static void skip_pixels(struct renderstate_r *rstate, uint16_t count)
{
    rstate->x += count;
 80003ce:	4403      	add	r3, r0
 80003d0:	b21b      	sxth	r3, r3
    while (rstate->x >= rstate->x_end)
 80003d2:	428b      	cmp	r3, r1
}

/* Skip the given number of pixels (0 alpha) */
static void skip_pixels(struct renderstate_r *rstate, uint16_t count)
{
    rstate->x += count;
 80003d4:	80a3      	strh	r3, [r4, #4]
    while (rstate->x >= rstate->x_end)
 80003d6:	db0d      	blt.n	80003f4 <write_ref_codeword+0x114>
 80003d8:	f9b4 2006 	ldrsh.w	r2, [r4, #6]
 80003dc:	f8b4 e000 	ldrh.w	lr, [r4]
 80003e0:	b288      	uxth	r0, r1
 80003e2:	4473      	add	r3, lr
 80003e4:	1a1b      	subs	r3, r3, r0
 80003e6:	b21b      	sxth	r3, r3
 80003e8:	3201      	adds	r2, #1
 80003ea:	428b      	cmp	r3, r1
 80003ec:	b212      	sxth	r2, r2
 80003ee:	daf8      	bge.n	80003e2 <write_ref_codeword+0x102>
 80003f0:	80a3      	strh	r3, [r4, #4]
 80003f2:	80e2      	strh	r2, [r4, #6]
 80003f4:	3501      	adds	r5, #1
{
    uint16_t offset = font->dictionary_offsets[index];
    uint16_t length = font->dictionary_offsets[index + 1] - offset;
    uint16_t i;
    
    for (i = 0; i < length; i++)
 80003f6:	42bd      	cmp	r5, r7
 80003f8:	d1e1      	bne.n	80003be <write_ref_codeword+0xde>
 80003fa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        uint8_t code = font->dictionary_data[offset + i];
        if ((code & RLE_CODEMASK) == RLE_ZEROS)
        {
            skip_pixels(rstate, code & RLE_VALMASK);
        }
        else if ((code & RLE_CODEMASK) == RLE_64ZEROS)
 80003fc:	2b40      	cmp	r3, #64	; 0x40
 80003fe:	d00f      	beq.n	8000420 <write_ref_codeword+0x140>
        {
            skip_pixels(rstate, ((code & RLE_VALMASK) + 1) * 64);
        }
        else if ((code & RLE_CODEMASK) == RLE_ONES)
 8000400:	2b80      	cmp	r3, #128	; 0x80
 8000402:	d026      	beq.n	8000452 <write_ref_codeword+0x172>
        {
            write_pixels(rstate, (code & RLE_VALMASK) + 1, 255);
        }
        else if ((code & RLE_CODEMASK) == RLE_SHADE)
 8000404:	2bc0      	cmp	r3, #192	; 0xc0
 8000406:	d1f5      	bne.n	80003f4 <write_ref_codeword+0x114>
        {
            uint8_t count, alpha;
            count = ((code & RLE_VALMASK) >> 4) + 1;
            alpha = ((code & RLE_VALMASK) & 0xF) * 0x11;
            write_pixels(rstate, count, alpha);
 8000408:	f000 020f 	and.w	r2, r0, #15
 800040c:	f3c0 1101 	ubfx	r1, r0, #4, #2
 8000410:	eb02 1202 	add.w	r2, r2, r2, lsl #4
 8000414:	b2d2      	uxtb	r2, r2
 8000416:	3101      	adds	r1, #1
 8000418:	4620      	mov	r0, r4
 800041a:	f7ff ff29 	bl	8000270 <write_pixels>
 800041e:	e7e9      	b.n	80003f4 <write_ref_codeword+0x114>
}

/* Skip the given number of pixels (0 alpha) */
static void skip_pixels(struct renderstate_r *rstate, uint16_t count)
{
    rstate->x += count;
 8000420:	88a2      	ldrh	r2, [r4, #4]
 8000422:	f000 033f 	and.w	r3, r0, #63	; 0x3f
 8000426:	3301      	adds	r3, #1
 8000428:	eb02 1383 	add.w	r3, r2, r3, lsl #6
    while (rstate->x >= rstate->x_end)
 800042c:	f9b4 1002 	ldrsh.w	r1, [r4, #2]
}

/* Skip the given number of pixels (0 alpha) */
static void skip_pixels(struct renderstate_r *rstate, uint16_t count)
{
    rstate->x += count;
 8000430:	b21b      	sxth	r3, r3
    while (rstate->x >= rstate->x_end)
 8000432:	428b      	cmp	r3, r1
}

/* Skip the given number of pixels (0 alpha) */
static void skip_pixels(struct renderstate_r *rstate, uint16_t count)
{
    rstate->x += count;
 8000434:	80a3      	strh	r3, [r4, #4]
    while (rstate->x >= rstate->x_end)
 8000436:	dbdd      	blt.n	80003f4 <write_ref_codeword+0x114>
 8000438:	f8b4 e000 	ldrh.w	lr, [r4]
 800043c:	f9b4 2006 	ldrsh.w	r2, [r4, #6]
 8000440:	b288      	uxth	r0, r1
 8000442:	4473      	add	r3, lr
 8000444:	1a1b      	subs	r3, r3, r0
 8000446:	b21b      	sxth	r3, r3
 8000448:	3201      	adds	r2, #1
 800044a:	428b      	cmp	r3, r1
 800044c:	b212      	sxth	r2, r2
 800044e:	daf8      	bge.n	8000442 <write_ref_codeword+0x162>
 8000450:	e7ce      	b.n	80003f0 <write_ref_codeword+0x110>
        {
            skip_pixels(rstate, ((code & RLE_VALMASK) + 1) * 64);
        }
        else if ((code & RLE_CODEMASK) == RLE_ONES)
        {
            write_pixels(rstate, (code & RLE_VALMASK) + 1, 255);
 8000452:	f000 013f 	and.w	r1, r0, #63	; 0x3f
 8000456:	3101      	adds	r1, #1
 8000458:	22ff      	movs	r2, #255	; 0xff
 800045a:	4620      	mov	r0, r4
 800045c:	f7ff ff08 	bl	8000270 <write_pixels>
 8000460:	e7c8      	b.n	80003f4 <write_ref_codeword+0x114>
/* Get bit count for the "fill entries" */
static uint8_t fillentry_bitcount(uint8_t index)
{
    if (index >= DICT_START2BIT)
        return 2;
    else if (index >= DICT_START3BIT)
 8000462:	2602      	movs	r6, #2
 8000464:	e74d      	b.n	8000302 <write_ref_codeword+0x22>
        return 3;
    else if (index >= DICT_START4BIT)
 8000466:	2603      	movs	r6, #3
 8000468:	e74b      	b.n	8000302 <write_ref_codeword+0x22>
        return 4;
    else if (index >= DICT_START5BIT)
 800046a:	2604      	movs	r6, #4
 800046c:	e749      	b.n	8000302 <write_ref_codeword+0x22>
 800046e:	bf00      	nop

08000470 <mf_rlefont_render_character>:
uint8_t mf_rlefont_render_character(const struct mf_font_s *font,
                                    int16_t x0, int16_t y0,
                                    uint16_t character,
                                    mf_pixel_callback_t callback,
                                    void *state)
{
 8000470:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    struct renderstate_r rstate;
    rstate.x_begin = x0;
    rstate.x_end = x0 + font->width;
    rstate.x = x0;
    rstate.y = y0;
    rstate.y_end = y0 + font->height;
 8000474:	f890 e009 	ldrb.w	lr, [r0, #9]
    const uint8_t *p;
    uint8_t width;
    
    struct renderstate_r rstate;
    rstate.x_begin = x0;
    rstate.x_end = x0 + font->width;
 8000478:	7a06      	ldrb	r6, [r0, #8]
uint8_t mf_rlefont_render_character(const struct mf_font_s *font,
                                    int16_t x0, int16_t y0,
                                    uint16_t character,
                                    mf_pixel_callback_t callback,
                                    void *state)
{
 800047a:	b086      	sub	sp, #24
    const uint8_t *p;
    uint8_t width;
    
    struct renderstate_r rstate;
    rstate.x_begin = x0;
    rstate.x_end = x0 + font->width;
 800047c:	440e      	add	r6, r1
    rstate.x = x0;
    rstate.y = y0;
    rstate.y_end = y0 + font->height;
 800047e:	4496      	add	lr, r2
uint8_t mf_rlefont_render_character(const struct mf_font_s *font,
                                    int16_t x0, int16_t y0,
                                    uint16_t character,
                                    mf_pixel_callback_t callback,
                                    void *state)
{
 8000480:	9c0c      	ldr	r4, [sp, #48]	; 0x30
    const uint8_t *p;
    uint8_t width;
    
    struct renderstate_r rstate;
    rstate.x_begin = x0;
 8000482:	f8ad 1004 	strh.w	r1, [sp, #4]
    rstate.x_end = x0 + font->width;
    rstate.x = x0;
 8000486:	f8ad 1008 	strh.w	r1, [sp, #8]
static const uint8_t *find_glyph(const struct mf_rlefont_s *font,
                                 uint16_t character)
{
   unsigned i, index;
   const struct mf_rlefont_char_range_s *range;
   for (i = 0; i < font->char_range_count; i++)
 800048a:	f890 502a 	ldrb.w	r5, [r0, #42]	; 0x2a
uint8_t mf_rlefont_render_character(const struct mf_font_s *font,
                                    int16_t x0, int16_t y0,
                                    uint16_t character,
                                    mf_pixel_callback_t callback,
                                    void *state)
{
 800048e:	990d      	ldr	r1, [sp, #52]	; 0x34
    struct renderstate_r rstate;
    rstate.x_begin = x0;
    rstate.x_end = x0 + font->width;
    rstate.x = x0;
    rstate.y = y0;
    rstate.y_end = y0 + font->height;
 8000490:	fa0f fe8e 	sxth.w	lr, lr
    
    struct renderstate_r rstate;
    rstate.x_begin = x0;
    rstate.x_end = x0 + font->width;
    rstate.x = x0;
    rstate.y = y0;
 8000494:	f8ad 200a 	strh.w	r2, [sp, #10]
    const uint8_t *p;
    uint8_t width;
    
    struct renderstate_r rstate;
    rstate.x_begin = x0;
    rstate.x_end = x0 + font->width;
 8000498:	f8ad 6006 	strh.w	r6, [sp, #6]
    rstate.x = x0;
    rstate.y = y0;
    rstate.y_end = y0 + font->height;
 800049c:	f8ad e00c 	strh.w	lr, [sp, #12]
    rstate.callback = callback;
 80004a0:	9404      	str	r4, [sp, #16]
    rstate.state = state;
 80004a2:	9105      	str	r1, [sp, #20]
static const uint8_t *find_glyph(const struct mf_rlefont_s *font,
                                 uint16_t character)
{
   unsigned i, index;
   const struct mf_rlefont_char_range_s *range;
   for (i = 0; i < font->char_range_count; i++)
 80004a4:	b175      	cbz	r5, 80004c4 <mf_rlefont_render_character+0x54>
 80004a6:	6ac1      	ldr	r1, [r0, #44]	; 0x2c
 80004a8:	2400      	movs	r4, #0
   {
       range = &font->char_ranges[i];
       index = character - range->first_char;
 80004aa:	880e      	ldrh	r6, [r1, #0]
static const uint8_t *find_glyph(const struct mf_rlefont_s *font,
                                 uint16_t character)
{
   unsigned i, index;
   const struct mf_rlefont_char_range_s *range;
   for (i = 0; i < font->char_range_count; i++)
 80004ac:	3401      	adds	r4, #1
   {
       range = &font->char_ranges[i];
       index = character - range->first_char;
       if (character >= range->first_char && index < range->char_count)
 80004ae:	42b3      	cmp	r3, r6
   unsigned i, index;
   const struct mf_rlefont_char_range_s *range;
   for (i = 0; i < font->char_range_count; i++)
   {
       range = &font->char_ranges[i];
       index = character - range->first_char;
 80004b0:	eba3 0706 	sub.w	r7, r3, r6
       if (character >= range->first_char && index < range->char_count)
 80004b4:	d302      	bcc.n	80004bc <mf_rlefont_render_character+0x4c>
 80004b6:	884e      	ldrh	r6, [r1, #2]
 80004b8:	42b7      	cmp	r7, r6
 80004ba:	d307      	bcc.n	80004cc <mf_rlefont_render_character+0x5c>
static const uint8_t *find_glyph(const struct mf_rlefont_s *font,
                                 uint16_t character)
{
   unsigned i, index;
   const struct mf_rlefont_char_range_s *range;
   for (i = 0; i < font->char_range_count; i++)
 80004bc:	42ac      	cmp	r4, r5
 80004be:	f101 010c 	add.w	r1, r1, #12
 80004c2:	d1f2      	bne.n	80004aa <mf_rlefont_render_character+0x3a>
    rstate.callback = callback;
    rstate.state = state;
    
   	p = find_glyph((struct mf_rlefont_s*)font, character);
    if (!p)
        return 0;
 80004c4:	2000      	movs	r0, #0
    {
        write_glyph_codeword((struct mf_rlefont_s*)font, &rstate, *p++);
    }
    
    return width;
}
 80004c6:	b006      	add	sp, #24
 80004c8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   {
       range = &font->char_ranges[i];
       index = character - range->first_char;
       if (character >= range->first_char && index < range->char_count)
       {
           uint16_t offset = range->glyph_offsets[index];
 80004cc:	684b      	ldr	r3, [r1, #4]
           return &range->glyph_data[offset];
 80004ce:	6889      	ldr	r1, [r1, #8]
 80004d0:	f833 3017 	ldrh.w	r3, [r3, r7, lsl #1]
    rstate.y_end = y0 + font->height;
    rstate.callback = callback;
    rstate.state = state;
    
   	p = find_glyph((struct mf_rlefont_s*)font, character);
    if (!p)
 80004d4:	18cf      	adds	r7, r1, r3
 80004d6:	d03a      	beq.n	800054e <mf_rlefont_render_character+0xde>
 80004d8:	4605      	mov	r5, r0
        return 0;
    
    width = *p++;
 80004da:	3701      	adds	r7, #1
 80004dc:	5cce      	ldrb	r6, [r1, r3]
 80004de:	4610      	mov	r0, r2
 80004e0:	e007      	b.n	80004f2 <mf_rlefont_render_character+0x82>
    {
        write_ref_dictentry(font, rstate, code - DICT_START);
    }
    else
    {
        write_ref_codeword(font, rstate, code);
 80004e2:	a901      	add	r1, sp, #4
 80004e4:	4628      	mov	r0, r5
 80004e6:	f7ff fefb 	bl	80002e0 <write_ref_codeword>
 80004ea:	f9bd 000a 	ldrsh.w	r0, [sp, #10]
 80004ee:	f9bd e00c 	ldrsh.w	lr, [sp, #12]
   	p = find_glyph((struct mf_rlefont_s*)font, character);
    if (!p)
        return 0;
    
    width = *p++;
    while (rstate.y < rstate.y_end)
 80004f2:	4570      	cmp	r0, lr
 80004f4:	da27      	bge.n	8000546 <mf_rlefont_render_character+0xd6>
/* Decode and write out an arbitrary glyph codeword */
static void write_glyph_codeword(const struct mf_rlefont_s *font,
                                struct renderstate_r *rstate,
                                uint8_t code)
{
    if (code >= DICT_START + font->rle_entry_count &&
 80004f6:	f895 3028 	ldrb.w	r3, [r5, #40]	; 0x28
        return 0;
    
    width = *p++;
    while (rstate.y < rstate.y_end)
    {
        write_glyph_codeword((struct mf_rlefont_s*)font, &rstate, *p++);
 80004fa:	f817 2b01 	ldrb.w	r2, [r7], #1
/* Decode and write out an arbitrary glyph codeword */
static void write_glyph_codeword(const struct mf_rlefont_s *font,
                                struct renderstate_r *rstate,
                                uint8_t code)
{
    if (code >= DICT_START + font->rle_entry_count &&
 80004fe:	3317      	adds	r3, #23
 8000500:	4293      	cmp	r3, r2
 8000502:	daee      	bge.n	80004e2 <mf_rlefont_render_character+0x72>
 8000504:	f895 3029 	ldrb.w	r3, [r5, #41]	; 0x29
 8000508:	3317      	adds	r3, #23
 800050a:	429a      	cmp	r2, r3
 800050c:	dce9      	bgt.n	80004e2 <mf_rlefont_render_character+0x72>
/* Decode and write out a reference encoded dictionary entry. */
static void write_ref_dictentry(const struct mf_rlefont_s *font,
                                struct renderstate_r *rstate,
                                uint8_t index)
{
    uint16_t offset = font->dictionary_offsets[index];
 800050e:	f1a2 0318 	sub.w	r3, r2, #24
 8000512:	6a6a      	ldr	r2, [r5, #36]	; 0x24
 8000514:	b2db      	uxtb	r3, r3
    uint16_t length = font->dictionary_offsets[index + 1] - offset;
 8000516:	eb02 0143 	add.w	r1, r2, r3, lsl #1
 800051a:	8849      	ldrh	r1, [r1, #2]
/* Decode and write out a reference encoded dictionary entry. */
static void write_ref_dictentry(const struct mf_rlefont_s *font,
                                struct renderstate_r *rstate,
                                uint8_t index)
{
    uint16_t offset = font->dictionary_offsets[index];
 800051c:	f832 4013 	ldrh.w	r4, [r2, r3, lsl #1]
    uint16_t length = font->dictionary_offsets[index + 1] - offset;
 8000520:	1b0b      	subs	r3, r1, r4
 8000522:	b29b      	uxth	r3, r3
    uint16_t i;
    
    for (i = 0; i < length; i++)
 8000524:	2b00      	cmp	r3, #0
 8000526:	d0e4      	beq.n	80004f2 <mf_rlefont_render_character+0x82>
 8000528:	3b01      	subs	r3, #1
 800052a:	b29b      	uxth	r3, r3
 800052c:	f104 0801 	add.w	r8, r4, #1
 8000530:	4498      	add	r8, r3
    {
        uint8_t code = font->dictionary_data[offset + i];
 8000532:	6a2b      	ldr	r3, [r5, #32]
        write_ref_codeword(font, rstate, code);
 8000534:	a901      	add	r1, sp, #4
 8000536:	5d1a      	ldrb	r2, [r3, r4]
 8000538:	4628      	mov	r0, r5
 800053a:	3401      	adds	r4, #1
 800053c:	f7ff fed0 	bl	80002e0 <write_ref_codeword>
{
    uint16_t offset = font->dictionary_offsets[index];
    uint16_t length = font->dictionary_offsets[index + 1] - offset;
    uint16_t i;
    
    for (i = 0; i < length; i++)
 8000540:	45a0      	cmp	r8, r4
 8000542:	d1f6      	bne.n	8000532 <mf_rlefont_render_character+0xc2>
 8000544:	e7d1      	b.n	80004ea <mf_rlefont_render_character+0x7a>
    while (rstate.y < rstate.y_end)
    {
        write_glyph_codeword((struct mf_rlefont_s*)font, &rstate, *p++);
    }
    
    return width;
 8000546:	4630      	mov	r0, r6
}
 8000548:	b006      	add	sp, #24
 800054a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    rstate.callback = callback;
    rstate.state = state;
    
   	p = find_glyph((struct mf_rlefont_s*)font, character);
    if (!p)
        return 0;
 800054e:	4638      	mov	r0, r7
 8000550:	e7b9      	b.n	80004c6 <mf_rlefont_render_character+0x56>
 8000552:	bf00      	nop
	...

08000560 <fillcharglyph.lto_priv.36>:
			return mf_render_character(GD->t.font, x, y, ch, drawcharline, state);
		#undef GD
	}

	/* Callback to render characters. */
	static uint8_t fillcharglyph(int16_t x, int16_t y, mf_char ch, void *state) {
 8000560:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8000564:	4606      	mov	r6, r0
                            mf_char character,
                            mf_pixel_callback_t callback,
                            void *state)
{
    uint8_t width;
    width = font->render_character(font, x0, y0, character, callback, state);
 8000566:	f8df 9038 	ldr.w	r9, [pc, #56]	; 80005a0 <fillcharglyph.lto_priv.36+0x40>
		#define GD	((GDisplay *)state)
			return mf_render_character(GD->t.font, x, y, ch, fillcharline, state);
 800056a:	6b9c      	ldr	r4, [r3, #56]	; 0x38
			return mf_render_character(GD->t.font, x, y, ch, drawcharline, state);
		#undef GD
	}

	/* Callback to render characters. */
	static uint8_t fillcharglyph(int16_t x, int16_t y, mf_char ch, void *state) {
 800056c:	b083      	sub	sp, #12
 800056e:	9301      	str	r3, [sp, #4]
 8000570:	f8cd 9000 	str.w	r9, [sp]
 8000574:	461d      	mov	r5, r3
 8000576:	4688      	mov	r8, r1
 8000578:	4613      	mov	r3, r2
 800057a:	4620      	mov	r0, r4
 800057c:	460a      	mov	r2, r1
 800057e:	69a7      	ldr	r7, [r4, #24]
 8000580:	4631      	mov	r1, r6
 8000582:	47b8      	blx	r7
    
    if (!width)
 8000584:	b940      	cbnz	r0, 8000598 <fillcharglyph.lto_priv.36+0x38>
    {
        width = font->render_character(font, x0, y0, font->fallback_character,
 8000586:	8a23      	ldrh	r3, [r4, #16]
 8000588:	9501      	str	r5, [sp, #4]
 800058a:	f8cd 9000 	str.w	r9, [sp]
 800058e:	4642      	mov	r2, r8
 8000590:	4631      	mov	r1, r6
 8000592:	69a5      	ldr	r5, [r4, #24]
 8000594:	4620      	mov	r0, r4
 8000596:	47a8      	blx	r5
		#define GD	((GDisplay *)state)
			return mf_render_character(GD->t.font, x, y, ch, fillcharline, state);
		#undef GD
	}
 8000598:	b003      	add	sp, #12
 800059a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 800059e:	bf00      	nop
 80005a0:	08000621 	.word	0x08000621
	...

080005b0 <_gdispDeInitDriver>:
}

void _gdispDeInitDriver(GDriver *g) {
	#define		gd		((GDisplay *)g)

	if (GDISP == gd)
 80005b0:	4906      	ldr	r1, [pc, #24]	; (80005cc <_gdispDeInitDriver+0x1c>)
 80005b2:	680b      	ldr	r3, [r1, #0]
 80005b4:	4283      	cmp	r3, r0
 80005b6:	d000      	beq.n	80005ba <_gdispDeInitDriver+0xa>
 80005b8:	4770      	bx	lr
	GDriver		*pd;
	unsigned	sinstance;

	// Loop to find the system instance
	sinstance = 0;
	for(pd = dhead; pd; pd = pd->driverchain) {
 80005ba:	4b05      	ldr	r3, [pc, #20]	; (80005d0 <_gdispDeInitDriver+0x20>)
 80005bc:	681b      	ldr	r3, [r3, #0]
 80005be:	b11b      	cbz	r3, 80005c8 <_gdispDeInitDriver+0x18>
		if (pd->vmt->type == type) {
 80005c0:	685a      	ldr	r2, [r3, #4]
 80005c2:	8812      	ldrh	r2, [r2, #0]
 80005c4:	2a67      	cmp	r2, #103	; 0x67
 80005c6:	d1f9      	bne.n	80005bc <_gdispDeInitDriver+0xc>
		GDISP = (GDisplay *)gdriverGetInstance(GDRIVER_TYPE_DISPLAY, 0);
 80005c8:	600b      	str	r3, [r1, #0]
 80005ca:	4770      	bx	lr
 80005cc:	200009fc 	.word	0x200009fc
 80005d0:	20000808 	.word	0x20000808
	...

080005e0 <i2c_lld_serve_tx_end_irq.lto_priv.35>:
static void i2c_lld_serve_tx_end_irq(I2CDriver *i2cp, uint32_t flags) {
  I2C_TypeDef *dp = i2cp->i2c;

  /* DMA errors handling.*/
#if defined(STM32_I2C_DMA_ERROR_HOOK)
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
 80005e0:	070b      	lsls	r3, r1, #28
 80005e2:	d412      	bmi.n	800060a <i2c_lld_serve_tx_end_irq.lto_priv.35+0x2a>
  }
#else
  (void)flags;
#endif

  dmaStreamDisable(i2cp->dmatx);
 80005e4:	6b02      	ldr	r2, [r0, #48]	; 0x30
 *
 * @param[in] i2cp      pointer to the @p I2CDriver object
 *
 * @notapi
 */
static void i2c_lld_serve_tx_end_irq(I2CDriver *i2cp, uint32_t flags) {
 80005e6:	b430      	push	{r4, r5}
  }
#else
  (void)flags;
#endif

  dmaStreamDisable(i2cp->dmatx);
 80005e8:	6854      	ldr	r4, [r2, #4]
 80005ea:	6815      	ldr	r5, [r2, #0]
 80005ec:	6821      	ldr	r1, [r4, #0]
 * @param[in] i2cp      pointer to the @p I2CDriver object
 *
 * @notapi
 */
static void i2c_lld_serve_tx_end_irq(I2CDriver *i2cp, uint32_t flags) {
  I2C_TypeDef *dp = i2cp->i2c;
 80005ee:	6b40      	ldr	r0, [r0, #52]	; 0x34
  }
#else
  (void)flags;
#endif

  dmaStreamDisable(i2cp->dmatx);
 80005f0:	f021 010f 	bic.w	r1, r1, #15
 80005f4:	6021      	str	r1, [r4, #0]
 80005f6:	7c12      	ldrb	r2, [r2, #16]
 80005f8:	230f      	movs	r3, #15
 80005fa:	4093      	lsls	r3, r2
 80005fc:	606b      	str	r3, [r5, #4]
  /* Enables interrupts to catch BTF event meaning transmission part complete.
     Interrupt handler will decide to generate STOP or to begin receiving part
     of R/W transaction itself.*/
  dp->CR2 |= I2C_CR2_ITEVTEN;
 80005fe:	6843      	ldr	r3, [r0, #4]
}
 8000600:	bc30      	pop	{r4, r5}

  dmaStreamDisable(i2cp->dmatx);
  /* Enables interrupts to catch BTF event meaning transmission part complete.
     Interrupt handler will decide to generate STOP or to begin receiving part
     of R/W transaction itself.*/
  dp->CR2 |= I2C_CR2_ITEVTEN;
 8000602:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 8000606:	6043      	str	r3, [r0, #4]
}
 8000608:	4770      	bx	lr
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800060a:	b672      	cpsid	i

  /* Logging the event.*/
  _trace_halt(reason);

  /* Pointing to the passed message.*/
  ch.dbg.panic_msg = reason;
 800060c:	4b01      	ldr	r3, [pc, #4]	; (8000614 <i2c_lld_serve_tx_end_irq.lto_priv.35+0x34>)
 800060e:	4a02      	ldr	r2, [pc, #8]	; (8000618 <i2c_lld_serve_tx_end_irq.lto_priv.35+0x38>)
 8000610:	629a      	str	r2, [r3, #40]	; 0x28
 8000612:	e7fe      	b.n	8000612 <i2c_lld_serve_tx_end_irq.lto_priv.35+0x32>
 8000614:	20000918 	.word	0x20000918
 8000618:	0800284c 	.word	0x0800284c
 800061c:	00000000 	.word	0x00000000

08000620 <drawcharline>:
				}
			}
			#undef GD
		}
	#else
		static void drawcharline(int16_t x, int16_t y, uint8_t count, uint8_t alpha, void *state) {
 8000620:	b4f0      	push	{r4, r5, r6, r7}
 8000622:	9c04      	ldr	r4, [sp, #16]
			#define GD	((GDisplay *)state)
			if (y < GD->t.clipy0 || y >= GD->t.clipy1 || x+count <= GD->t.clipx0 || x >= GD->t.clipx1)
 8000624:	f9b4 5040 	ldrsh.w	r5, [r4, #64]	; 0x40
 8000628:	428d      	cmp	r5, r1
 800062a:	dc31      	bgt.n	8000690 <drawcharline+0x70>
 800062c:	f9b4 5044 	ldrsh.w	r5, [r4, #68]	; 0x44
 8000630:	428d      	cmp	r5, r1
 8000632:	dd2d      	ble.n	8000690 <drawcharline+0x70>
 8000634:	f9b4 503e 	ldrsh.w	r5, [r4, #62]	; 0x3e
 8000638:	1886      	adds	r6, r0, r2
 800063a:	42ae      	cmp	r6, r5
 800063c:	dd28      	ble.n	8000690 <drawcharline+0x70>
 800063e:	f9b4 7042 	ldrsh.w	r7, [r4, #66]	; 0x42
 8000642:	42b8      	cmp	r0, r7
 8000644:	da24      	bge.n	8000690 <drawcharline+0x70>
				return;
			if (x < GD->t.clipx0) {
 8000646:	42a8      	cmp	r0, r5
 8000648:	da05      	bge.n	8000656 <drawcharline+0x36>
 800064a:	1b52      	subs	r2, r2, r5
				count -= GD->t.clipx0 - x;
 800064c:	4402      	add	r2, r0
 800064e:	4628      	mov	r0, r5
 8000650:	f002 02ff 	and.w	r2, r2, #255	; 0xff
 8000654:	1956      	adds	r6, r2, r5
				x = GD->t.clipx0;
			}
			if (x+count > GD->t.clipx1)
 8000656:	42b7      	cmp	r7, r6
				count = GD->t.clipx1 - x;
 8000658:	bfbc      	itt	lt
 800065a:	1a3a      	sublt	r2, r7, r0
 800065c:	b2d2      	uxtblt	r2, r2
			if (alpha > 0x80) {			// A best approximation when using anti-aliased fonts but we can't actually draw them anti-aliased
 800065e:	2b80      	cmp	r3, #128	; 0x80
 8000660:	d916      	bls.n	8000690 <drawcharline+0x70>
				GD->p.x = x; GD->p.y = y; GD->p.x1 = x+count-1; GD->p.color = GD->t.color;
 8000662:	1e43      	subs	r3, r0, #1
 8000664:	441a      	add	r2, r3
 8000666:	b212      	sxth	r2, r2
 8000668:	f894 303c 	ldrb.w	r3, [r4, #60]	; 0x3c
// Alters:		x,y x1,y1 cx,cy
// Assumes the window covers the screen and a write_stop() will occur later
//	if GDISP_HARDWARE_STREAM_WRITE and GDISP_HARDWARE_STREAM_POS is set.
static void hline_clip(GDisplay *g) {
	// Swap the points if necessary so it always goes from x to x1
	if (g->p.x1 < g->p.x) {
 800066c:	4290      	cmp	r0, r2
				x = GD->t.clipx0;
			}
			if (x+count > GD->t.clipx1)
				count = GD->t.clipx1 - x;
			if (alpha > 0x80) {			// A best approximation when using anti-aliased fonts but we can't actually draw them anti-aliased
				GD->p.x = x; GD->p.y = y; GD->p.x1 = x+count-1; GD->p.color = GD->t.color;
 800066e:	8420      	strh	r0, [r4, #32]
 8000670:	8461      	strh	r1, [r4, #34]	; 0x22
 8000672:	8522      	strh	r2, [r4, #40]	; 0x28
 8000674:	f884 3030 	strb.w	r3, [r4, #48]	; 0x30
// Alters:		x,y x1,y1 cx,cy
// Assumes the window covers the screen and a write_stop() will occur later
//	if GDISP_HARDWARE_STREAM_WRITE and GDISP_HARDWARE_STREAM_POS is set.
static void hline_clip(GDisplay *g) {
	// Swap the points if necessary so it always goes from x to x1
	if (g->p.x1 < g->p.x) {
 8000678:	dc0c      	bgt.n	8000694 <drawcharline+0x74>

	// This is an optimization for the point case. It is only worthwhile however if we
	// have hardware fills or if we support both hardware pixel drawing and hardware streaming
	#if GDISP_HARDWARE_FILLS || (GDISP_HARDWARE_DRAWPIXEL && GDISP_HARDWARE_STREAM_WRITE)
		// Is this a point
		if (g->p.x == g->p.x1) {
 800067a:	d010      	beq.n	800069e <drawcharline+0x7e>
 800067c:	4601      	mov	r1, r0
			for (col = sx; col <= ex; col++)
				base[col] |= mask;
		}

        */
		g->flags |= GDISP_FLG_NEEDFLUSH;
 800067e:	8be3      	ldrh	r3, [r4, #30]
	#if GDISP_HARDWARE_FILLS
		#if GDISP_HARDWARE_FILLS == HARDWARE_AUTODETECT
			if (gvmt(g)->fill)
		#endif
		{
			g->p.cx = g->p.x1 - g->p.x + 1;
 8000680:	3201      	adds	r2, #1
 8000682:	1a52      	subs	r2, r2, r1
 8000684:	f043 0304 	orr.w	r3, r3, #4
			g->p.cy = 1;
 8000688:	2101      	movs	r1, #1
	#if GDISP_HARDWARE_FILLS
		#if GDISP_HARDWARE_FILLS == HARDWARE_AUTODETECT
			if (gvmt(g)->fill)
		#endif
		{
			g->p.cx = g->p.x1 - g->p.x + 1;
 800068a:	84a2      	strh	r2, [r4, #36]	; 0x24
 800068c:	83e3      	strh	r3, [r4, #30]
			g->p.cy = 1;
 800068e:	84e1      	strh	r1, [r4, #38]	; 0x26
			if (alpha > 0x80) {			// A best approximation when using anti-aliased fonts but we can't actually draw them anti-aliased
				GD->p.x = x; GD->p.y = y; GD->p.x1 = x+count-1; GD->p.color = GD->t.color;
				hline_clip(GD);
			}
			#undef GD
		}
 8000690:	bcf0      	pop	{r4, r5, r6, r7}
 8000692:	4770      	bx	lr
// Assumes the window covers the screen and a write_stop() will occur later
//	if GDISP_HARDWARE_STREAM_WRITE and GDISP_HARDWARE_STREAM_POS is set.
static void hline_clip(GDisplay *g) {
	// Swap the points if necessary so it always goes from x to x1
	if (g->p.x1 < g->p.x) {
		g->p.cx = g->p.x; g->p.x = g->p.x1; g->p.x1 = g->p.cx;
 8000694:	8422      	strh	r2, [r4, #32]
 8000696:	4611      	mov	r1, r2
 8000698:	8520      	strh	r0, [r4, #40]	; 0x28
 800069a:	4602      	mov	r2, r0
 800069c:	e7ef      	b.n	800067e <drawcharline+0x5e>
	#if GDISP_HARDWARE_DRAWPIXEL
		#if GDISP_HARDWARE_DRAWPIXEL == HARDWARE_AUTODETECT
			if (gvmt(g)->pixel)
		#endif
		{
			gdisp_lld_draw_pixel(g);
 800069e:	4620      	mov	r0, r4
			if (alpha > 0x80) {			// A best approximation when using anti-aliased fonts but we can't actually draw them anti-aliased
				GD->p.x = x; GD->p.y = y; GD->p.x1 = x+count-1; GD->p.color = GD->t.color;
				hline_clip(GD);
			}
			#undef GD
		}
 80006a0:	bcf0      	pop	{r4, r5, r6, r7}
	#if GDISP_HARDWARE_DRAWPIXEL
		#if GDISP_HARDWARE_DRAWPIXEL == HARDWARE_AUTODETECT
			if (gvmt(g)->pixel)
		#endif
		{
			gdisp_lld_draw_pixel(g);
 80006a2:	f000 bc35 	b.w	8000f10 <gdisp_lld_draw_pixel>
 80006a6:	bf00      	nop
	...

080006b0 <_gdispPostInitDriver>:
	return ret;

	#undef gd
}

void _gdispPostInitDriver(GDriver *g) {
 80006b0:	b538      	push	{r3, r4, r5, lr}
 80006b2:	4604      	mov	r4, r0
 80006b4:	8bc2      	ldrh	r2, [r0, #30]
			if (gvmt(g)->fill)
		#endif
		{
			g->p.x = g->p.y = 0;
			g->p.cx = g->g.Width;
			g->p.cy = g->g.Height;
 80006b6:	8941      	ldrh	r1, [r0, #10]
		#if GDISP_HARDWARE_FILLS == HARDWARE_AUTODETECT
			if (gvmt(g)->fill)
		#endif
		{
			g->p.x = g->p.y = 0;
			g->p.cx = g->g.Width;
 80006b8:	8905      	ldrh	r5, [r0, #8]
	#if GDISP_HARDWARE_CLEARS != TRUE && GDISP_HARDWARE_FILLS
		#if GDISP_HARDWARE_FILLS == HARDWARE_AUTODETECT
			if (gvmt(g)->fill)
		#endif
		{
			g->p.x = g->p.y = 0;
 80006ba:	2300      	movs	r3, #0
 80006bc:	f042 0204 	orr.w	r2, r2, #4
 80006c0:	83c2      	strh	r2, [r0, #30]
 80006c2:	8443      	strh	r3, [r0, #34]	; 0x22
 80006c4:	8403      	strh	r3, [r0, #32]
			g->p.cx = g->g.Width;
			g->p.cy = g->g.Height;
			g->p.color = color;
 80006c6:	f880 3030 	strb.w	r3, [r0, #48]	; 0x30
			if (gvmt(g)->fill)
		#endif
		{
			g->p.x = g->p.y = 0;
			g->p.cx = g->g.Width;
			g->p.cy = g->g.Height;
 80006ca:	84c1      	strh	r1, [r0, #38]	; 0x26
		#if GDISP_HARDWARE_FILLS == HARDWARE_AUTODETECT
			if (gvmt(g)->fill)
		#endif
		{
			g->p.x = g->p.y = 0;
			g->p.cx = g->g.Width;
 80006cc:	8485      	strh	r5, [r0, #36]	; 0x24
			g->p.cy = g->g.Height;
			g->p.color = color;
			gdisp_lld_fill_area(g);
			autoflush_stopdone(g);
 80006ce:	f000 fd9f 	bl	8001210 <gdisp_lld_flush>
		#if GDISP_HARDWARE_FLUSH == HARDWARE_AUTODETECT
			if (gvmt(g)->flush)
		#endif
		{
			MUTEX_ENTER(g);
			gdisp_lld_flush(g);
 80006d2:	4620      	mov	r0, r4
 80006d4:	f000 fd9c 	bl	8001210 <gdisp_lld_flush>
	#if GDISP_HARDWARE_FLUSH
		gdispGFlush(gd);
	#endif

	// If this is the first driver set GDISP
	if (!GDISP)
 80006d8:	4b02      	ldr	r3, [pc, #8]	; (80006e4 <_gdispPostInitDriver+0x34>)
 80006da:	681a      	ldr	r2, [r3, #0]
 80006dc:	b102      	cbz	r2, 80006e0 <_gdispPostInitDriver+0x30>
 80006de:	bd38      	pop	{r3, r4, r5, pc}
		GDISP = gd;
 80006e0:	601c      	str	r4, [r3, #0]
 80006e2:	bd38      	pop	{r3, r4, r5, pc}
 80006e4:	200009fc 	.word	0x200009fc
	...

080006f0 <_gdispInitDriver>:
void _gdispDeinit(void)
{
	/* ToDo */
}

bool_t _gdispInitDriver(GDriver *g, void *param, unsigned driverinstance, unsigned systeminstance) {
 80006f0:	b430      	push	{r4, r5}
	bool_t		ret;

	// Intialise fields
	gd->systemdisplay = systeminstance;
	gd->controllerdisplay = driverinstance;
	gd->flags = 0;
 80006f2:	2500      	movs	r5, #0
bool_t _gdispInitDriver(GDriver *g, void *param, unsigned driverinstance, unsigned systeminstance) {
	#define		gd		((GDisplay *)g)
	bool_t		ret;

	// Intialise fields
	gd->systemdisplay = systeminstance;
 80006f4:	7703      	strb	r3, [r0, #28]
	gd->controllerdisplay = driverinstance;
 80006f6:	7742      	strb	r2, [r0, #29]
	gd->flags = 0;
 80006f8:	83c5      	strh	r5, [r0, #30]
	gd->priv = param;
 80006fa:	6141      	str	r1, [r0, #20]
	ret = gdisp_lld_init(gd);
	MUTEX_EXIT(gd);
	return ret;

	#undef gd
}
 80006fc:	bc30      	pop	{r4, r5}
	gd->priv = param;
	MUTEX_INIT(gd);

	// Call the driver init
	MUTEX_ENTER(gd);
	ret = gdisp_lld_init(gd);
 80006fe:	f000 bdef 	b.w	80012e0 <gdisp_lld_init>
 8000702:	bf00      	nop
	...

08000710 <VectorB0>:
 * @brief   TIM2 interrupt handler.
 * @details This interrupt is used for system tick in free running mode.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(ST_HANDLER) {
 8000710:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  OSAL_IRQ_PROLOGUE();

  /* Note, under rare circumstances an interrupt can remain latched even if
     the timer SR register has been cleared, in those cases the interrupt
     is simply ignored.*/
  if ((STM32_ST_TIM->SR & TIM_SR_CC1IF) != 0U) {
 8000714:	f04f 4480 	mov.w	r4, #1073741824	; 0x40000000
 8000718:	6923      	ldr	r3, [r4, #16]
 800071a:	079b      	lsls	r3, r3, #30
 800071c:	d403      	bmi.n	8000726 <VectorB0+0x16>
    osalOsTimerHandlerI();
    osalSysUnlockFromISR();
  }

  OSAL_IRQ_EPILOGUE();
}
 800071e:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    osalSysLockFromISR();
    osalOsTimerHandlerI();
    osalSysUnlockFromISR();
  }

  OSAL_IRQ_EPILOGUE();
 8000722:	f001 b90d 	b.w	8001940 <_port_irq_epilogue>

  /* Note, under rare circumstances an interrupt can remain latched even if
     the timer SR register has been cleared, in those cases the interrupt
     is simply ignored.*/
  if ((STM32_ST_TIM->SR & TIM_SR_CC1IF) != 0U) {
    STM32_ST_TIM->SR = 0U;
 8000726:	2700      	movs	r7, #0
 8000728:	6127      	str	r7, [r4, #16]
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 800072a:	2520      	movs	r5, #32
 800072c:	f385 8811 	msr	BASEPRI, r5
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  virtual_timer_t *vtp;
  systime_t now, delta;

  /* First timer to be processed.*/
  vtp = ch.vtlist.next;
 8000730:	4e1e      	ldr	r6, [pc, #120]	; (80007ac <VectorB0+0x9c>)
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 8000732:	6a62      	ldr	r2, [r4, #36]	; 0x24

  /* All timers within the time window are triggered and removed,
     note that the loop is stopped by the timers header having
     "ch.vtlist.vt_delta == (systime_t)-1" which is greater than
     all deltas.*/
  while (vtp->delta <= (systime_t)(now - ch.vtlist.lasttime)) {
 8000734:	f8b6 e026 	ldrh.w	lr, [r6, #38]	; 0x26
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  virtual_timer_t *vtp;
  systime_t now, delta;

  /* First timer to be processed.*/
  vtp = ch.vtlist.next;
 8000738:	69f3      	ldr	r3, [r6, #28]
 800073a:	b290      	uxth	r0, r2

  /* All timers within the time window are triggered and removed,
     note that the loop is stopped by the timers header having
     "ch.vtlist.vt_delta == (systime_t)-1" which is greater than
     all deltas.*/
  while (vtp->delta <= (systime_t)(now - ch.vtlist.lasttime)) {
 800073c:	ebce 0100 	rsb	r1, lr, r0
 8000740:	891a      	ldrh	r2, [r3, #8]
 8000742:	b289      	uxth	r1, r1
 8000744:	4291      	cmp	r1, r2
 8000746:	f106 081c 	add.w	r8, r6, #28
 800074a:	d31b      	bcc.n	8000784 <VectorB0+0x74>
    vtfunc_t fn;

    /* The "last time" becomes this timer's expiration time.*/
    ch.vtlist.lasttime += vtp->delta;

    vtp->next->prev = (virtual_timer_t *)&ch.vtlist;
 800074c:	6819      	ldr	r1, [r3, #0]
     all deltas.*/
  while (vtp->delta <= (systime_t)(now - ch.vtlist.lasttime)) {
    vtfunc_t fn;

    /* The "last time" becomes this timer's expiration time.*/
    ch.vtlist.lasttime += vtp->delta;
 800074e:	4472      	add	r2, lr
    ch.vtlist.next = vtp->next;
    fn = vtp->func;
    vtp->func = NULL;

    /* if the list becomes empty then the timer is stopped.*/
    if (ch.vtlist.next == (virtual_timer_t *)&ch.vtlist) {
 8000750:	4541      	cmp	r1, r8
     all deltas.*/
  while (vtp->delta <= (systime_t)(now - ch.vtlist.lasttime)) {
    vtfunc_t fn;

    /* The "last time" becomes this timer's expiration time.*/
    ch.vtlist.lasttime += vtp->delta;
 8000752:	84f2      	strh	r2, [r6, #38]	; 0x26

    vtp->next->prev = (virtual_timer_t *)&ch.vtlist;
    ch.vtlist.next = vtp->next;
    fn = vtp->func;
 8000754:	68da      	ldr	r2, [r3, #12]
    vtfunc_t fn;

    /* The "last time" becomes this timer's expiration time.*/
    ch.vtlist.lasttime += vtp->delta;

    vtp->next->prev = (virtual_timer_t *)&ch.vtlist;
 8000756:	f8c1 8004 	str.w	r8, [r1, #4]
    ch.vtlist.next = vtp->next;
 800075a:	61f1      	str	r1, [r6, #28]
    fn = vtp->func;
    vtp->func = NULL;
 800075c:	60df      	str	r7, [r3, #12]
 *
 * @notapi
 */
static inline void st_lld_stop_alarm(void) {

  STM32_ST_TIM->DIER = 0;
 800075e:	bf08      	it	eq
 8000760:	60e7      	streq	r7, [r4, #12]
 8000762:	f387 8811 	msr	BASEPRI, r7
       and in order to give a preemption chance to higher priority
       interrupts.*/
    chSysUnlockFromISR();

    /* The callback is invoked outside the kernel critical zone.*/
    fn(vtp->par);
 8000766:	6918      	ldr	r0, [r3, #16]
 8000768:	4790      	blx	r2
 800076a:	f385 8811 	msr	BASEPRI, r5
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 800076e:	6a62      	ldr	r2, [r4, #36]	; 0x24

  /* All timers within the time window are triggered and removed,
     note that the loop is stopped by the timers header having
     "ch.vtlist.vt_delta == (systime_t)-1" which is greater than
     all deltas.*/
  while (vtp->delta <= (systime_t)(now - ch.vtlist.lasttime)) {
 8000770:	f8b6 e026 	ldrh.w	lr, [r6, #38]	; 0x26
       of the list.*/
    chSysLockFromISR();

    /* Next element in the list, the current time could have advanced so
       recalculating the time window.*/
    vtp = ch.vtlist.next;
 8000774:	69f3      	ldr	r3, [r6, #28]
 8000776:	b290      	uxth	r0, r2

  /* All timers within the time window are triggered and removed,
     note that the loop is stopped by the timers header having
     "ch.vtlist.vt_delta == (systime_t)-1" which is greater than
     all deltas.*/
  while (vtp->delta <= (systime_t)(now - ch.vtlist.lasttime)) {
 8000778:	ebce 0100 	rsb	r1, lr, r0
 800077c:	891a      	ldrh	r2, [r3, #8]
 800077e:	b289      	uxth	r1, r1
 8000780:	428a      	cmp	r2, r1
 8000782:	d9e3      	bls.n	800074c <VectorB0+0x3c>
    vtp = ch.vtlist.next;
    now = chVTGetSystemTimeX();
  }

  /* if the list is empty, nothing else to do.*/
  if (ch.vtlist.next == (virtual_timer_t *)&ch.vtlist) {
 8000784:	4543      	cmp	r3, r8
 8000786:	d00a      	beq.n	800079e <VectorB0+0x8e>
    return;
  }

  /* Recalculating the next alarm time.*/
  delta = ch.vtlist.lasttime + vtp->delta - now;
 8000788:	4472      	add	r2, lr
 800078a:	1a12      	subs	r2, r2, r0
 800078c:	b292      	uxth	r2, r2
  if (delta < (systime_t)CH_CFG_ST_TIMEDELTA) {
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
 800078e:	2a01      	cmp	r2, #1
 8000790:	bf98      	it	ls
 8000792:	2202      	movls	r2, #2
 *
 * @notapi
 */
static inline void st_lld_set_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8000794:	4402      	add	r2, r0
 8000796:	b292      	uxth	r2, r2
 8000798:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 800079c:	635a      	str	r2, [r3, #52]	; 0x34
 800079e:	2300      	movs	r3, #0
 80007a0:	f383 8811 	msr	BASEPRI, r3
    osalOsTimerHandlerI();
    osalSysUnlockFromISR();
  }

  OSAL_IRQ_EPILOGUE();
}
 80007a4:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    osalSysLockFromISR();
    osalOsTimerHandlerI();
    osalSysUnlockFromISR();
  }

  OSAL_IRQ_EPILOGUE();
 80007a8:	f001 b8ca 	b.w	8001940 <_port_irq_epilogue>
 80007ac:	20000918 	.word	0x20000918

080007b0 <Vector84>:
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH7_HANDLER) {

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM7);
 80007b0:	4b09      	ldr	r3, [pc, #36]	; (80007d8 <Vector84+0x28>)
 80007b2:	6819      	ldr	r1, [r3, #0]
 80007b4:	f3c1 6103 	ubfx	r1, r1, #24, #4
 80007b8:	b159      	cbz	r1, 80007d2 <Vector84+0x22>
 80007ba:	4808      	ldr	r0, [pc, #32]	; (80007dc <Vector84+0x2c>)
/**
 * @brief   DMA1 stream 7 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH7_HANDLER) {
 80007bc:	b510      	push	{r4, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM7);
 80007be:	6b04      	ldr	r4, [r0, #48]	; 0x30
 80007c0:	060a      	lsls	r2, r1, #24
 80007c2:	605a      	str	r2, [r3, #4]
 80007c4:	b10c      	cbz	r4, 80007ca <Vector84+0x1a>
 80007c6:	6b40      	ldr	r0, [r0, #52]	; 0x34
 80007c8:	47a0      	blx	r4

  OSAL_IRQ_EPILOGUE();
}
 80007ca:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM7);

  OSAL_IRQ_EPILOGUE();
 80007ce:	f001 b8b7 	b.w	8001940 <_port_irq_epilogue>
 80007d2:	f001 b8b5 	b.w	8001940 <_port_irq_epilogue>
 80007d6:	bf00      	nop
 80007d8:	40020000 	.word	0x40020000
 80007dc:	200009c0 	.word	0x200009c0

080007e0 <Vector80>:
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH6_HANDLER) {

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM6);
 80007e0:	4b09      	ldr	r3, [pc, #36]	; (8000808 <Vector80+0x28>)
 80007e2:	6819      	ldr	r1, [r3, #0]
 80007e4:	f3c1 5103 	ubfx	r1, r1, #20, #4
 80007e8:	b159      	cbz	r1, 8000802 <Vector80+0x22>
 80007ea:	4808      	ldr	r0, [pc, #32]	; (800080c <Vector80+0x2c>)
/**
 * @brief   DMA1 stream 6 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH6_HANDLER) {
 80007ec:	b510      	push	{r4, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM6);
 80007ee:	6a84      	ldr	r4, [r0, #40]	; 0x28
 80007f0:	050a      	lsls	r2, r1, #20
 80007f2:	605a      	str	r2, [r3, #4]
 80007f4:	b10c      	cbz	r4, 80007fa <Vector80+0x1a>
 80007f6:	6ac0      	ldr	r0, [r0, #44]	; 0x2c
 80007f8:	47a0      	blx	r4

  OSAL_IRQ_EPILOGUE();
}
 80007fa:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM6);

  OSAL_IRQ_EPILOGUE();
 80007fe:	f001 b89f 	b.w	8001940 <_port_irq_epilogue>
 8000802:	f001 b89d 	b.w	8001940 <_port_irq_epilogue>
 8000806:	bf00      	nop
 8000808:	40020000 	.word	0x40020000
 800080c:	200009c0 	.word	0x200009c0

08000810 <Vector7C>:
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH5_HANDLER) {

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM5);
 8000810:	4b09      	ldr	r3, [pc, #36]	; (8000838 <Vector7C+0x28>)
 8000812:	6819      	ldr	r1, [r3, #0]
 8000814:	f3c1 4103 	ubfx	r1, r1, #16, #4
 8000818:	b159      	cbz	r1, 8000832 <Vector7C+0x22>
 800081a:	4808      	ldr	r0, [pc, #32]	; (800083c <Vector7C+0x2c>)
/**
 * @brief   DMA1 stream 5 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH5_HANDLER) {
 800081c:	b510      	push	{r4, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM5);
 800081e:	6a04      	ldr	r4, [r0, #32]
 8000820:	040a      	lsls	r2, r1, #16
 8000822:	605a      	str	r2, [r3, #4]
 8000824:	b10c      	cbz	r4, 800082a <Vector7C+0x1a>
 8000826:	6a40      	ldr	r0, [r0, #36]	; 0x24
 8000828:	47a0      	blx	r4

  OSAL_IRQ_EPILOGUE();
}
 800082a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM5);

  OSAL_IRQ_EPILOGUE();
 800082e:	f001 b887 	b.w	8001940 <_port_irq_epilogue>
 8000832:	f001 b885 	b.w	8001940 <_port_irq_epilogue>
 8000836:	bf00      	nop
 8000838:	40020000 	.word	0x40020000
 800083c:	200009c0 	.word	0x200009c0

08000840 <Vector78>:
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH4_HANDLER) {

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM4);
 8000840:	4b09      	ldr	r3, [pc, #36]	; (8000868 <Vector78+0x28>)
 8000842:	6819      	ldr	r1, [r3, #0]
 8000844:	f3c1 3103 	ubfx	r1, r1, #12, #4
 8000848:	b159      	cbz	r1, 8000862 <Vector78+0x22>
 800084a:	4808      	ldr	r0, [pc, #32]	; (800086c <Vector78+0x2c>)
/**
 * @brief   DMA1 stream 4 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH4_HANDLER) {
 800084c:	b510      	push	{r4, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM4);
 800084e:	6984      	ldr	r4, [r0, #24]
 8000850:	030a      	lsls	r2, r1, #12
 8000852:	605a      	str	r2, [r3, #4]
 8000854:	b10c      	cbz	r4, 800085a <Vector78+0x1a>
 8000856:	69c0      	ldr	r0, [r0, #28]
 8000858:	47a0      	blx	r4

  OSAL_IRQ_EPILOGUE();
}
 800085a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM4);

  OSAL_IRQ_EPILOGUE();
 800085e:	f001 b86f 	b.w	8001940 <_port_irq_epilogue>
 8000862:	f001 b86d 	b.w	8001940 <_port_irq_epilogue>
 8000866:	bf00      	nop
 8000868:	40020000 	.word	0x40020000
 800086c:	200009c0 	.word	0x200009c0

08000870 <Vector74>:
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH3_HANDLER) {

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM3);
 8000870:	4b09      	ldr	r3, [pc, #36]	; (8000898 <Vector74+0x28>)
 8000872:	6819      	ldr	r1, [r3, #0]
 8000874:	f3c1 2103 	ubfx	r1, r1, #8, #4
 8000878:	b159      	cbz	r1, 8000892 <Vector74+0x22>
 800087a:	4808      	ldr	r0, [pc, #32]	; (800089c <Vector74+0x2c>)
/**
 * @brief   DMA1 stream 3 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH3_HANDLER) {
 800087c:	b510      	push	{r4, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM3);
 800087e:	6904      	ldr	r4, [r0, #16]
 8000880:	020a      	lsls	r2, r1, #8
 8000882:	605a      	str	r2, [r3, #4]
 8000884:	b10c      	cbz	r4, 800088a <Vector74+0x1a>
 8000886:	6940      	ldr	r0, [r0, #20]
 8000888:	47a0      	blx	r4

  OSAL_IRQ_EPILOGUE();
}
 800088a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM3);

  OSAL_IRQ_EPILOGUE();
 800088e:	f001 b857 	b.w	8001940 <_port_irq_epilogue>
 8000892:	f001 b855 	b.w	8001940 <_port_irq_epilogue>
 8000896:	bf00      	nop
 8000898:	40020000 	.word	0x40020000
 800089c:	200009c0 	.word	0x200009c0

080008a0 <Vector70>:
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH2_HANDLER) {

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM2);
 80008a0:	4b09      	ldr	r3, [pc, #36]	; (80008c8 <Vector70+0x28>)
 80008a2:	6819      	ldr	r1, [r3, #0]
 80008a4:	f3c1 1103 	ubfx	r1, r1, #4, #4
 80008a8:	b159      	cbz	r1, 80008c2 <Vector70+0x22>
 80008aa:	4808      	ldr	r0, [pc, #32]	; (80008cc <Vector70+0x2c>)
/**
 * @brief   DMA1 stream 2 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH2_HANDLER) {
 80008ac:	b510      	push	{r4, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM2);
 80008ae:	6884      	ldr	r4, [r0, #8]
 80008b0:	010a      	lsls	r2, r1, #4
 80008b2:	605a      	str	r2, [r3, #4]
 80008b4:	b10c      	cbz	r4, 80008ba <Vector70+0x1a>
 80008b6:	68c0      	ldr	r0, [r0, #12]
 80008b8:	47a0      	blx	r4

  OSAL_IRQ_EPILOGUE();
}
 80008ba:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM2);

  OSAL_IRQ_EPILOGUE();
 80008be:	f001 b83f 	b.w	8001940 <_port_irq_epilogue>
 80008c2:	f001 b83d 	b.w	8001940 <_port_irq_epilogue>
 80008c6:	bf00      	nop
 80008c8:	40020000 	.word	0x40020000
 80008cc:	200009c0 	.word	0x200009c0

080008d0 <Vector6C>:
/**
 * @brief   DMA1 stream 1 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH1_HANDLER) {
 80008d0:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM1);
 80008d2:	4b07      	ldr	r3, [pc, #28]	; (80008f0 <Vector6C+0x20>)
 80008d4:	6819      	ldr	r1, [r3, #0]
 80008d6:	f011 010f 	ands.w	r1, r1, #15
 80008da:	d005      	beq.n	80008e8 <Vector6C+0x18>
 80008dc:	4a05      	ldr	r2, [pc, #20]	; (80008f4 <Vector6C+0x24>)
 80008de:	6059      	str	r1, [r3, #4]
 80008e0:	6813      	ldr	r3, [r2, #0]
 80008e2:	b10b      	cbz	r3, 80008e8 <Vector6C+0x18>
 80008e4:	6850      	ldr	r0, [r2, #4]
 80008e6:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
}
 80008e8:	e8bd 4008 	ldmia.w	sp!, {r3, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM1);

  OSAL_IRQ_EPILOGUE();
 80008ec:	f001 b828 	b.w	8001940 <_port_irq_epilogue>
 80008f0:	40020000 	.word	0x40020000
 80008f4:	200009c0 	.word	0x200009c0
	...

08000900 <i2c_lld_serve_event_interrupt>:
 *
 * @param[in] i2cp      pointer to the @p I2CDriver object
 *
 * @notapi
 */
static void i2c_lld_serve_event_interrupt(I2CDriver *i2cp) {
 8000900:	b538      	push	{r3, r4, r5, lr}
  I2C_TypeDef *dp = i2cp->i2c;
 8000902:	6b44      	ldr	r4, [r0, #52]	; 0x34
  uint32_t event = dp->SR1;

  /* Interrupts are disabled just before dmaStreamEnable() because there
     is no need of interrupts until next transaction begin. All the work is
     done by the DMA.*/
  switch (I2C_EV_MASK & (event | (regSR2 << 16))) {
 8000904:	4a3c      	ldr	r2, [pc, #240]	; (80009f8 <i2c_lld_serve_event_interrupt+0xf8>)
 *
 * @notapi
 */
static void i2c_lld_serve_event_interrupt(I2CDriver *i2cp) {
  I2C_TypeDef *dp = i2cp->i2c;
  uint32_t regSR2 = dp->SR2;
 8000906:	69a3      	ldr	r3, [r4, #24]
  uint32_t event = dp->SR1;
 8000908:	6965      	ldr	r5, [r4, #20]

  /* Interrupts are disabled just before dmaStreamEnable() because there
     is no need of interrupts until next transaction begin. All the work is
     done by the DMA.*/
  switch (I2C_EV_MASK & (event | (regSR2 << 16))) {
 800090a:	ea45 4303 	orr.w	r3, r5, r3, lsl #16
 800090e:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 8000912:	4293      	cmp	r3, r2
 8000914:	d04b      	beq.n	80009ae <i2c_lld_serve_event_interrupt+0xae>
 8000916:	d81b      	bhi.n	8000950 <i2c_lld_serve_event_interrupt+0x50>
 8000918:	3a07      	subs	r2, #7
 800091a:	4293      	cmp	r3, r2
 800091c:	d03b      	beq.n	8000996 <i2c_lld_serve_event_interrupt+0x96>
 800091e:	3201      	adds	r2, #1
 8000920:	4293      	cmp	r3, r2
 8000922:	d110      	bne.n	8000946 <i2c_lld_serve_event_interrupt+0x46>
  case I2C_EV9_MASTER_ADD10:
    /* Set second addr byte (10-bit addressing)*/
    dp->DR = (0xFF & (i2cp->addr >> 1));
    break;
  case I2C_EV6_MASTER_REC_MODE_SELECTED:
    dp->CR2 &= ~I2C_CR2_ITEVTEN;
 8000924:	6862      	ldr	r2, [r4, #4]
    dmaStreamEnable(i2cp->dmarx);
 8000926:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
  case I2C_EV9_MASTER_ADD10:
    /* Set second addr byte (10-bit addressing)*/
    dp->DR = (0xFF & (i2cp->addr >> 1));
    break;
  case I2C_EV6_MASTER_REC_MODE_SELECTED:
    dp->CR2 &= ~I2C_CR2_ITEVTEN;
 8000928:	f422 7200 	bic.w	r2, r2, #512	; 0x200
    dmaStreamEnable(i2cp->dmarx);
 800092c:	685b      	ldr	r3, [r3, #4]
  case I2C_EV9_MASTER_ADD10:
    /* Set second addr byte (10-bit addressing)*/
    dp->DR = (0xFF & (i2cp->addr >> 1));
    break;
  case I2C_EV6_MASTER_REC_MODE_SELECTED:
    dp->CR2 &= ~I2C_CR2_ITEVTEN;
 800092e:	6062      	str	r2, [r4, #4]
    dmaStreamEnable(i2cp->dmarx);
 8000930:	681a      	ldr	r2, [r3, #0]
 8000932:	f042 0201 	orr.w	r2, r2, #1
 8000936:	601a      	str	r2, [r3, #0]
    dp->CR2 |= I2C_CR2_LAST;                 /* Needed in receiver mode. */
 8000938:	6862      	ldr	r2, [r4, #4]
 800093a:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 800093e:	6062      	str	r2, [r4, #4]
    if (dmaStreamGetTransactionSize(i2cp->dmarx) < 2)
 8000940:	685b      	ldr	r3, [r3, #4]
 8000942:	2b01      	cmp	r3, #1
 8000944:	d952      	bls.n	80009ec <i2c_lld_serve_event_interrupt+0xec>
    break;
  default:
    break;
  }
  /* Clear ADDR flag. */
  if (event & (I2C_SR1_ADDR | I2C_SR1_ADD10))
 8000946:	f015 0f0a 	tst.w	r5, #10
    (void)dp->SR2;
 800094a:	bf18      	it	ne
 800094c:	69a3      	ldrne	r3, [r4, #24]
 800094e:	bd38      	pop	{r3, r4, r5, pc}
  uint32_t event = dp->SR1;

  /* Interrupts are disabled just before dmaStreamEnable() because there
     is no need of interrupts until next transaction begin. All the work is
     done by the DMA.*/
  switch (I2C_EV_MASK & (event | (regSR2 << 16))) {
 8000950:	4a2a      	ldr	r2, [pc, #168]	; (80009fc <i2c_lld_serve_event_interrupt+0xfc>)
 8000952:	4293      	cmp	r3, r2
 8000954:	d010      	beq.n	8000978 <i2c_lld_serve_event_interrupt+0x78>
 8000956:	3202      	adds	r2, #2
 8000958:	4293      	cmp	r3, r2
 800095a:	d1f4      	bne.n	8000946 <i2c_lld_serve_event_interrupt+0x46>
    dp->CR2 &= ~I2C_CR2_ITEVTEN;
    dmaStreamEnable(i2cp->dmatx);
    break;
  case I2C_EV8_2_MASTER_BYTE_TRANSMITTED:
    /* Catches BTF event after the end of transmission.*/
    if (dmaStreamGetTransactionSize(i2cp->dmarx) > 0) {
 800095c:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 800095e:	685b      	ldr	r3, [r3, #4]
 8000960:	685b      	ldr	r3, [r3, #4]
 8000962:	2b00      	cmp	r3, #0
 8000964:	d02c      	beq.n	80009c0 <i2c_lld_serve_event_interrupt+0xc0>
      /* Starts "read after write" operation, LSB = 1 -> receive.*/
      i2cp->addr |= 0x01;
 8000966:	8c02      	ldrh	r2, [r0, #32]
      dp->CR1 |= I2C_CR1_START | I2C_CR1_ACK;
 8000968:	6823      	ldr	r3, [r4, #0]
    break;
  case I2C_EV8_2_MASTER_BYTE_TRANSMITTED:
    /* Catches BTF event after the end of transmission.*/
    if (dmaStreamGetTransactionSize(i2cp->dmarx) > 0) {
      /* Starts "read after write" operation, LSB = 1 -> receive.*/
      i2cp->addr |= 0x01;
 800096a:	f042 0201 	orr.w	r2, r2, #1
      dp->CR1 |= I2C_CR1_START | I2C_CR1_ACK;
 800096e:	f443 63a0 	orr.w	r3, r3, #1280	; 0x500
    break;
  case I2C_EV8_2_MASTER_BYTE_TRANSMITTED:
    /* Catches BTF event after the end of transmission.*/
    if (dmaStreamGetTransactionSize(i2cp->dmarx) > 0) {
      /* Starts "read after write" operation, LSB = 1 -> receive.*/
      i2cp->addr |= 0x01;
 8000972:	8402      	strh	r2, [r0, #32]
      dp->CR1 |= I2C_CR1_START | I2C_CR1_ACK;
 8000974:	6023      	str	r3, [r4, #0]
 8000976:	bd38      	pop	{r3, r4, r5, pc}
    dp->CR2 |= I2C_CR2_LAST;                 /* Needed in receiver mode. */
    if (dmaStreamGetTransactionSize(i2cp->dmarx) < 2)
      dp->CR1 &= ~I2C_CR1_ACK;
    break;
  case I2C_EV6_MASTER_TRA_MODE_SELECTED:
    dp->CR2 &= ~I2C_CR2_ITEVTEN;
 8000978:	6863      	ldr	r3, [r4, #4]
    dmaStreamEnable(i2cp->dmatx);
 800097a:	6b02      	ldr	r2, [r0, #48]	; 0x30
    dp->CR2 |= I2C_CR2_LAST;                 /* Needed in receiver mode. */
    if (dmaStreamGetTransactionSize(i2cp->dmarx) < 2)
      dp->CR1 &= ~I2C_CR1_ACK;
    break;
  case I2C_EV6_MASTER_TRA_MODE_SELECTED:
    dp->CR2 &= ~I2C_CR2_ITEVTEN;
 800097c:	f423 7300 	bic.w	r3, r3, #512	; 0x200
    dmaStreamEnable(i2cp->dmatx);
 8000980:	6852      	ldr	r2, [r2, #4]
    dp->CR2 |= I2C_CR2_LAST;                 /* Needed in receiver mode. */
    if (dmaStreamGetTransactionSize(i2cp->dmarx) < 2)
      dp->CR1 &= ~I2C_CR1_ACK;
    break;
  case I2C_EV6_MASTER_TRA_MODE_SELECTED:
    dp->CR2 &= ~I2C_CR2_ITEVTEN;
 8000982:	6063      	str	r3, [r4, #4]
    dmaStreamEnable(i2cp->dmatx);
 8000984:	6813      	ldr	r3, [r2, #0]
    break;
  default:
    break;
  }
  /* Clear ADDR flag. */
  if (event & (I2C_SR1_ADDR | I2C_SR1_ADD10))
 8000986:	f015 0f0a 	tst.w	r5, #10
    if (dmaStreamGetTransactionSize(i2cp->dmarx) < 2)
      dp->CR1 &= ~I2C_CR1_ACK;
    break;
  case I2C_EV6_MASTER_TRA_MODE_SELECTED:
    dp->CR2 &= ~I2C_CR2_ITEVTEN;
    dmaStreamEnable(i2cp->dmatx);
 800098a:	f043 0301 	orr.w	r3, r3, #1
 800098e:	6013      	str	r3, [r2, #0]
  default:
    break;
  }
  /* Clear ADDR flag. */
  if (event & (I2C_SR1_ADDR | I2C_SR1_ADD10))
    (void)dp->SR2;
 8000990:	bf18      	it	ne
 8000992:	69a3      	ldrne	r3, [r4, #24]
 8000994:	bd38      	pop	{r3, r4, r5, pc}
  /* Interrupts are disabled just before dmaStreamEnable() because there
     is no need of interrupts until next transaction begin. All the work is
     done by the DMA.*/
  switch (I2C_EV_MASK & (event | (regSR2 << 16))) {
  case I2C_EV5_MASTER_MODE_SELECT:
    if ((i2cp->addr >> 8) > 0) { 
 8000996:	8c03      	ldrh	r3, [r0, #32]
 8000998:	0a1a      	lsrs	r2, r3, #8
 800099a:	d00b      	beq.n	80009b4 <i2c_lld_serve_event_interrupt+0xb4>
      /* 10-bit address: 1 1 1 1 0 X X R/W */
      dp->DR = 0xF0 | (0x6 & (i2cp->addr >> 8)) | (0x1 & i2cp->addr);
 800099c:	f003 0301 	and.w	r3, r3, #1
 80009a0:	f043 03f0 	orr.w	r3, r3, #240	; 0xf0
 80009a4:	f002 0206 	and.w	r2, r2, #6
 80009a8:	4313      	orrs	r3, r2
 80009aa:	6123      	str	r3, [r4, #16]
 80009ac:	e7cb      	b.n	8000946 <i2c_lld_serve_event_interrupt+0x46>
      dp->DR = i2cp->addr;
    }
    break;
  case I2C_EV9_MASTER_ADD10:
    /* Set second addr byte (10-bit addressing)*/
    dp->DR = (0xFF & (i2cp->addr >> 1));
 80009ae:	8c03      	ldrh	r3, [r0, #32]
 80009b0:	f3c3 0347 	ubfx	r3, r3, #1, #8
 80009b4:	6123      	str	r3, [r4, #16]
    break;
  default:
    break;
  }
  /* Clear ADDR flag. */
  if (event & (I2C_SR1_ADDR | I2C_SR1_ADD10))
 80009b6:	f015 0f0a 	tst.w	r5, #10
    (void)dp->SR2;
 80009ba:	bf18      	it	ne
 80009bc:	69a3      	ldrne	r3, [r4, #24]
 80009be:	bd38      	pop	{r3, r4, r5, pc}
      /* Starts "read after write" operation, LSB = 1 -> receive.*/
      i2cp->addr |= 0x01;
      dp->CR1 |= I2C_CR1_START | I2C_CR1_ACK;
      return;
    }
    dp->CR2 &= ~I2C_CR2_ITEVTEN;
 80009c0:	6862      	ldr	r2, [r4, #4]
 80009c2:	2120      	movs	r1, #32
 80009c4:	f422 7200 	bic.w	r2, r2, #512	; 0x200
 80009c8:	6062      	str	r2, [r4, #4]
    dp->CR1 |= I2C_CR1_STOP;
 80009ca:	6822      	ldr	r2, [r4, #0]
 80009cc:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 80009d0:	6022      	str	r2, [r4, #0]
 80009d2:	f381 8811 	msr	BASEPRI, r1
 *
 * @iclass
 */
void chThdResumeI(thread_reference_t *trp, msg_t msg) {

  if (*trp != NULL) {
 80009d6:	69c2      	ldr	r2, [r0, #28]
 80009d8:	b122      	cbz	r2, 80009e4 <i2c_lld_serve_event_interrupt+0xe4>
    thread_t *tp = *trp;

    chDbgAssert(tp->state == CH_STATE_SUSPENDED, "not CH_STATE_SUSPENDED");

    *trp = NULL;
 80009da:	61c3      	str	r3, [r0, #28]
    tp->u.rdymsg = msg;
    (void) chSchReadyI(tp);
 80009dc:	4610      	mov	r0, r2
    thread_t *tp = *trp;

    chDbgAssert(tp->state == CH_STATE_SUSPENDED, "not CH_STATE_SUSPENDED");

    *trp = NULL;
    tp->u.rdymsg = msg;
 80009de:	6253      	str	r3, [r2, #36]	; 0x24
    (void) chSchReadyI(tp);
 80009e0:	f001 f8d6 	bl	8001b90 <chSchReadyI>
 80009e4:	2300      	movs	r3, #0
 80009e6:	f383 8811 	msr	BASEPRI, r3
 80009ea:	e7ac      	b.n	8000946 <i2c_lld_serve_event_interrupt+0x46>
  case I2C_EV6_MASTER_REC_MODE_SELECTED:
    dp->CR2 &= ~I2C_CR2_ITEVTEN;
    dmaStreamEnable(i2cp->dmarx);
    dp->CR2 |= I2C_CR2_LAST;                 /* Needed in receiver mode. */
    if (dmaStreamGetTransactionSize(i2cp->dmarx) < 2)
      dp->CR1 &= ~I2C_CR1_ACK;
 80009ec:	6823      	ldr	r3, [r4, #0]
 80009ee:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 80009f2:	6023      	str	r3, [r4, #0]
 80009f4:	e7a7      	b.n	8000946 <i2c_lld_serve_event_interrupt+0x46>
 80009f6:	bf00      	nop
 80009f8:	00030008 	.word	0x00030008
 80009fc:	00070082 	.word	0x00070082

08000a00 <VectorC4>:
/**
 * @brief   I2C2 event interrupt handler.
 *
 * @notapi
 */
OSAL_IRQ_HANDLER(STM32_I2C2_EVENT_HANDLER) {
 8000a00:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

  i2c_lld_serve_event_interrupt(&I2CD2);
 8000a02:	4803      	ldr	r0, [pc, #12]	; (8000a10 <VectorC4+0x10>)
 8000a04:	f7ff ff7c 	bl	8000900 <i2c_lld_serve_event_interrupt>

  OSAL_IRQ_EPILOGUE();
}
 8000a08:	e8bd 4008 	ldmia.w	sp!, {r3, lr}

  OSAL_IRQ_PROLOGUE();

  i2c_lld_serve_event_interrupt(&I2CD2);

  OSAL_IRQ_EPILOGUE();
 8000a0c:	f000 bf98 	b.w	8001940 <_port_irq_epilogue>
 8000a10:	20000988 	.word	0x20000988
	...

08000a20 <VectorBC>:
/**
 * @brief   I2C1 event interrupt handler.
 *
 * @notapi
 */
OSAL_IRQ_HANDLER(STM32_I2C1_EVENT_HANDLER) {
 8000a20:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

  i2c_lld_serve_event_interrupt(&I2CD1);
 8000a22:	4803      	ldr	r0, [pc, #12]	; (8000a30 <VectorBC+0x10>)
 8000a24:	f7ff ff6c 	bl	8000900 <i2c_lld_serve_event_interrupt>

  OSAL_IRQ_EPILOGUE();
}
 8000a28:	e8bd 4008 	ldmia.w	sp!, {r3, lr}

  OSAL_IRQ_PROLOGUE();

  i2c_lld_serve_event_interrupt(&I2CD1);

  OSAL_IRQ_EPILOGUE();
 8000a2c:	f000 bf88 	b.w	8001940 <_port_irq_epilogue>
 8000a30:	20000a04 	.word	0x20000a04
	...

08000a40 <i2c_lld_serve_error_interrupt>:
 * @param[in] i2cp      pointer to the @p I2CDriver object
 * @param[in]  sr       content of the SR1 register to be decoded
 *
 * @notapi
 */
static void i2c_lld_serve_error_interrupt(I2CDriver *i2cp, uint16_t sr) {
 8000a40:	b5f8      	push	{r3, r4, r5, r6, r7, lr}

  /* Clears interrupt flags just to be safe.*/
  dmaStreamDisable(i2cp->dmatx);
 8000a42:	6b04      	ldr	r4, [r0, #48]	; 0x30
  dmaStreamDisable(i2cp->dmarx);
 8000a44:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 * @notapi
 */
static void i2c_lld_serve_error_interrupt(I2CDriver *i2cp, uint16_t sr) {

  /* Clears interrupt flags just to be safe.*/
  dmaStreamDisable(i2cp->dmatx);
 8000a46:	6866      	ldr	r6, [r4, #4]
 8000a48:	6827      	ldr	r7, [r4, #0]
 8000a4a:	6835      	ldr	r5, [r6, #0]
 8000a4c:	220f      	movs	r2, #15
 8000a4e:	f025 050f 	bic.w	r5, r5, #15
 8000a52:	6035      	str	r5, [r6, #0]
 8000a54:	7c24      	ldrb	r4, [r4, #16]
  dmaStreamDisable(i2cp->dmarx);
 8000a56:	685d      	ldr	r5, [r3, #4]
 * @notapi
 */
static void i2c_lld_serve_error_interrupt(I2CDriver *i2cp, uint16_t sr) {

  /* Clears interrupt flags just to be safe.*/
  dmaStreamDisable(i2cp->dmatx);
 8000a58:	fa02 f404 	lsl.w	r4, r2, r4
 8000a5c:	607c      	str	r4, [r7, #4]
  dmaStreamDisable(i2cp->dmarx);
 8000a5e:	682c      	ldr	r4, [r5, #0]
 8000a60:	681e      	ldr	r6, [r3, #0]
 8000a62:	f024 040f 	bic.w	r4, r4, #15
 8000a66:	602c      	str	r4, [r5, #0]
 8000a68:	7c1c      	ldrb	r4, [r3, #16]

  i2cp->errors = I2C_NO_ERROR;

  if (sr & I2C_SR1_BERR)                            /* Bus error.           */
 8000a6a:	f401 7380 	and.w	r3, r1, #256	; 0x100
 */
static void i2c_lld_serve_error_interrupt(I2CDriver *i2cp, uint16_t sr) {

  /* Clears interrupt flags just to be safe.*/
  dmaStreamDisable(i2cp->dmatx);
  dmaStreamDisable(i2cp->dmarx);
 8000a6e:	40a2      	lsls	r2, r4

  i2cp->errors = I2C_NO_ERROR;

  if (sr & I2C_SR1_BERR)                            /* Bus error.           */
 8000a70:	b29b      	uxth	r3, r3
 */
static void i2c_lld_serve_error_interrupt(I2CDriver *i2cp, uint16_t sr) {

  /* Clears interrupt flags just to be safe.*/
  dmaStreamDisable(i2cp->dmatx);
  dmaStreamDisable(i2cp->dmarx);
 8000a72:	6072      	str	r2, [r6, #4]

  i2cp->errors = I2C_NO_ERROR;

  if (sr & I2C_SR1_BERR)                            /* Bus error.           */
 8000a74:	2b00      	cmp	r3, #0
 8000a76:	d135      	bne.n	8000ae4 <i2c_lld_serve_error_interrupt+0xa4>

  /* Clears interrupt flags just to be safe.*/
  dmaStreamDisable(i2cp->dmatx);
  dmaStreamDisable(i2cp->dmarx);

  i2cp->errors = I2C_NO_ERROR;
 8000a78:	6083      	str	r3, [r0, #8]

  if (sr & I2C_SR1_BERR)                            /* Bus error.           */
    i2cp->errors |= I2C_BUS_ERROR;

  if (sr & I2C_SR1_ARLO)                            /* Arbitration lost.    */
 8000a7a:	058a      	lsls	r2, r1, #22
    i2cp->errors |= I2C_ARBITRATION_LOST;
 8000a7c:	bf44      	itt	mi
 8000a7e:	f043 0302 	orrmi.w	r3, r3, #2
 8000a82:	6083      	strmi	r3, [r0, #8]

  if (sr & I2C_SR1_AF) {                            /* Acknowledge fail.    */
 8000a84:	054f      	lsls	r7, r1, #21
 8000a86:	d50b      	bpl.n	8000aa0 <i2c_lld_serve_error_interrupt+0x60>
    i2cp->i2c->CR2 &= ~I2C_CR2_ITEVTEN;
 8000a88:	6b42      	ldr	r2, [r0, #52]	; 0x34
    i2cp->i2c->CR1 |= I2C_CR1_STOP;                 /* Setting stop bit.    */
    i2cp->errors |= I2C_ACK_FAILURE;
 8000a8a:	f043 0304 	orr.w	r3, r3, #4

  if (sr & I2C_SR1_ARLO)                            /* Arbitration lost.    */
    i2cp->errors |= I2C_ARBITRATION_LOST;

  if (sr & I2C_SR1_AF) {                            /* Acknowledge fail.    */
    i2cp->i2c->CR2 &= ~I2C_CR2_ITEVTEN;
 8000a8e:	6854      	ldr	r4, [r2, #4]
 8000a90:	f424 7400 	bic.w	r4, r4, #512	; 0x200
 8000a94:	6054      	str	r4, [r2, #4]
    i2cp->i2c->CR1 |= I2C_CR1_STOP;                 /* Setting stop bit.    */
 8000a96:	6814      	ldr	r4, [r2, #0]
 8000a98:	f444 7400 	orr.w	r4, r4, #512	; 0x200
 8000a9c:	6014      	str	r4, [r2, #0]
    i2cp->errors |= I2C_ACK_FAILURE;
 8000a9e:	6083      	str	r3, [r0, #8]
  }

  if (sr & I2C_SR1_OVR)                             /* Overrun.             */
 8000aa0:	050e      	lsls	r6, r1, #20
    i2cp->errors |= I2C_OVERRUN;
 8000aa2:	bf44      	itt	mi
 8000aa4:	f043 0308 	orrmi.w	r3, r3, #8
 8000aa8:	6083      	strmi	r3, [r0, #8]

  if (sr & I2C_SR1_TIMEOUT)                         /* SMBus Timeout.       */
 8000aaa:	044d      	lsls	r5, r1, #17
    i2cp->errors |= I2C_TIMEOUT;
 8000aac:	bf44      	itt	mi
 8000aae:	f043 0320 	orrmi.w	r3, r3, #32
 8000ab2:	6083      	strmi	r3, [r0, #8]

  if (sr & I2C_SR1_PECERR)                          /* PEC error.           */
 8000ab4:	04cc      	lsls	r4, r1, #19
 8000ab6:	d519      	bpl.n	8000aec <i2c_lld_serve_error_interrupt+0xac>
    i2cp->errors |= I2C_PEC_ERROR;
 8000ab8:	f043 0310 	orr.w	r3, r3, #16

  if (sr & I2C_SR1_SMBALERT)                        /* SMBus alert.         */
 8000abc:	0409      	lsls	r1, r1, #16

  if (sr & I2C_SR1_TIMEOUT)                         /* SMBus Timeout.       */
    i2cp->errors |= I2C_TIMEOUT;

  if (sr & I2C_SR1_PECERR)                          /* PEC error.           */
    i2cp->errors |= I2C_PEC_ERROR;
 8000abe:	6083      	str	r3, [r0, #8]

  if (sr & I2C_SR1_SMBALERT)                        /* SMBus alert.         */
 8000ac0:	d419      	bmi.n	8000af6 <i2c_lld_serve_error_interrupt+0xb6>
 8000ac2:	2320      	movs	r3, #32
 8000ac4:	f383 8811 	msr	BASEPRI, r3
 *
 * @iclass
 */
void chThdResumeI(thread_reference_t *trp, msg_t msg) {

  if (*trp != NULL) {
 8000ac8:	69c3      	ldr	r3, [r0, #28]
 8000aca:	b13b      	cbz	r3, 8000adc <i2c_lld_serve_error_interrupt+0x9c>
    thread_t *tp = *trp;

    chDbgAssert(tp->state == CH_STATE_SUSPENDED, "not CH_STATE_SUSPENDED");

    *trp = NULL;
 8000acc:	2100      	movs	r1, #0
    tp->u.rdymsg = msg;
 8000ace:	f06f 0201 	mvn.w	r2, #1
  if (*trp != NULL) {
    thread_t *tp = *trp;

    chDbgAssert(tp->state == CH_STATE_SUSPENDED, "not CH_STATE_SUSPENDED");

    *trp = NULL;
 8000ad2:	61c1      	str	r1, [r0, #28]
    tp->u.rdymsg = msg;
    (void) chSchReadyI(tp);
 8000ad4:	4618      	mov	r0, r3
    thread_t *tp = *trp;

    chDbgAssert(tp->state == CH_STATE_SUSPENDED, "not CH_STATE_SUSPENDED");

    *trp = NULL;
    tp->u.rdymsg = msg;
 8000ad6:	625a      	str	r2, [r3, #36]	; 0x24
    (void) chSchReadyI(tp);
 8000ad8:	f001 f85a 	bl	8001b90 <chSchReadyI>
 8000adc:	2300      	movs	r3, #0
 8000ade:	f383 8811 	msr	BASEPRI, r3
 8000ae2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  dmaStreamDisable(i2cp->dmarx);

  i2cp->errors = I2C_NO_ERROR;

  if (sr & I2C_SR1_BERR)                            /* Bus error.           */
    i2cp->errors |= I2C_BUS_ERROR;
 8000ae4:	2201      	movs	r2, #1
 8000ae6:	4613      	mov	r3, r2
 8000ae8:	6082      	str	r2, [r0, #8]
 8000aea:	e7c6      	b.n	8000a7a <i2c_lld_serve_error_interrupt+0x3a>
    i2cp->errors |= I2C_TIMEOUT;

  if (sr & I2C_SR1_PECERR)                          /* PEC error.           */
    i2cp->errors |= I2C_PEC_ERROR;

  if (sr & I2C_SR1_SMBALERT)                        /* SMBus alert.         */
 8000aec:	040a      	lsls	r2, r1, #16
 8000aee:	d402      	bmi.n	8000af6 <i2c_lld_serve_error_interrupt+0xb6>
    i2cp->errors |= I2C_SMB_ALERT;

  /* If some error has been identified then sends wakes the waiting thread.*/
  if (i2cp->errors != I2C_NO_ERROR)
 8000af0:	2b00      	cmp	r3, #0
 8000af2:	d1e6      	bne.n	8000ac2 <i2c_lld_serve_error_interrupt+0x82>
 8000af4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

  if (sr & I2C_SR1_PECERR)                          /* PEC error.           */
    i2cp->errors |= I2C_PEC_ERROR;

  if (sr & I2C_SR1_SMBALERT)                        /* SMBus alert.         */
    i2cp->errors |= I2C_SMB_ALERT;
 8000af6:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8000afa:	6083      	str	r3, [r0, #8]
 8000afc:	e7e1      	b.n	8000ac2 <i2c_lld_serve_error_interrupt+0x82>
 8000afe:	bf00      	nop

08000b00 <VectorC8>:
 * @brief   I2C2 error interrupt handler.
 *
 * @notapi
 */
OSAL_IRQ_HANDLER(STM32_I2C2_ERROR_HANDLER) {
  uint16_t sr = I2CD2.i2c->SR1;
 8000b00:	4807      	ldr	r0, [pc, #28]	; (8000b20 <VectorC8+0x20>)
/**
 * @brief   I2C2 error interrupt handler.
 *
 * @notapi
 */
OSAL_IRQ_HANDLER(STM32_I2C2_ERROR_HANDLER) {
 8000b02:	b508      	push	{r3, lr}
  uint16_t sr = I2CD2.i2c->SR1;
 8000b04:	6b42      	ldr	r2, [r0, #52]	; 0x34
 8000b06:	6951      	ldr	r1, [r2, #20]

  OSAL_IRQ_PROLOGUE();

  I2CD2.i2c->SR1 = ~(sr & I2C_ERROR_MASK);
 8000b08:	b289      	uxth	r1, r1
 8000b0a:	f401 435f 	and.w	r3, r1, #57088	; 0xdf00
 8000b0e:	43db      	mvns	r3, r3
 8000b10:	6153      	str	r3, [r2, #20]
  i2c_lld_serve_error_interrupt(&I2CD2, sr);
 8000b12:	f7ff ff95 	bl	8000a40 <i2c_lld_serve_error_interrupt>

  OSAL_IRQ_EPILOGUE();
}
 8000b16:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_PROLOGUE();

  I2CD2.i2c->SR1 = ~(sr & I2C_ERROR_MASK);
  i2c_lld_serve_error_interrupt(&I2CD2, sr);

  OSAL_IRQ_EPILOGUE();
 8000b1a:	f000 bf11 	b.w	8001940 <_port_irq_epilogue>
 8000b1e:	bf00      	nop
 8000b20:	20000988 	.word	0x20000988
	...

08000b30 <VectorC0>:

/**
 * @brief   I2C1 error interrupt handler.
 */
OSAL_IRQ_HANDLER(STM32_I2C1_ERROR_HANDLER) {
  uint16_t sr = I2CD1.i2c->SR1;
 8000b30:	4807      	ldr	r0, [pc, #28]	; (8000b50 <VectorC0+0x20>)
}

/**
 * @brief   I2C1 error interrupt handler.
 */
OSAL_IRQ_HANDLER(STM32_I2C1_ERROR_HANDLER) {
 8000b32:	b508      	push	{r3, lr}
  uint16_t sr = I2CD1.i2c->SR1;
 8000b34:	6b42      	ldr	r2, [r0, #52]	; 0x34
 8000b36:	6951      	ldr	r1, [r2, #20]

  OSAL_IRQ_PROLOGUE();

  I2CD1.i2c->SR1 = ~(sr & I2C_ERROR_MASK);
 8000b38:	b289      	uxth	r1, r1
 8000b3a:	f401 435f 	and.w	r3, r1, #57088	; 0xdf00
 8000b3e:	43db      	mvns	r3, r3
 8000b40:	6153      	str	r3, [r2, #20]
  i2c_lld_serve_error_interrupt(&I2CD1, sr);
 8000b42:	f7ff ff7d 	bl	8000a40 <i2c_lld_serve_error_interrupt>

  OSAL_IRQ_EPILOGUE();
}
 8000b46:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_PROLOGUE();

  I2CD1.i2c->SR1 = ~(sr & I2C_ERROR_MASK);
  i2c_lld_serve_error_interrupt(&I2CD1, sr);

  OSAL_IRQ_EPILOGUE();
 8000b4a:	f000 bef9 	b.w	8001940 <_port_irq_epilogue>
 8000b4e:	bf00      	nop
 8000b50:	20000a04 	.word	0x20000a04
	...

08000b60 <i2c_lld_serve_rx_end_irq.lto_priv.34>:
static void i2c_lld_serve_rx_end_irq(I2CDriver *i2cp, uint32_t flags) {
  I2C_TypeDef *dp = i2cp->i2c;

  /* DMA errors handling.*/
#if defined(STM32_I2C_DMA_ERROR_HOOK)
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
 8000b60:	f011 0108 	ands.w	r1, r1, #8
 * @param[in] i2cp      pointer to the @p I2CDriver object
 * @param[in] flags     pre-shifted content of the ISR register
 *
 * @notapi
 */
static void i2c_lld_serve_rx_end_irq(I2CDriver *i2cp, uint32_t flags) {
 8000b64:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  I2C_TypeDef *dp = i2cp->i2c;

  /* DMA errors handling.*/
#if defined(STM32_I2C_DMA_ERROR_HOOK)
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
 8000b66:	d125      	bne.n	8000bb4 <i2c_lld_serve_rx_end_irq.lto_priv.34+0x54>
  }
#else
  (void)flags;
#endif

  dmaStreamDisable(i2cp->dmarx);
 8000b68:	6ac4      	ldr	r4, [r0, #44]	; 0x2c
 * @param[in] flags     pre-shifted content of the ISR register
 *
 * @notapi
 */
static void i2c_lld_serve_rx_end_irq(I2CDriver *i2cp, uint32_t flags) {
  I2C_TypeDef *dp = i2cp->i2c;
 8000b6a:	6b43      	ldr	r3, [r0, #52]	; 0x34
  }
#else
  (void)flags;
#endif

  dmaStreamDisable(i2cp->dmarx);
 8000b6c:	6866      	ldr	r6, [r4, #4]
 8000b6e:	6827      	ldr	r7, [r4, #0]
 8000b70:	6835      	ldr	r5, [r6, #0]
 8000b72:	220f      	movs	r2, #15
 8000b74:	f025 050f 	bic.w	r5, r5, #15
 8000b78:	6035      	str	r5, [r6, #0]
 8000b7a:	7c25      	ldrb	r5, [r4, #16]
 8000b7c:	2420      	movs	r4, #32
 8000b7e:	40aa      	lsls	r2, r5
 8000b80:	607a      	str	r2, [r7, #4]

  dp->CR2 &= ~I2C_CR2_LAST;
 8000b82:	685a      	ldr	r2, [r3, #4]
 8000b84:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
 8000b88:	605a      	str	r2, [r3, #4]
  dp->CR1 &= ~I2C_CR1_ACK;
 8000b8a:	681a      	ldr	r2, [r3, #0]
 8000b8c:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 8000b90:	601a      	str	r2, [r3, #0]
  dp->CR1 |= I2C_CR1_STOP;
 8000b92:	681a      	ldr	r2, [r3, #0]
 8000b94:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 8000b98:	601a      	str	r2, [r3, #0]
 8000b9a:	f384 8811 	msr	BASEPRI, r4
 *
 * @iclass
 */
void chThdResumeI(thread_reference_t *trp, msg_t msg) {

  if (*trp != NULL) {
 8000b9e:	69c3      	ldr	r3, [r0, #28]
 8000ba0:	b123      	cbz	r3, 8000bac <i2c_lld_serve_rx_end_irq.lto_priv.34+0x4c>
    thread_t *tp = *trp;

    chDbgAssert(tp->state == CH_STATE_SUSPENDED, "not CH_STATE_SUSPENDED");

    *trp = NULL;
 8000ba2:	61c1      	str	r1, [r0, #28]
    tp->u.rdymsg = msg;
    (void) chSchReadyI(tp);
 8000ba4:	4618      	mov	r0, r3
    thread_t *tp = *trp;

    chDbgAssert(tp->state == CH_STATE_SUSPENDED, "not CH_STATE_SUSPENDED");

    *trp = NULL;
    tp->u.rdymsg = msg;
 8000ba6:	6259      	str	r1, [r3, #36]	; 0x24
    (void) chSchReadyI(tp);
 8000ba8:	f000 fff2 	bl	8001b90 <chSchReadyI>
 8000bac:	2300      	movs	r3, #0
 8000bae:	f383 8811 	msr	BASEPRI, r3
 8000bb2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000bb4:	b672      	cpsid	i
 8000bb6:	4b02      	ldr	r3, [pc, #8]	; (8000bc0 <i2c_lld_serve_rx_end_irq.lto_priv.34+0x60>)
 8000bb8:	4a02      	ldr	r2, [pc, #8]	; (8000bc4 <i2c_lld_serve_rx_end_irq.lto_priv.34+0x64>)
 8000bba:	629a      	str	r2, [r3, #40]	; 0x28
 8000bbc:	e7fe      	b.n	8000bbc <i2c_lld_serve_rx_end_irq.lto_priv.34+0x5c>
 8000bbe:	bf00      	nop
 8000bc0:	20000918 	.word	0x20000918
 8000bc4:	0800284c 	.word	0x0800284c
	...

08000bd0 <mf_character_width>:
    return width;
}

uint8_t mf_character_width(const struct mf_font_s *font,
                           mf_char character)
{
 8000bd0:	b510      	push	{r4, lr}
    uint8_t width;
    width = font->character_width(font, MFCHAR2UINT16(character));
 8000bd2:	6943      	ldr	r3, [r0, #20]
    return width;
}

uint8_t mf_character_width(const struct mf_font_s *font,
                           mf_char character)
{
 8000bd4:	4604      	mov	r4, r0
    uint8_t width;
    width = font->character_width(font, MFCHAR2UINT16(character));
 8000bd6:	4798      	blx	r3
    
    if (!width)
 8000bd8:	b100      	cbz	r0, 8000bdc <mf_character_width+0xc>
    {
        width = font->character_width(font, font->fallback_character);
    }
    
    return width;
}
 8000bda:	bd10      	pop	{r4, pc}
    uint8_t width;
    width = font->character_width(font, MFCHAR2UINT16(character));
    
    if (!width)
    {
        width = font->character_width(font, font->fallback_character);
 8000bdc:	6963      	ldr	r3, [r4, #20]
 8000bde:	8a21      	ldrh	r1, [r4, #16]
 8000be0:	4620      	mov	r0, r4
    }
    
    return width;
}
 8000be2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    uint8_t width;
    width = font->character_width(font, MFCHAR2UINT16(character));
    
    if (!width)
    {
        width = font->character_width(font, font->fallback_character);
 8000be6:	4718      	bx	r3
	...

08000bf0 <mf_round_to_tab.lto_priv.37>:

#if MF_USE_TABS
/* Round the X coordinate up to the nearest tab stop. */
static int16_t mf_round_to_tab(const struct mf_font_s *font,
                               int16_t x0, int16_t x)
{
 8000bf0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8000bf2:	460f      	mov	r7, r1
    int16_t tabw, dx;
    
    tabw = mf_character_width(font, 'm') * MF_TABSIZE;
 8000bf4:	216d      	movs	r1, #109	; 0x6d

#if MF_USE_TABS
/* Round the X coordinate up to the nearest tab stop. */
static int16_t mf_round_to_tab(const struct mf_font_s *font,
                               int16_t x0, int16_t x)
{
 8000bf6:	4614      	mov	r4, r2
 8000bf8:	4606      	mov	r6, r0
    int16_t tabw, dx;
    
    tabw = mf_character_width(font, 'm') * MF_TABSIZE;
 8000bfa:	f7ff ffe9 	bl	8000bd0 <mf_character_width>
    
    /* Always atleast 1 space */
    x += mf_character_width(font, ' ');
 8000bfe:	2120      	movs	r1, #32
static int16_t mf_round_to_tab(const struct mf_font_s *font,
                               int16_t x0, int16_t x)
{
    int16_t tabw, dx;
    
    tabw = mf_character_width(font, 'm') * MF_TABSIZE;
 8000c00:	00c2      	lsls	r2, r0, #3
    
    /* Always atleast 1 space */
    x += mf_character_width(font, ' ');
 8000c02:	4630      	mov	r0, r6
static int16_t mf_round_to_tab(const struct mf_font_s *font,
                               int16_t x0, int16_t x)
{
    int16_t tabw, dx;
    
    tabw = mf_character_width(font, 'm') * MF_TABSIZE;
 8000c04:	b295      	uxth	r5, r2
    
    /* Always atleast 1 space */
    x += mf_character_width(font, ' ');
 8000c06:	f7ff ffe3 	bl	8000bd0 <mf_character_width>
    
    /* Round to next tab stop */
    dx = x - x0 + font->baseline_x;
    x += tabw - (dx % tabw);
    
    return x;
 8000c0a:	7b33      	ldrb	r3, [r6, #12]
    int16_t tabw, dx;
    
    tabw = mf_character_width(font, 'm') * MF_TABSIZE;
    
    /* Always atleast 1 space */
    x += mf_character_width(font, ' ');
 8000c0c:	4420      	add	r0, r4
 8000c0e:	b282      	uxth	r2, r0
    
    /* Round to next tab stop */
    dx = x - x0 + font->baseline_x;
    x += tabw - (dx % tabw);
    
    return x;
 8000c10:	1bdb      	subs	r3, r3, r7
 8000c12:	4413      	add	r3, r2
 8000c14:	b21b      	sxth	r3, r3
 8000c16:	fb93 f0f5 	sdiv	r0, r3, r5
 8000c1a:	fb05 3010 	mls	r0, r5, r0, r3
 8000c1e:	442a      	add	r2, r5
 8000c20:	1a10      	subs	r0, r2, r0
}
 8000c22:	b200      	sxth	r0, r0
 8000c24:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8000c26:	bf00      	nop
	...

08000c30 <mf_getchar>:
{
    uint8_t c;
    uint8_t tmp, seqlen;
    uint16_t result;
    
    c = **str;
 8000c30:	6802      	ldr	r2, [r0, #0]
 8000c32:	7813      	ldrb	r3, [r2, #0]
    if (!c)
 8000c34:	b373      	cbz	r3, 8000c94 <mf_getchar+0x64>
#ifndef MF_NO_COMPILE

#if MF_ENCODING == MF_ENCODING_UTF8

mf_char mf_getchar(mf_str *str)
{
 8000c36:	b5f0      	push	{r4, r5, r6, r7, lr}
    if (!c)
        return 0;
    
    (*str)++;
    
    if ((c & 0x80) == 0)
 8000c38:	0619      	lsls	r1, r3, #24
    
    c = **str;
    if (!c)
        return 0;
    
    (*str)++;
 8000c3a:	f102 0601 	add.w	r6, r2, #1
 8000c3e:	6006      	str	r6, [r0, #0]
    
    if ((c & 0x80) == 0)
 8000c40:	d402      	bmi.n	8000c48 <mf_getchar+0x18>
    else if ((**str & 0xC0) == 0xC0)
    {
        /* Start of multibyte sequence without any following bytes.
         * Silly. Maybe you are using the wrong encoding.
         */
        return c;
 8000c42:	b29b      	uxth	r3, r3
        (*str)++;
        
        result |= (c & (tmp - 1)) << ((seqlen - 1) * 6);
        return result;
    }
}
 8000c44:	4618      	mov	r0, r3
 8000c46:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if ((c & 0x80) == 0)
    {
        /* Just normal ASCII character. */
        return c;
    }
    else if ((c & 0xC0) == 0x80)
 8000c48:	f003 01c0 	and.w	r1, r3, #192	; 0xc0
 8000c4c:	2980      	cmp	r1, #128	; 0x80
 8000c4e:	d0f8      	beq.n	8000c42 <mf_getchar+0x12>
        /* Dangling piece of corrupted multibyte sequence.
         * Did you cut the string in the wrong place?
         */
        return c;
    }
    else if ((**str & 0xC0) == 0xC0)
 8000c50:	7851      	ldrb	r1, [r2, #1]
 8000c52:	f001 04c0 	and.w	r4, r1, #192	; 0xc0
 8000c56:	2cc0      	cmp	r4, #192	; 0xc0
 8000c58:	d0f3      	beq.n	8000c42 <mf_getchar+0x12>
         * Find out how many characters and combine them.
         */
        seqlen = 2;
        tmp = 0x20;
        result = 0;
        while ((c & tmp) && (seqlen < 5))
 8000c5a:	f003 0420 	and.w	r4, r3, #32
 8000c5e:	f004 05ff 	and.w	r5, r4, #255	; 0xff
 8000c62:	b3a4      	cbz	r4, 8000cce <mf_getchar+0x9e>
 8000c64:	3204      	adds	r2, #4
 8000c66:	2500      	movs	r5, #0
 8000c68:	2702      	movs	r7, #2
 8000c6a:	2420      	movs	r4, #32
        {
            seqlen++;
            tmp >>= 1;
            
            result = (result << 6) | (**str & 0x3F);
 8000c6c:	f001 013f 	and.w	r1, r1, #63	; 0x3f
        tmp = 0x20;
        result = 0;
        while ((c & tmp) && (seqlen < 5))
        {
            seqlen++;
            tmp >>= 1;
 8000c70:	0864      	lsrs	r4, r4, #1
            
            result = (result << 6) | (**str & 0x3F);
 8000c72:	ea41 1585 	orr.w	r5, r1, r5, lsl #6
        seqlen = 2;
        tmp = 0x20;
        result = 0;
        while ((c & tmp) && (seqlen < 5))
        {
            seqlen++;
 8000c76:	3701      	adds	r7, #1
            tmp >>= 1;
            
            result = (result << 6) | (**str & 0x3F);
            (*str)++;
 8000c78:	f106 0e01 	add.w	lr, r6, #1
         * Find out how many characters and combine them.
         */
        seqlen = 2;
        tmp = 0x20;
        result = 0;
        while ((c & tmp) && (seqlen < 5))
 8000c7c:	4223      	tst	r3, r4
        {
            seqlen++;
            tmp >>= 1;
            
            result = (result << 6) | (**str & 0x3F);
 8000c7e:	b2ad      	uxth	r5, r5
        seqlen = 2;
        tmp = 0x20;
        result = 0;
        while ((c & tmp) && (seqlen < 5))
        {
            seqlen++;
 8000c80:	b2ff      	uxtb	r7, r7
            tmp >>= 1;
            
            result = (result << 6) | (**str & 0x3F);
            (*str)++;
 8000c82:	f8c0 e000 	str.w	lr, [r0]
         * Find out how many characters and combine them.
         */
        seqlen = 2;
        tmp = 0x20;
        result = 0;
        while ((c & tmp) && (seqlen < 5))
 8000c86:	d018      	beq.n	8000cba <mf_getchar+0x8a>
 8000c88:	4596      	cmp	lr, r2
 8000c8a:	d005      	beq.n	8000c98 <mf_getchar+0x68>
 8000c8c:	f89e 1000 	ldrb.w	r1, [lr]
 8000c90:	4676      	mov	r6, lr
 8000c92:	e7eb      	b.n	8000c6c <mf_getchar+0x3c>
        (*str)++;
        
        result |= (c & (tmp - 1)) << ((seqlen - 1) * 6);
        return result;
    }
}
 8000c94:	4618      	mov	r0, r3
 8000c96:	4770      	bx	lr
 8000c98:	01ad      	lsls	r5, r5, #6
 8000c9a:	7871      	ldrb	r1, [r6, #1]
 8000c9c:	b22d      	sxth	r5, r5
 8000c9e:	3c01      	subs	r4, #1
         * Find out how many characters and combine them.
         */
        seqlen = 2;
        tmp = 0x20;
        result = 0;
        while ((c & tmp) && (seqlen < 5))
 8000ca0:	2718      	movs	r7, #24
        }
        
        result = (result << 6) | (**str & 0x3F);
        (*str)++;
        
        result |= (c & (tmp - 1)) << ((seqlen - 1) * 6);
 8000ca2:	f001 013f 	and.w	r1, r1, #63	; 0x3f
 8000ca6:	401c      	ands	r4, r3
 8000ca8:	430d      	orrs	r5, r1
 8000caa:	fa04 f307 	lsl.w	r3, r4, r7
 8000cae:	432b      	orrs	r3, r5
            result = (result << 6) | (**str & 0x3F);
            (*str)++;
        }
        
        result = (result << 6) | (**str & 0x3F);
        (*str)++;
 8000cb0:	3201      	adds	r2, #1
        
        result |= (c & (tmp - 1)) << ((seqlen - 1) * 6);
 8000cb2:	b29b      	uxth	r3, r3
            result = (result << 6) | (**str & 0x3F);
            (*str)++;
        }
        
        result = (result << 6) | (**str & 0x3F);
        (*str)++;
 8000cb4:	6002      	str	r2, [r0, #0]
        
        result |= (c & (tmp - 1)) << ((seqlen - 1) * 6);
        return result;
    }
}
 8000cb6:	4618      	mov	r0, r3
 8000cb8:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8000cba:	3f01      	subs	r7, #1
 8000cbc:	eb07 0747 	add.w	r7, r7, r7, lsl #1
 8000cc0:	01ad      	lsls	r5, r5, #6
 8000cc2:	007f      	lsls	r7, r7, #1
 8000cc4:	b22d      	sxth	r5, r5
 8000cc6:	7871      	ldrb	r1, [r6, #1]
 8000cc8:	3c01      	subs	r4, #1
        {
            seqlen++;
            tmp >>= 1;
            
            result = (result << 6) | (**str & 0x3F);
            (*str)++;
 8000cca:	4672      	mov	r2, lr
 8000ccc:	e7e9      	b.n	8000ca2 <mf_getchar+0x72>
         * Find out how many characters and combine them.
         */
        seqlen = 2;
        tmp = 0x20;
        result = 0;
        while ((c & tmp) && (seqlen < 5))
 8000cce:	4632      	mov	r2, r6
 8000cd0:	2706      	movs	r7, #6
 8000cd2:	241f      	movs	r4, #31
 8000cd4:	e7e5      	b.n	8000ca2 <mf_getchar+0x72>
 8000cd6:	bf00      	nop
	...

08000ce0 <matchfont.lto_priv.38>:
static const struct mf_font_list_s *fontList;

/**
 * Match a pattern against the font name.
 */
static bool_t matchfont(const char *pattern, const char *name) {
 8000ce0:	b410      	push	{r4}
 8000ce2:	780b      	ldrb	r3, [r1, #0]
 8000ce4:	7802      	ldrb	r2, [r0, #0]
	while(1) {
		switch (pattern[0]) {
 8000ce6:	b14a      	cbz	r2, 8000cfc <matchfont.lto_priv.38+0x1c>
 8000ce8:	2a2a      	cmp	r2, #42	; 0x2a
 8000cea:	d00c      	beq.n	8000d06 <matchfont.lto_priv.38+0x26>
				name++;
			break;
		case 0:
			return name[0] == 0;
		default:
			if (name[0] != pattern[0])
 8000cec:	429a      	cmp	r2, r3
 8000cee:	d118      	bne.n	8000d22 <matchfont.lto_priv.38+0x42>
 8000cf0:	7842      	ldrb	r2, [r0, #1]
 8000cf2:	784b      	ldrb	r3, [r1, #1]
				return FALSE;
			pattern++;
 8000cf4:	3001      	adds	r0, #1
			name++;
 8000cf6:	3101      	adds	r1, #1
/**
 * Match a pattern against the font name.
 */
static bool_t matchfont(const char *pattern, const char *name) {
	while(1) {
		switch (pattern[0]) {
 8000cf8:	2a00      	cmp	r2, #0
 8000cfa:	d1f5      	bne.n	8000ce8 <matchfont.lto_priv.38+0x8>
				pattern++;
			else
				name++;
			break;
		case 0:
			return name[0] == 0;
 8000cfc:	fab3 f083 	clz	r0, r3
 8000d00:	0940      	lsrs	r0, r0, #5
			pattern++;
			name++;
			break;
		}
	}
}
 8000d02:	bc10      	pop	{r4}
 8000d04:	4770      	bx	lr
 8000d06:	7844      	ldrb	r4, [r0, #1]
 */
static bool_t matchfont(const char *pattern, const char *name) {
	while(1) {
		switch (pattern[0]) {
		case '*':
			if (name[0] == 0)
 8000d08:	b13b      	cbz	r3, 8000d1a <matchfont.lto_priv.38+0x3a>
				return pattern[1] == 0;
			if (pattern[1] == name[0])
 8000d0a:	429c      	cmp	r4, r3
 8000d0c:	4622      	mov	r2, r4
 8000d0e:	d002      	beq.n	8000d16 <matchfont.lto_priv.38+0x36>
 8000d10:	784b      	ldrb	r3, [r1, #1]
				pattern++;
			else
				name++;
 8000d12:	3101      	adds	r1, #1
 8000d14:	e7f8      	b.n	8000d08 <matchfont.lto_priv.38+0x28>
		switch (pattern[0]) {
		case '*':
			if (name[0] == 0)
				return pattern[1] == 0;
			if (pattern[1] == name[0])
				pattern++;
 8000d16:	3001      	adds	r0, #1
 8000d18:	e7e5      	b.n	8000ce6 <matchfont.lto_priv.38+0x6>
static bool_t matchfont(const char *pattern, const char *name) {
	while(1) {
		switch (pattern[0]) {
		case '*':
			if (name[0] == 0)
				return pattern[1] == 0;
 8000d1a:	fab4 f084 	clz	r0, r4
 8000d1e:	0940      	lsrs	r0, r0, #5
 8000d20:	e7ef      	b.n	8000d02 <matchfont.lto_priv.38+0x22>
			break;
		case 0:
			return name[0] == 0;
		default:
			if (name[0] != pattern[0])
				return FALSE;
 8000d22:	2000      	movs	r0, #0
 8000d24:	e7ed      	b.n	8000d02 <matchfont.lto_priv.38+0x22>
 8000d26:	bf00      	nop
	...

08000d30 <__early_init>:
void stm32_clock_init(void) {

#if !STM32_NO_INIT
  /* HSI setup, it enforces the reset situation in order to handle possible
     problems with JTAG probes and re-initializations.*/
  RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
 8000d30:	4b1e      	ldr	r3, [pc, #120]	; (8000dac <__early_init+0x7c>)
  while (!(RCC->CR & RCC_CR_HSIRDY))
 8000d32:	4619      	mov	r1, r3
void stm32_clock_init(void) {

#if !STM32_NO_INIT
  /* HSI setup, it enforces the reset situation in order to handle possible
     problems with JTAG probes and re-initializations.*/
  RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
 8000d34:	681a      	ldr	r2, [r3, #0]
 8000d36:	f042 0201 	orr.w	r2, r2, #1
 8000d3a:	601a      	str	r2, [r3, #0]
  while (!(RCC->CR & RCC_CR_HSIRDY))
 8000d3c:	680b      	ldr	r3, [r1, #0]
 8000d3e:	4a1b      	ldr	r2, [pc, #108]	; (8000dac <__early_init+0x7c>)
 8000d40:	079b      	lsls	r3, r3, #30
 8000d42:	d5fb      	bpl.n	8000d3c <__early_init+0xc>
    ;                                       /* Wait until HSI is stable.    */
  RCC->CR &= RCC_CR_HSITRIM | RCC_CR_HSION; /* CR Reset value.              */
  RCC->CFGR = 0;                            /* CFGR reset value.            */
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
 8000d44:	4611      	mov	r1, r2
  /* HSI setup, it enforces the reset situation in order to handle possible
     problems with JTAG probes and re-initializations.*/
  RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
  while (!(RCC->CR & RCC_CR_HSIRDY))
    ;                                       /* Wait until HSI is stable.    */
  RCC->CR &= RCC_CR_HSITRIM | RCC_CR_HSION; /* CR Reset value.              */
 8000d46:	6813      	ldr	r3, [r2, #0]
  RCC->CFGR = 0;                            /* CFGR reset value.            */
 8000d48:	2000      	movs	r0, #0
  /* HSI setup, it enforces the reset situation in order to handle possible
     problems with JTAG probes and re-initializations.*/
  RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
  while (!(RCC->CR & RCC_CR_HSIRDY))
    ;                                       /* Wait until HSI is stable.    */
  RCC->CR &= RCC_CR_HSITRIM | RCC_CR_HSION; /* CR Reset value.              */
 8000d4a:	f003 03f9 	and.w	r3, r3, #249	; 0xf9
 8000d4e:	6013      	str	r3, [r2, #0]
  RCC->CFGR = 0;                            /* CFGR reset value.            */
 8000d50:	6050      	str	r0, [r2, #4]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
 8000d52:	684b      	ldr	r3, [r1, #4]
 8000d54:	4a15      	ldr	r2, [pc, #84]	; (8000dac <__early_init+0x7c>)
 8000d56:	f013 0f0c 	tst.w	r3, #12
 8000d5a:	d1fa      	bne.n	8000d52 <__early_init+0x22>
  /* HSE Bypass.*/
  RCC->CR |= RCC_CR_HSEON | RCC_CR_HSEBYP;
#endif
  /* HSE activation.*/
  RCC->CR |= RCC_CR_HSEON;
  while (!(RCC->CR & RCC_CR_HSERDY))
 8000d5c:	4611      	mov	r1, r2
#if defined(STM32_HSE_BYPASS)
  /* HSE Bypass.*/
  RCC->CR |= RCC_CR_HSEON | RCC_CR_HSEBYP;
#endif
  /* HSE activation.*/
  RCC->CR |= RCC_CR_HSEON;
 8000d5e:	6813      	ldr	r3, [r2, #0]
 8000d60:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8000d64:	6013      	str	r3, [r2, #0]
  while (!(RCC->CR & RCC_CR_HSERDY))
 8000d66:	680b      	ldr	r3, [r1, #0]
 8000d68:	4a10      	ldr	r2, [pc, #64]	; (8000dac <__early_init+0x7c>)
 8000d6a:	0398      	lsls	r0, r3, #14
 8000d6c:	d5fb      	bpl.n	8000d66 <__early_init+0x36>

#if STM32_ACTIVATE_PLL
  /* PLL activation.*/
  RCC->CFGR |= STM32_PLLMUL | STM32_PLLXTPRE | STM32_PLLSRC;
  RCC->CR   |= RCC_CR_PLLON;
  while (!(RCC->CR & RCC_CR_PLLRDY))
 8000d6e:	4611      	mov	r1, r2
    ;                                       /* Waits until LSI is stable.   */
#endif

#if STM32_ACTIVATE_PLL
  /* PLL activation.*/
  RCC->CFGR |= STM32_PLLMUL | STM32_PLLXTPRE | STM32_PLLSRC;
 8000d70:	6853      	ldr	r3, [r2, #4]
 8000d72:	f443 13e8 	orr.w	r3, r3, #1900544	; 0x1d0000
 8000d76:	6053      	str	r3, [r2, #4]
  RCC->CR   |= RCC_CR_PLLON;
 8000d78:	6813      	ldr	r3, [r2, #0]
 8000d7a:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 8000d7e:	6013      	str	r3, [r2, #0]
  while (!(RCC->CR & RCC_CR_PLLRDY))
 8000d80:	680b      	ldr	r3, [r1, #0]
 8000d82:	4a0a      	ldr	r2, [pc, #40]	; (8000dac <__early_init+0x7c>)
 8000d84:	019b      	lsls	r3, r3, #6
 8000d86:	d5fb      	bpl.n	8000d80 <__early_init+0x50>

  /* Switching to the configured clock source if it is different from HSI.*/
#if (STM32_SW != STM32_SW_HSI)
  /* Switches clock source.*/
  RCC->CFGR |= STM32_SW;
  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
 8000d88:	4611      	mov	r1, r2
/*
 * Early initialization code.
 * This initialization must be performed just after stack setup and before
 * any other initialization.
 */
void __early_init(void) {
 8000d8a:	b410      	push	{r4}
              STM32_PLLSRC | STM32_ADCPRE | STM32_PPRE2  | STM32_PPRE1    |
              STM32_HPRE;
#endif

  /* Flash setup and final clock selection.   */
  FLASH->ACR = STM32_FLASHBITS;
 8000d8c:	4b08      	ldr	r3, [pc, #32]	; (8000db0 <__early_init+0x80>)
    ;                                       /* Waits until PLL is stable.   */
#endif

  /* Clock settings.*/
#if STM32_HAS_USB
  RCC->CFGR = STM32_MCOSEL | STM32_USBPRE | STM32_PLLMUL | STM32_PLLXTPRE |
 8000d8e:	4c09      	ldr	r4, [pc, #36]	; (8000db4 <__early_init+0x84>)
              STM32_PLLSRC | STM32_ADCPRE | STM32_PPRE2  | STM32_PPRE1    |
              STM32_HPRE;
#endif

  /* Flash setup and final clock selection.   */
  FLASH->ACR = STM32_FLASHBITS;
 8000d90:	2012      	movs	r0, #18
    ;                                       /* Waits until PLL is stable.   */
#endif

  /* Clock settings.*/
#if STM32_HAS_USB
  RCC->CFGR = STM32_MCOSEL | STM32_USBPRE | STM32_PLLMUL | STM32_PLLXTPRE |
 8000d92:	6054      	str	r4, [r2, #4]
              STM32_PLLSRC | STM32_ADCPRE | STM32_PPRE2  | STM32_PPRE1    |
              STM32_HPRE;
#endif

  /* Flash setup and final clock selection.   */
  FLASH->ACR = STM32_FLASHBITS;
 8000d94:	6018      	str	r0, [r3, #0]

  /* Switching to the configured clock source if it is different from HSI.*/
#if (STM32_SW != STM32_SW_HSI)
  /* Switches clock source.*/
  RCC->CFGR |= STM32_SW;
 8000d96:	6853      	ldr	r3, [r2, #4]
 8000d98:	f043 0302 	orr.w	r3, r3, #2
 8000d9c:	6053      	str	r3, [r2, #4]
  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
 8000d9e:	684b      	ldr	r3, [r1, #4]
 8000da0:	f003 030c 	and.w	r3, r3, #12
 8000da4:	2b08      	cmp	r3, #8
 8000da6:	d1fa      	bne.n	8000d9e <__early_init+0x6e>

  stm32_clock_init();
}
 8000da8:	bc10      	pop	{r4}
 8000daa:	4770      	bx	lr
 8000dac:	40021000 	.word	0x40021000
 8000db0:	40022000 	.word	0x40022000
 8000db4:	001d6400 	.word	0x001d6400
	...

08000dc0 <i2c_lld_init>:
/**
 * @brief   Low level I2C driver initialization.
 *
 * @notapi
 */
void i2c_lld_init(void) {
 8000dc0:	b5f0      	push	{r4, r5, r6, r7, lr}

#if STM32_I2C_USE_I2C1
  i2cObjectInit(&I2CD1);
  I2CD1.thread = NULL;
  I2CD1.i2c    = I2C1;
  I2CD1.dmarx  = STM32_DMA_STREAM(STM32_I2C_I2C1_RX_DMA_STREAM);
 8000dc2:	4913      	ldr	r1, [pc, #76]	; (8000e10 <i2c_lld_init+0x50>)
 *
 * @init
 */
void i2cObjectInit(I2CDriver *i2cp) {

  i2cp->state  = I2C_STOP;
 8000dc4:	4a13      	ldr	r2, [pc, #76]	; (8000e14 <i2c_lld_init+0x54>)
 8000dc6:	4b14      	ldr	r3, [pc, #80]	; (8000e18 <i2c_lld_init+0x58>)
void i2c_lld_init(void) {

#if STM32_I2C_USE_I2C1
  i2cObjectInit(&I2CD1);
  I2CD1.thread = NULL;
  I2CD1.i2c    = I2C1;
 8000dc8:	4814      	ldr	r0, [pc, #80]	; (8000e1c <i2c_lld_init+0x5c>)
  I2CD1.dmarx  = STM32_DMA_STREAM(STM32_I2C_I2C1_RX_DMA_STREAM);
 8000dca:	f101 0578 	add.w	r5, r1, #120	; 0x78
  I2CD1.dmatx  = STM32_DMA_STREAM(STM32_I2C_I2C1_TX_DMA_STREAM);
 8000dce:	f101 0464 	add.w	r4, r1, #100	; 0x64
#endif /* STM32_I2C_USE_I2C1 */

#if STM32_I2C_USE_I2C2
  i2cObjectInit(&I2CD2);
  I2CD2.thread = NULL;
  I2CD2.i2c    = I2C2;
 8000dd2:	4f13      	ldr	r7, [pc, #76]	; (8000e20 <i2c_lld_init+0x60>)
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8000dd4:	f102 060c 	add.w	r6, r2, #12
  I2CD2.dmarx  = STM32_DMA_STREAM(STM32_I2C_I2C2_RX_DMA_STREAM);
 8000dd8:	f101 0e50 	add.w	lr, r1, #80	; 0x50
void i2c_lld_init(void) {

#if STM32_I2C_USE_I2C1
  i2cObjectInit(&I2CD1);
  I2CD1.thread = NULL;
  I2CD1.i2c    = I2C1;
 8000ddc:	6350      	str	r0, [r2, #52]	; 0x34
  I2CD1.dmarx  = STM32_DMA_STREAM(STM32_I2C_I2C1_RX_DMA_STREAM);
 8000dde:	62d5      	str	r5, [r2, #44]	; 0x2c
#if STM32_I2C_USE_I2C2
  i2cObjectInit(&I2CD2);
  I2CD2.thread = NULL;
  I2CD2.i2c    = I2C2;
  I2CD2.dmarx  = STM32_DMA_STREAM(STM32_I2C_I2C2_RX_DMA_STREAM);
  I2CD2.dmatx  = STM32_DMA_STREAM(STM32_I2C_I2C2_TX_DMA_STREAM);
 8000de0:	f101 003c 	add.w	r0, r1, #60	; 0x3c
 8000de4:	f103 050c 	add.w	r5, r3, #12
  i2cp->config = NULL;
 8000de8:	2100      	movs	r1, #0
#if STM32_I2C_USE_I2C1
  i2cObjectInit(&I2CD1);
  I2CD1.thread = NULL;
  I2CD1.i2c    = I2C1;
  I2CD1.dmarx  = STM32_DMA_STREAM(STM32_I2C_I2C1_RX_DMA_STREAM);
  I2CD1.dmatx  = STM32_DMA_STREAM(STM32_I2C_I2C1_TX_DMA_STREAM);
 8000dea:	6314      	str	r4, [r2, #48]	; 0x30
 *
 * @init
 */
void i2cObjectInit(I2CDriver *i2cp) {

  i2cp->state  = I2C_STOP;
 8000dec:	2401      	movs	r4, #1
 8000dee:	60d6      	str	r6, [r2, #12]
  tqp->prev = (thread_t *)tqp;
 8000df0:	6116      	str	r6, [r2, #16]

#if STM32_I2C_USE_I2C2
  i2cObjectInit(&I2CD2);
  I2CD2.thread = NULL;
  I2CD2.i2c    = I2C2;
  I2CD2.dmarx  = STM32_DMA_STREAM(STM32_I2C_I2C2_RX_DMA_STREAM);
 8000df2:	f8c3 e02c 	str.w	lr, [r3, #44]	; 0x2c
  I2CD2.dmatx  = STM32_DMA_STREAM(STM32_I2C_I2C2_TX_DMA_STREAM);
 8000df6:	6318      	str	r0, [r3, #48]	; 0x30
#endif /* STM32_I2C_USE_I2C1 */

#if STM32_I2C_USE_I2C2
  i2cObjectInit(&I2CD2);
  I2CD2.thread = NULL;
  I2CD2.i2c    = I2C2;
 8000df8:	635f      	str	r7, [r3, #52]	; 0x34
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8000dfa:	60dd      	str	r5, [r3, #12]
  tqp->prev = (thread_t *)tqp;
 8000dfc:	611d      	str	r5, [r3, #16]
 8000dfe:	7014      	strb	r4, [r2, #0]
 8000e00:	701c      	strb	r4, [r3, #0]
  i2cp->config = NULL;
 8000e02:	6051      	str	r1, [r2, #4]
void chMtxObjectInit(mutex_t *mp) {

  chDbgCheck(mp != NULL);

  queue_init(&mp->queue);
  mp->owner = NULL;
 8000e04:	6151      	str	r1, [r2, #20]
 */
void i2c_lld_init(void) {

#if STM32_I2C_USE_I2C1
  i2cObjectInit(&I2CD1);
  I2CD1.thread = NULL;
 8000e06:	61d1      	str	r1, [r2, #28]
 8000e08:	6059      	str	r1, [r3, #4]
 8000e0a:	6159      	str	r1, [r3, #20]
  I2CD1.dmatx  = STM32_DMA_STREAM(STM32_I2C_I2C1_TX_DMA_STREAM);
#endif /* STM32_I2C_USE_I2C1 */

#if STM32_I2C_USE_I2C2
  i2cObjectInit(&I2CD2);
  I2CD2.thread = NULL;
 8000e0c:	61d9      	str	r1, [r3, #28]
 8000e0e:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8000e10:	08002858 	.word	0x08002858
 8000e14:	20000a04 	.word	0x20000a04
 8000e18:	20000988 	.word	0x20000988
 8000e1c:	40005400 	.word	0x40005400
 8000e20:	40005800 	.word	0x40005800
	...

08000e30 <dmaStreamRelease>:
 *
 * @param[in] dmastp    pointer to a stm32_dma_stream_t structure
 *
 * @special
 */
void dmaStreamRelease(const stm32_dma_stream_t *dmastp) {
 8000e30:	b4f0      	push	{r4, r5, r6, r7}
  /* Check if the streams is not taken.*/
  osalDbgAssert((dma_streams_mask & (1 << dmastp->selfindex)) != 0U,
                "not allocated");

  /* Marks the stream as not allocated.*/
  dma_streams_mask &= ~(1U << dmastp->selfindex);
 8000e32:	4c16      	ldr	r4, [pc, #88]	; (8000e8c <dmaStreamRelease+0x5c>)
 8000e34:	7c42      	ldrb	r2, [r0, #17]
 8000e36:	6823      	ldr	r3, [r4, #0]
 8000e38:	2501      	movs	r5, #1
 8000e3a:	fa05 f602 	lsl.w	r6, r5, r2

  /* Disables the associated IRQ vector if it is no more in use.*/
  if ((dma_streams_mask & dmastp->cmask) == 0U) {
 8000e3e:	6881      	ldr	r1, [r0, #8]
  /* Check if the streams is not taken.*/
  osalDbgAssert((dma_streams_mask & (1 << dmastp->selfindex)) != 0U,
                "not allocated");

  /* Marks the stream as not allocated.*/
  dma_streams_mask &= ~(1U << dmastp->selfindex);
 8000e40:	ea23 0306 	bic.w	r3, r3, r6

  /* Disables the associated IRQ vector if it is no more in use.*/
  if ((dma_streams_mask & dmastp->cmask) == 0U) {
 8000e44:	4019      	ands	r1, r3
  /* Check if the streams is not taken.*/
  osalDbgAssert((dma_streams_mask & (1 << dmastp->selfindex)) != 0U,
                "not allocated");

  /* Marks the stream as not allocated.*/
  dma_streams_mask &= ~(1U << dmastp->selfindex);
 8000e46:	6023      	str	r3, [r4, #0]

  /* Disables the associated IRQ vector if it is no more in use.*/
  if ((dma_streams_mask & dmastp->cmask) == 0U) {
 8000e48:	d00f      	beq.n	8000e6a <dmaStreamRelease+0x3a>
    nvicDisableVector(dmastp->vector);
  }

  /* Removes the DMA handler.*/
  _stm32_dma_isr_redir[dmastp->selfindex].dma_func  = NULL;
 8000e4a:	4911      	ldr	r1, [pc, #68]	; (8000e90 <dmaStreamRelease+0x60>)
 8000e4c:	2000      	movs	r0, #0
  _stm32_dma_isr_redir[dmastp->selfindex].dma_param = NULL;
 8000e4e:	eb01 04c2 	add.w	r4, r1, r2, lsl #3

  /* Shutting down clocks that are no more required, if any.*/
  if ((dma_streams_mask & STM32_DMA1_STREAMS_MASK) == 0U) {
 8000e52:	065b      	lsls	r3, r3, #25
    nvicDisableVector(dmastp->vector);
  }

  /* Removes the DMA handler.*/
  _stm32_dma_isr_redir[dmastp->selfindex].dma_func  = NULL;
  _stm32_dma_isr_redir[dmastp->selfindex].dma_param = NULL;
 8000e54:	6060      	str	r0, [r4, #4]
  if ((dma_streams_mask & dmastp->cmask) == 0U) {
    nvicDisableVector(dmastp->vector);
  }

  /* Removes the DMA handler.*/
  _stm32_dma_isr_redir[dmastp->selfindex].dma_func  = NULL;
 8000e56:	f841 0032 	str.w	r0, [r1, r2, lsl #3]
  _stm32_dma_isr_redir[dmastp->selfindex].dma_param = NULL;

  /* Shutting down clocks that are no more required, if any.*/
  if ((dma_streams_mask & STM32_DMA1_STREAMS_MASK) == 0U) {
 8000e5a:	d104      	bne.n	8000e66 <dmaStreamRelease+0x36>
    rccDisableDMA1(false);
 8000e5c:	4a0d      	ldr	r2, [pc, #52]	; (8000e94 <dmaStreamRelease+0x64>)
 8000e5e:	6953      	ldr	r3, [r2, #20]
 8000e60:	f023 0301 	bic.w	r3, r3, #1
 8000e64:	6153      	str	r3, [r2, #20]
#if STM32_DMA2_NUM_CHANNELS > 0
  if ((dma_streams_mask & STM32_DMA2_STREAMS_MASK) == 0U) {
    rccDisableDMA2(false);
  }
#endif
}
 8000e66:	bcf0      	pop	{r4, r5, r6, r7}
 8000e68:	4770      	bx	lr
  /* Marks the stream as not allocated.*/
  dma_streams_mask &= ~(1U << dmastp->selfindex);

  /* Disables the associated IRQ vector if it is no more in use.*/
  if ((dma_streams_mask & dmastp->cmask) == 0U) {
    nvicDisableVector(dmastp->vector);
 8000e6a:	7c82      	ldrb	r2, [r0, #18]
 *
 * @param[in] n         the interrupt number
 */
void nvicDisableVector(uint32_t n) {

  NVIC->ICER[n >> 5U] = 1U << (n & 0x1FU);
 8000e6c:	4e0a      	ldr	r6, [pc, #40]	; (8000e98 <dmaStreamRelease+0x68>)
 8000e6e:	0954      	lsrs	r4, r2, #5
 8000e70:	f002 071f 	and.w	r7, r2, #31
#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = 0U;
 8000e74:	f102 4260 	add.w	r2, r2, #3758096384	; 0xe0000000
 8000e78:	f502 4261 	add.w	r2, r2, #57600	; 0xe100
 *
 * @param[in] n         the interrupt number
 */
void nvicDisableVector(uint32_t n) {

  NVIC->ICER[n >> 5U] = 1U << (n & 0x1FU);
 8000e7c:	3420      	adds	r4, #32
 8000e7e:	40bd      	lsls	r5, r7
 8000e80:	f846 5024 	str.w	r5, [r6, r4, lsl #2]
#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = 0U;
 8000e84:	f882 1300 	strb.w	r1, [r2, #768]	; 0x300
 8000e88:	7c42      	ldrb	r2, [r0, #17]
 8000e8a:	e7de      	b.n	8000e4a <dmaStreamRelease+0x1a>
 8000e8c:	200009f8 	.word	0x200009f8
 8000e90:	200009c0 	.word	0x200009c0
 8000e94:	40021000 	.word	0x40021000
 8000e98:	e000e100 	.word	0xe000e100
 8000e9c:	00000000 	.word	0x00000000

08000ea0 <gdisp_lld_fill_area>:
 8000ea0:	8bc3      	ldrh	r3, [r0, #30]
 8000ea2:	f043 0304 	orr.w	r3, r3, #4
 8000ea6:	83c3      	strh	r3, [r0, #30]
 8000ea8:	4770      	bx	lr
 8000eaa:	bf00      	nop
 8000eac:	0000      	movs	r0, r0
	...

08000eb0 <gdisp_lld_get_pixel_color>:

#if GDISP_HARDWARE_PIXELREAD
	LLDSPEC color_t gdisp_lld_get_pixel_color(GDisplay *g) {
		coord_t		x, y;

		switch(g->g.Orientation) {
 8000eb0:	8983      	ldrh	r3, [r0, #12]
 8000eb2:	2bb4      	cmp	r3, #180	; 0xb4
 8000eb4:	d023      	beq.n	8000efe <gdisp_lld_get_pixel_color+0x4e>
 8000eb6:	f5b3 7f87 	cmp.w	r3, #270	; 0x10e
 8000eba:	d019      	beq.n	8000ef0 <gdisp_lld_get_pixel_color+0x40>
 8000ebc:	2b5a      	cmp	r3, #90	; 0x5a
 8000ebe:	d010      	beq.n	8000ee2 <gdisp_lld_get_pixel_color+0x32>
		default:
		case GDISP_ROTATE_0:
			x = g->p.x;
 8000ec0:	f9b0 1020 	ldrsh.w	r1, [r0, #32]
			y = g->p.y;
 8000ec4:	f9b0 3022 	ldrsh.w	r3, [r0, #34]	; 0x22
		case GDISP_ROTATE_270:
			x = GDISP_SCREEN_WIDTH-1 - g->p.y;
			y = g->p.x;
			break;
		}
		return (RAM(g)[xyaddr(x, y)] & xybit(y)) ? White : Black;
 8000ec8:	6940      	ldr	r0, [r0, #20]
 8000eca:	10da      	asrs	r2, r3, #3
 8000ecc:	eb02 1242 	add.w	r2, r2, r2, lsl #5
 8000ed0:	eb00 0282 	add.w	r2, r0, r2, lsl #2
 8000ed4:	5c50      	ldrb	r0, [r2, r1]
 8000ed6:	f003 0307 	and.w	r3, r3, #7
 8000eda:	4118      	asrs	r0, r3
	}
 8000edc:	f000 0001 	and.w	r0, r0, #1
 8000ee0:	4770      	bx	lr
			x = g->p.x;
			y = g->p.y;
			break;
		case GDISP_ROTATE_90:
			x = g->p.y;
			y = GDISP_SCREEN_HEIGHT-1 - g->p.x;
 8000ee2:	8c03      	ldrh	r3, [r0, #32]
		case GDISP_ROTATE_0:
			x = g->p.x;
			y = g->p.y;
			break;
		case GDISP_ROTATE_90:
			x = g->p.y;
 8000ee4:	f9b0 1022 	ldrsh.w	r1, [r0, #34]	; 0x22
			y = GDISP_SCREEN_HEIGHT-1 - g->p.x;
 8000ee8:	f1c3 033f 	rsb	r3, r3, #63	; 0x3f
 8000eec:	b21b      	sxth	r3, r3
 8000eee:	e7eb      	b.n	8000ec8 <gdisp_lld_get_pixel_color+0x18>
		case GDISP_ROTATE_180:
			x = GDISP_SCREEN_WIDTH-1 - g->p.x;
			y = GDISP_SCREEN_HEIGHT-1 - g->p.y;
			break;
		case GDISP_ROTATE_270:
			x = GDISP_SCREEN_WIDTH-1 - g->p.y;
 8000ef0:	8c41      	ldrh	r1, [r0, #34]	; 0x22
			y = g->p.x;
 8000ef2:	f9b0 3020 	ldrsh.w	r3, [r0, #32]
		case GDISP_ROTATE_180:
			x = GDISP_SCREEN_WIDTH-1 - g->p.x;
			y = GDISP_SCREEN_HEIGHT-1 - g->p.y;
			break;
		case GDISP_ROTATE_270:
			x = GDISP_SCREEN_WIDTH-1 - g->p.y;
 8000ef6:	f1c1 0183 	rsb	r1, r1, #131	; 0x83
 8000efa:	b209      	sxth	r1, r1
 8000efc:	e7e4      	b.n	8000ec8 <gdisp_lld_get_pixel_color+0x18>
		case GDISP_ROTATE_90:
			x = g->p.y;
			y = GDISP_SCREEN_HEIGHT-1 - g->p.x;
			break;
		case GDISP_ROTATE_180:
			x = GDISP_SCREEN_WIDTH-1 - g->p.x;
 8000efe:	8c01      	ldrh	r1, [r0, #32]
			y = GDISP_SCREEN_HEIGHT-1 - g->p.y;
 8000f00:	8c43      	ldrh	r3, [r0, #34]	; 0x22
		case GDISP_ROTATE_90:
			x = g->p.y;
			y = GDISP_SCREEN_HEIGHT-1 - g->p.x;
			break;
		case GDISP_ROTATE_180:
			x = GDISP_SCREEN_WIDTH-1 - g->p.x;
 8000f02:	f1c1 0183 	rsb	r1, r1, #131	; 0x83
			y = GDISP_SCREEN_HEIGHT-1 - g->p.y;
 8000f06:	f1c3 033f 	rsb	r3, r3, #63	; 0x3f
		case GDISP_ROTATE_90:
			x = g->p.y;
			y = GDISP_SCREEN_HEIGHT-1 - g->p.x;
			break;
		case GDISP_ROTATE_180:
			x = GDISP_SCREEN_WIDTH-1 - g->p.x;
 8000f0a:	b209      	sxth	r1, r1
			y = GDISP_SCREEN_HEIGHT-1 - g->p.y;
 8000f0c:	b21b      	sxth	r3, r3
 8000f0e:	e7db      	b.n	8000ec8 <gdisp_lld_get_pixel_color+0x18>

08000f10 <gdisp_lld_draw_pixel>:
#if GDISP_HARDWARE_DRAWPIXEL
	LLDSPEC void gdisp_lld_draw_pixel(GDisplay *g) {
		coord_t x, y;
		
		#if GDISP_NEED_CONTROL
			switch(g->g.Orientation) {
 8000f10:	8983      	ldrh	r3, [r0, #12]
		g->flags &= ~GDISP_FLG_NEEDFLUSH;
	}
#endif

#if GDISP_HARDWARE_DRAWPIXEL
	LLDSPEC void gdisp_lld_draw_pixel(GDisplay *g) {
 8000f12:	b430      	push	{r4, r5}
		coord_t x, y;
		
		#if GDISP_NEED_CONTROL
			switch(g->g.Orientation) {
 8000f14:	2bb4      	cmp	r3, #180	; 0xb4
 8000f16:	d042      	beq.n	8000f9e <gdisp_lld_draw_pixel+0x8e>
 8000f18:	f5b3 7f87 	cmp.w	r3, #270	; 0x10e
 8000f1c:	d037      	beq.n	8000f8e <gdisp_lld_draw_pixel+0x7e>
 8000f1e:	2b5a      	cmp	r3, #90	; 0x5a
 8000f20:	d01b      	beq.n	8000f5a <gdisp_lld_draw_pixel+0x4a>
			default:
			case GDISP_ROTATE_0:
				x = g->p.x;
 8000f22:	f9b0 3020 	ldrsh.w	r3, [r0, #32]
				y = g->p.y;
 8000f26:	f9b0 2022 	ldrsh.w	r2, [r0, #34]	; 0x22
		#else
			x = g->p.x;
			y = g->p.y;
		#endif

		if (gdispColor2Native(g->p.color) != Black) {
 8000f2a:	f890 1030 	ldrb.w	r1, [r0, #48]	; 0x30
 8000f2e:	b9f9      	cbnz	r1, 8000f70 <gdisp_lld_draw_pixel+0x60>
			RAM(g)[xyaddr(x, y)] |= xybit(y);
		} else {
			RAM(g)[xyaddr(x, y)] &= ~xybit(y);
 8000f30:	10d1      	asrs	r1, r2, #3
 8000f32:	eb01 1141 	add.w	r1, r1, r1, lsl #5
 8000f36:	6945      	ldr	r5, [r0, #20]
 8000f38:	eb03 0381 	add.w	r3, r3, r1, lsl #2
 8000f3c:	5ce9      	ldrb	r1, [r5, r3]
 8000f3e:	f002 0207 	and.w	r2, r2, #7
 8000f42:	2401      	movs	r4, #1
 8000f44:	fa04 f202 	lsl.w	r2, r4, r2
 8000f48:	ea21 0202 	bic.w	r2, r1, r2
 8000f4c:	54ea      	strb	r2, [r5, r3]
		}

		g->flags |= GDISP_FLG_NEEDFLUSH;
 8000f4e:	8bc3      	ldrh	r3, [r0, #30]
	}
 8000f50:	bc30      	pop	{r4, r5}
			RAM(g)[xyaddr(x, y)] |= xybit(y);
		} else {
			RAM(g)[xyaddr(x, y)] &= ~xybit(y);
		}

		g->flags |= GDISP_FLG_NEEDFLUSH;
 8000f52:	f043 0304 	orr.w	r3, r3, #4
 8000f56:	83c3      	strh	r3, [r0, #30]
	}
 8000f58:	4770      	bx	lr
				x = g->p.x;
				y = g->p.y;
				break;
			case GDISP_ROTATE_90:
				x = g->p.y;
				y = g->g.Width - g->p.x - 1;
 8000f5a:	8903      	ldrh	r3, [r0, #8]
 8000f5c:	8c02      	ldrh	r2, [r0, #32]
 8000f5e:	3b01      	subs	r3, #1
		#else
			x = g->p.x;
			y = g->p.y;
		#endif

		if (gdispColor2Native(g->p.color) != Black) {
 8000f60:	f890 1030 	ldrb.w	r1, [r0, #48]	; 0x30
				x = g->p.x;
				y = g->p.y;
				break;
			case GDISP_ROTATE_90:
				x = g->p.y;
				y = g->g.Width - g->p.x - 1;
 8000f64:	1a9a      	subs	r2, r3, r2
 8000f66:	b212      	sxth	r2, r2
			case GDISP_ROTATE_0:
				x = g->p.x;
				y = g->p.y;
				break;
			case GDISP_ROTATE_90:
				x = g->p.y;
 8000f68:	f9b0 3022 	ldrsh.w	r3, [r0, #34]	; 0x22
		#else
			x = g->p.x;
			y = g->p.y;
		#endif

		if (gdispColor2Native(g->p.color) != Black) {
 8000f6c:	2900      	cmp	r1, #0
 8000f6e:	d0df      	beq.n	8000f30 <gdisp_lld_draw_pixel+0x20>
			RAM(g)[xyaddr(x, y)] |= xybit(y);
 8000f70:	10d1      	asrs	r1, r2, #3
 8000f72:	eb01 1141 	add.w	r1, r1, r1, lsl #5
 8000f76:	6945      	ldr	r5, [r0, #20]
 8000f78:	eb03 0381 	add.w	r3, r3, r1, lsl #2
 8000f7c:	5ce9      	ldrb	r1, [r5, r3]
 8000f7e:	f002 0207 	and.w	r2, r2, #7
 8000f82:	2401      	movs	r4, #1
 8000f84:	fa04 f202 	lsl.w	r2, r4, r2
 8000f88:	430a      	orrs	r2, r1
 8000f8a:	54ea      	strb	r2, [r5, r3]
 8000f8c:	e7df      	b.n	8000f4e <gdisp_lld_draw_pixel+0x3e>
			case GDISP_ROTATE_180:
				x = g->g.Width  - g->p.x - 1;
				y = g->g.Height - g->p.y - 1;
				break;
			case GDISP_ROTATE_270:
				x = g->g.Height - g->p.y - 1;
 8000f8e:	8943      	ldrh	r3, [r0, #10]
 8000f90:	8c42      	ldrh	r2, [r0, #34]	; 0x22
 8000f92:	3b01      	subs	r3, #1
 8000f94:	1a9b      	subs	r3, r3, r2
 8000f96:	b21b      	sxth	r3, r3
				y = g->p.x;
 8000f98:	f9b0 2020 	ldrsh.w	r2, [r0, #32]
 8000f9c:	e7c5      	b.n	8000f2a <gdisp_lld_draw_pixel+0x1a>
			case GDISP_ROTATE_90:
				x = g->p.y;
				y = g->g.Width - g->p.x - 1;
				break;
			case GDISP_ROTATE_180:
				x = g->g.Width  - g->p.x - 1;
 8000f9e:	8903      	ldrh	r3, [r0, #8]
				y = g->g.Height - g->p.y - 1;
 8000fa0:	8942      	ldrh	r2, [r0, #10]
			case GDISP_ROTATE_90:
				x = g->p.y;
				y = g->g.Width - g->p.x - 1;
				break;
			case GDISP_ROTATE_180:
				x = g->g.Width  - g->p.x - 1;
 8000fa2:	8c04      	ldrh	r4, [r0, #32]
				y = g->g.Height - g->p.y - 1;
 8000fa4:	8c41      	ldrh	r1, [r0, #34]	; 0x22
			case GDISP_ROTATE_90:
				x = g->p.y;
				y = g->g.Width - g->p.x - 1;
				break;
			case GDISP_ROTATE_180:
				x = g->g.Width  - g->p.x - 1;
 8000fa6:	3b01      	subs	r3, #1
				y = g->g.Height - g->p.y - 1;
 8000fa8:	3a01      	subs	r2, #1
			case GDISP_ROTATE_90:
				x = g->p.y;
				y = g->g.Width - g->p.x - 1;
				break;
			case GDISP_ROTATE_180:
				x = g->g.Width  - g->p.x - 1;
 8000faa:	1b1b      	subs	r3, r3, r4
				y = g->g.Height - g->p.y - 1;
 8000fac:	1a52      	subs	r2, r2, r1
			case GDISP_ROTATE_90:
				x = g->p.y;
				y = g->g.Width - g->p.x - 1;
				break;
			case GDISP_ROTATE_180:
				x = g->g.Width  - g->p.x - 1;
 8000fae:	b21b      	sxth	r3, r3
				y = g->g.Height - g->p.y - 1;
 8000fb0:	b212      	sxth	r2, r2
 8000fb2:	e7ba      	b.n	8000f2a <gdisp_lld_draw_pixel+0x1a>
	...

08000fc0 <mf_rlefont_character_width>:
    return width;
}

uint8_t mf_rlefont_character_width(const struct mf_font_s *font,
                                   uint16_t character)
{
 8000fc0:	b470      	push	{r4, r5, r6}
static const uint8_t *find_glyph(const struct mf_rlefont_s *font,
                                 uint16_t character)
{
   unsigned i, index;
   const struct mf_rlefont_char_range_s *range;
   for (i = 0; i < font->char_range_count; i++)
 8000fc2:	f890 602a 	ldrb.w	r6, [r0, #42]	; 0x2a
 8000fc6:	b1d6      	cbz	r6, 8000ffe <mf_rlefont_character_width+0x3e>
 8000fc8:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 8000fca:	2200      	movs	r2, #0
   {
       range = &font->char_ranges[i];
       index = character - range->first_char;
 8000fcc:	881c      	ldrh	r4, [r3, #0]
static const uint8_t *find_glyph(const struct mf_rlefont_s *font,
                                 uint16_t character)
{
   unsigned i, index;
   const struct mf_rlefont_char_range_s *range;
   for (i = 0; i < font->char_range_count; i++)
 8000fce:	3201      	adds	r2, #1
   {
       range = &font->char_ranges[i];
       index = character - range->first_char;
       if (character >= range->first_char && index < range->char_count)
 8000fd0:	42a1      	cmp	r1, r4
   unsigned i, index;
   const struct mf_rlefont_char_range_s *range;
   for (i = 0; i < font->char_range_count; i++)
   {
       range = &font->char_ranges[i];
       index = character - range->first_char;
 8000fd2:	eba1 0504 	sub.w	r5, r1, r4
       if (character >= range->first_char && index < range->char_count)
 8000fd6:	d302      	bcc.n	8000fde <mf_rlefont_character_width+0x1e>
 8000fd8:	8858      	ldrh	r0, [r3, #2]
 8000fda:	4285      	cmp	r5, r0
 8000fdc:	d306      	bcc.n	8000fec <mf_rlefont_character_width+0x2c>
static const uint8_t *find_glyph(const struct mf_rlefont_s *font,
                                 uint16_t character)
{
   unsigned i, index;
   const struct mf_rlefont_char_range_s *range;
   for (i = 0; i < font->char_range_count; i++)
 8000fde:	42b2      	cmp	r2, r6
 8000fe0:	f103 030c 	add.w	r3, r3, #12
 8000fe4:	d1f2      	bne.n	8000fcc <mf_rlefont_character_width+0xc>
                                   uint16_t character)
{
    const uint8_t *p;
    p = find_glyph((struct mf_rlefont_s*)font, character);
    if (!p)
        return 0;
 8000fe6:	2000      	movs	r0, #0
    
    return *p;
}
 8000fe8:	bc70      	pop	{r4, r5, r6}
 8000fea:	4770      	bx	lr
   {
       range = &font->char_ranges[i];
       index = character - range->first_char;
       if (character >= range->first_char && index < range->char_count)
       {
           uint16_t offset = range->glyph_offsets[index];
 8000fec:	6859      	ldr	r1, [r3, #4]
           return &range->glyph_data[offset];
 8000fee:	689a      	ldr	r2, [r3, #8]
 8000ff0:	f831 3015 	ldrh.w	r3, [r1, r5, lsl #1]
uint8_t mf_rlefont_character_width(const struct mf_font_s *font,
                                   uint16_t character)
{
    const uint8_t *p;
    p = find_glyph((struct mf_rlefont_s*)font, character);
    if (!p)
 8000ff4:	18d0      	adds	r0, r2, r3
 8000ff6:	d0f7      	beq.n	8000fe8 <mf_rlefont_character_width+0x28>
        return 0;
    
    return *p;
}
 8000ff8:	bc70      	pop	{r4, r5, r6}
    const uint8_t *p;
    p = find_glyph((struct mf_rlefont_s*)font, character);
    if (!p)
        return 0;
    
    return *p;
 8000ffa:	5cd0      	ldrb	r0, [r2, r3]
}
 8000ffc:	4770      	bx	lr
                                   uint16_t character)
{
    const uint8_t *p;
    p = find_glyph((struct mf_rlefont_s*)font, character);
    if (!p)
        return 0;
 8000ffe:	4630      	mov	r0, r6
 8001000:	e7f2      	b.n	8000fe8 <mf_rlefont_character_width+0x28>
 8001002:	bf00      	nop
	...

08001010 <menu_down>:
	}
	if((ms->DRAW_AUTO) && draw) menu_draw(ms);
}

void menu_down(menu_state * ms)
{
 8001010:	b410      	push	{r4}
	if(ms->top != ms->current_menu->count_items) {
 8001012:	68c3      	ldr	r3, [r0, #12]
 8001014:	7a01      	ldrb	r1, [r0, #8]
 8001016:	7c1a      	ldrb	r2, [r3, #16]
 8001018:	4291      	cmp	r1, r2
 800101a:	d00d      	beq.n	8001038 <menu_down+0x28>
		if(ms->current_item != (ms->current_menu->count_items-1)) {
 800101c:	7a83      	ldrb	r3, [r0, #10]
 800101e:	3a01      	subs	r2, #1
 8001020:	4293      	cmp	r3, r2
 8001022:	d009      	beq.n	8001038 <menu_down+0x28>
			ms->current_item += 1;
 8001024:	3301      	adds	r3, #1
 8001026:	b2db      	uxtb	r3, r3
			if(((ms->current_item) - (ms->top)) == ms->MAX_ROWS) {
 8001028:	7802      	ldrb	r2, [r0, #0]
 800102a:	1a5c      	subs	r4, r3, r1
 800102c:	4294      	cmp	r4, r2
				ms->top += 1;
 800102e:	bf08      	it	eq
 8001030:	3101      	addeq	r1, #1

void menu_down(menu_state * ms)
{
	if(ms->top != ms->current_menu->count_items) {
		if(ms->current_item != (ms->current_menu->count_items-1)) {
			ms->current_item += 1;
 8001032:	7283      	strb	r3, [r0, #10]
			if(((ms->current_item) - (ms->top)) == ms->MAX_ROWS) {
				ms->top += 1;
 8001034:	bf08      	it	eq
 8001036:	7201      	strbeq	r1, [r0, #8]
			}
		}
	}
	if(ms->DRAW_AUTO) menu_draw(ms);
 8001038:	7843      	ldrb	r3, [r0, #1]
 800103a:	b90b      	cbnz	r3, 8001040 <menu_down+0x30>
}
 800103c:	bc10      	pop	{r4}
 800103e:	4770      	bx	lr
 8001040:	bc10      	pop	{r4}
			if(((ms->current_item) - (ms->top)) == ms->MAX_ROWS) {
				ms->top += 1;
			}
		}
	}
	if(ms->DRAW_AUTO) menu_draw(ms);
 8001042:	f001 ba65 	b.w	8002510 <menu_draw>
 8001046:	bf00      	nop
	...

08001050 <gdisp_lld_control>:
		return (RAM(g)[xyaddr(x, y)] & xybit(y)) ? White : Black;
	}
#endif

#if GDISP_NEED_CONTROL && GDISP_HARDWARE_CONTROL
	LLDSPEC void gdisp_lld_control(GDisplay *g) {
 8001050:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
		switch(g->p.x) {
 8001054:	f9b0 3020 	ldrsh.w	r3, [r0, #32]
		return (RAM(g)[xyaddr(x, y)] & xybit(y)) ? White : Black;
	}
#endif

#if GDISP_NEED_CONTROL && GDISP_HARDWARE_CONTROL
	LLDSPEC void gdisp_lld_control(GDisplay *g) {
 8001058:	b083      	sub	sp, #12
 800105a:	4604      	mov	r4, r0
		switch(g->p.x) {
 800105c:	2b03      	cmp	r3, #3
 800105e:	d840      	bhi.n	80010e2 <gdisp_lld_control+0x92>
 8001060:	e8df f003 	tbb	[pc, r3]
 8001064:	42869102 	.word	0x42869102
		case GDISP_CONTROL_POWER:
			if (g->g.Powermode == (powermode_t)g->p.ptr)
 8001068:	7b82      	ldrb	r2, [r0, #14]
 800106a:	f890 3034 	ldrb.w	r3, [r0, #52]	; 0x34
 800106e:	429a      	cmp	r2, r3
 8001070:	d037      	beq.n	80010e2 <gdisp_lld_control+0x92>
				return;
			switch((powermode_t)g->p.ptr) {
 8001072:	2b02      	cmp	r3, #2
 8001074:	f340 809d 	ble.w	80011b2 <gdisp_lld_control+0x162>
 8001078:	2b03      	cmp	r3, #3
 800107a:	d132      	bne.n	80010e2 <gdisp_lld_control+0x92>
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 800107c:	4b5e      	ldr	r3, [pc, #376]	; (80011f8 <gdisp_lld_control+0x1a8>)
}

static GFXINLINE void acquire_bus(GDisplay *g) {
	(void) g;
	#if GFX_USE_OS_CHIBIOS
		thdPriority = (int32_t)chThdGetPriorityX();
 800107e:	4f5f      	ldr	r7, [pc, #380]	; (80011fc <gdisp_lld_control+0x1ac>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->prio;
 8001080:	699b      	ldr	r3, [r3, #24]
		chThdSetPriority(HIGHPRIO);
 8001082:	20ff      	movs	r0, #255	; 0xff
}

static GFXINLINE void acquire_bus(GDisplay *g) {
	(void) g;
	#if GFX_USE_OS_CHIBIOS
		thdPriority = (int32_t)chThdGetPriorityX();
 8001084:	689b      	ldr	r3, [r3, #8]
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8001086:	f04f 0920 	mov.w	r9, #32
 800108a:	603b      	str	r3, [r7, #0]
		chThdSetPriority(HIGHPRIO);
 800108c:	f000 fcb8 	bl	8001a00 <chThdSetPriority>
 8001090:	f389 8811 	msr	BASEPRI, r9
 * @api
 */
void chMtxLock(mutex_t *mp) {

  chSysLock();
  chMtxLockS(mp);
 8001094:	4d5a      	ldr	r5, [pc, #360]	; (8001200 <gdisp_lld_control+0x1b0>)
 8001096:	f04f 0800 	mov.w	r8, #0
 800109a:	4628      	mov	r0, r5
 800109c:	f000 fdc8 	bl	8001c30 <chMtxLockS>
 80010a0:	f388 8811 	msr	BASEPRI, r8

static GFXINLINE void write_cmd(GDisplay *g, uint8_t cmd) {
	(void) g;

	uint8_t command[1];
	command[0] = cmd;
 80010a4:	23af      	movs	r3, #175	; 0xaf
 80010a6:	ae02      	add	r6, sp, #8
 80010a8:	f806 3d04 	strb.w	r3, [r6, #-4]!
 80010ac:	f389 8811 	msr	BASEPRI, r9
  osalDbgCheck((i2cp != NULL) && (config != NULL));
  osalDbgAssert((i2cp->state == I2C_STOP) || (i2cp->state == I2C_READY) ||
                (i2cp->state == I2C_LOCKED), "invalid state");

  osalSysLock();
  i2cp->config = config;
 80010b0:	4b54      	ldr	r3, [pc, #336]	; (8001204 <gdisp_lld_control+0x1b4>)
 80010b2:	f845 3c08 	str.w	r3, [r5, #-8]
  i2c_lld_start(i2cp);
 80010b6:	f001 f88b 	bl	80021d0 <i2c_lld_start.constprop.24>
  i2cp->state = I2C_READY;
 80010ba:	2302      	movs	r3, #2
 80010bc:	f805 3c0c 	strb.w	r3, [r5, #-12]
 80010c0:	f388 8811 	msr	BASEPRI, r8

	i2cStart(&I2CD1, &i2cconfig);
	i2cMasterTransmitTimeout(&I2CD1, UC1601s_I2C_ADDRESS_COMMAND, command, 1, 0, 0, MS2ST(10));
 80010c4:	2201      	movs	r2, #1
 80010c6:	4631      	mov	r1, r6
 80010c8:	2038      	movs	r0, #56	; 0x38
 80010ca:	f001 f981 	bl	80023d0 <i2cMasterTransmitTimeout.constprop.18>
	i2cStop(&I2CD1);
 80010ce:	f001 f92f 	bl	8002330 <i2cStop.constprop.20>
}

static GFXINLINE void release_bus(GDisplay *g) {
	(void) g;
	#if GFX_USE_OS_CHIBIOS
		chThdSetPriority(thdPriority);
 80010d2:	6838      	ldr	r0, [r7, #0]
 80010d4:	f000 fc94 	bl	8001a00 <chThdSetPriority>
 * @api
 */
static inline void osalMutexUnlock(mutex_t *mp) {

#if CH_CFG_USE_MUTEXES
  chMtxUnlock(mp);
 80010d8:	4628      	mov	r0, r5
 80010da:	f000 fd71 	bl	8001bc0 <chMtxUnlock>
					release_bus(g);
					break;
				default:
					return;
			}
			g->g.Powermode = (powermode_t)g->p.ptr;
 80010de:	6b63      	ldr	r3, [r4, #52]	; 0x34
 80010e0:	73a3      	strb	r3, [r4, #14]
			write_cmd2(g, UC1601s_SET_BIAS, (uint8_t)(((((unsigned)g->p.ptr) << 8) - 1) / 100));
			release_bus(g);
			g->g.Contrast = (unsigned)g->p.ptr;
			return;
		}
	}
 80010e2:	b003      	add	sp, #12
 80010e4:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
			set_backlight(g, (unsigned)g->p.ptr);
			g->g.Backlight = (unsigned)g->p.ptr;
			return;

		case GDISP_CONTROL_CONTRAST:
			if ((unsigned)g->p.ptr > 100) g->p.ptr = (void *)100;
 80010e8:	6b43      	ldr	r3, [r0, #52]	; 0x34
}

static GFXINLINE void acquire_bus(GDisplay *g) {
	(void) g;
	#if GFX_USE_OS_CHIBIOS
		thdPriority = (int32_t)chThdGetPriorityX();
 80010ea:	f8df 8110 	ldr.w	r8, [pc, #272]	; 80011fc <gdisp_lld_control+0x1ac>
 80010ee:	2b64      	cmp	r3, #100	; 0x64
 80010f0:	bf84      	itt	hi
 80010f2:	2364      	movhi	r3, #100	; 0x64
 80010f4:	6343      	strhi	r3, [r0, #52]	; 0x34
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 80010f6:	4b40      	ldr	r3, [pc, #256]	; (80011f8 <gdisp_lld_control+0x1a8>)
		chThdSetPriority(HIGHPRIO);
 80010f8:	20ff      	movs	r0, #255	; 0xff
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->prio;
 80010fa:	699b      	ldr	r3, [r3, #24]
 80010fc:	2720      	movs	r7, #32
}

static GFXINLINE void acquire_bus(GDisplay *g) {
	(void) g;
	#if GFX_USE_OS_CHIBIOS
		thdPriority = (int32_t)chThdGetPriorityX();
 80010fe:	689b      	ldr	r3, [r3, #8]
 8001100:	f8c8 3000 	str.w	r3, [r8]
		chThdSetPriority(HIGHPRIO);
 8001104:	f000 fc7c 	bl	8001a00 <chThdSetPriority>
 8001108:	f387 8811 	msr	BASEPRI, r7
 800110c:	4d3c      	ldr	r5, [pc, #240]	; (8001200 <gdisp_lld_control+0x1b0>)
 800110e:	2600      	movs	r6, #0
 8001110:	4628      	mov	r0, r5
 8001112:	f000 fd8d 	bl	8001c30 <chMtxLockS>
 8001116:	f386 8811 	msr	BASEPRI, r6
			acquire_bus(g);
			write_cmd2(g, UC1601s_SET_BIAS, (uint8_t)(((((unsigned)g->p.ptr) << 8) - 1) / 100));
 800111a:	6b63      	ldr	r3, [r4, #52]	; 0x34
 800111c:	4a3a      	ldr	r2, [pc, #232]	; (8001208 <gdisp_lld_control+0x1b8>)
 800111e:	021b      	lsls	r3, r3, #8
 8001120:	3b01      	subs	r3, #1
 8001122:	fba2 2303 	umull	r2, r3, r2, r3

static GFXINLINE void write_cmd2(GDisplay *g, uint8_t cmd1, uint8_t cmd2) {
	(void) g;

	uint8_t command[2];
	command[0] = cmd1;
 8001126:	2281      	movs	r2, #129	; 0x81
 8001128:	f3c3 1347 	ubfx	r3, r3, #5, #8
 800112c:	f88d 2004 	strb.w	r2, [sp, #4]
	command[1] = cmd2;
 8001130:	f88d 3005 	strb.w	r3, [sp, #5]
 8001134:	f387 8811 	msr	BASEPRI, r7
  osalDbgCheck((i2cp != NULL) && (config != NULL));
  osalDbgAssert((i2cp->state == I2C_STOP) || (i2cp->state == I2C_READY) ||
                (i2cp->state == I2C_LOCKED), "invalid state");

  osalSysLock();
  i2cp->config = config;
 8001138:	4b32      	ldr	r3, [pc, #200]	; (8001204 <gdisp_lld_control+0x1b4>)
 800113a:	f845 3c08 	str.w	r3, [r5, #-8]
  i2c_lld_start(i2cp);
 800113e:	f001 f847 	bl	80021d0 <i2c_lld_start.constprop.24>
  i2cp->state = I2C_READY;
 8001142:	2202      	movs	r2, #2
 8001144:	f805 2c0c 	strb.w	r2, [r5, #-12]
 8001148:	f386 8811 	msr	BASEPRI, r6

	i2cStart(&I2CD1, &i2cconfig);
	i2cMasterTransmitTimeout(&I2CD1, UC1601s_I2C_ADDRESS_COMMAND, command, 2, 0, 0, MS2ST(10));
 800114c:	2038      	movs	r0, #56	; 0x38
 800114e:	a901      	add	r1, sp, #4
 8001150:	f001 f93e 	bl	80023d0 <i2cMasterTransmitTimeout.constprop.18>
	i2cStop(&I2CD1);
 8001154:	f001 f8ec 	bl	8002330 <i2cStop.constprop.20>
}

static GFXINLINE void release_bus(GDisplay *g) {
	(void) g;
	#if GFX_USE_OS_CHIBIOS
		chThdSetPriority(thdPriority);
 8001158:	f8d8 0000 	ldr.w	r0, [r8]
 800115c:	f000 fc50 	bl	8001a00 <chThdSetPriority>
 8001160:	4628      	mov	r0, r5
 8001162:	f000 fd2d 	bl	8001bc0 <chMtxUnlock>
			release_bus(g);
			g->g.Contrast = (unsigned)g->p.ptr;
 8001166:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8001168:	7423      	strb	r3, [r4, #16]
			return;
		}
	}
 800116a:	b003      	add	sp, #12
 800116c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
			}
			g->g.Orientation = (orientation_t)g->p.ptr;
			return;

		case GDISP_CONTROL_BACKLIGHT:
			if ((unsigned)g->p.ptr > 100) g->p.ptr = (void *)100;
 8001170:	6b43      	ldr	r3, [r0, #52]	; 0x34
 8001172:	2b64      	cmp	r3, #100	; 0x64
 8001174:	bf85      	ittet	hi
 8001176:	2264      	movhi	r2, #100	; 0x64
 8001178:	4613      	movhi	r3, r2
 800117a:	b2db      	uxtbls	r3, r3
 800117c:	6342      	strhi	r2, [r0, #52]	; 0x34
			set_backlight(g, (unsigned)g->p.ptr);
			g->g.Backlight = (unsigned)g->p.ptr;
 800117e:	73c3      	strb	r3, [r0, #15]
			write_cmd2(g, UC1601s_SET_BIAS, (uint8_t)(((((unsigned)g->p.ptr) << 8) - 1) / 100));
			release_bus(g);
			g->g.Contrast = (unsigned)g->p.ptr;
			return;
		}
	}
 8001180:	b003      	add	sp, #12
 8001182:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
			}
			g->g.Powermode = (powermode_t)g->p.ptr;
			return;

		case GDISP_CONTROL_ORIENTATION:
			if (g->g.Orientation == (orientation_t)g->p.ptr)
 8001186:	8982      	ldrh	r2, [r0, #12]
 8001188:	8e83      	ldrh	r3, [r0, #52]	; 0x34
 800118a:	429a      	cmp	r2, r3
 800118c:	d0a9      	beq.n	80010e2 <gdisp_lld_control+0x92>
				return;
			switch((orientation_t)g->p.ptr) {
 800118e:	2b5a      	cmp	r3, #90	; 0x5a
 8001190:	d005      	beq.n	800119e <gdisp_lld_control+0x14e>
 8001192:	dd25      	ble.n	80011e0 <gdisp_lld_control+0x190>
 8001194:	2bb4      	cmp	r3, #180	; 0xb4
 8001196:	d026      	beq.n	80011e6 <gdisp_lld_control+0x196>
 8001198:	f5b3 7f87 	cmp.w	r3, #270	; 0x10e
 800119c:	d1a1      	bne.n	80010e2 <gdisp_lld_control+0x92>
						g->g.Height = tmp;
					}
					break;
				case GDISP_ROTATE_90:
				case GDISP_ROTATE_270:
					if (g->g.Orientation == GDISP_ROTATE_0 || g->g.Orientation == GDISP_ROTATE_180) {
 800119e:	bb42      	cbnz	r2, 80011f2 <gdisp_lld_control+0x1a2>
				case GDISP_ROTATE_0:
				case GDISP_ROTATE_180:
					if (g->g.Orientation == GDISP_ROTATE_90 || g->g.Orientation == GDISP_ROTATE_270) {
						coord_t		tmp;

						tmp = g->g.Width;
 80011a0:	f9b4 1008 	ldrsh.w	r1, [r4, #8]
						g->g.Width = g->g.Height;
 80011a4:	8962      	ldrh	r2, [r4, #10]
						g->g.Height = tmp;
 80011a6:	8161      	strh	r1, [r4, #10]
				case GDISP_ROTATE_180:
					if (g->g.Orientation == GDISP_ROTATE_90 || g->g.Orientation == GDISP_ROTATE_270) {
						coord_t		tmp;

						tmp = g->g.Width;
						g->g.Width = g->g.Height;
 80011a8:	8122      	strh	r2, [r4, #8]
					}
					break;
				default:
					return;
			}
			g->g.Orientation = (orientation_t)g->p.ptr;
 80011aa:	81a3      	strh	r3, [r4, #12]
			write_cmd2(g, UC1601s_SET_BIAS, (uint8_t)(((((unsigned)g->p.ptr) << 8) - 1) / 100));
			release_bus(g);
			g->g.Contrast = (unsigned)g->p.ptr;
			return;
		}
	}
 80011ac:	b003      	add	sp, #12
 80011ae:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 80011b2:	4b11      	ldr	r3, [pc, #68]	; (80011f8 <gdisp_lld_control+0x1a8>)
}

static GFXINLINE void acquire_bus(GDisplay *g) {
	(void) g;
	#if GFX_USE_OS_CHIBIOS
		thdPriority = (int32_t)chThdGetPriorityX();
 80011b4:	4f11      	ldr	r7, [pc, #68]	; (80011fc <gdisp_lld_control+0x1ac>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->prio;
 80011b6:	699b      	ldr	r3, [r3, #24]
		chThdSetPriority(HIGHPRIO);
 80011b8:	20ff      	movs	r0, #255	; 0xff
}

static GFXINLINE void acquire_bus(GDisplay *g) {
	(void) g;
	#if GFX_USE_OS_CHIBIOS
		thdPriority = (int32_t)chThdGetPriorityX();
 80011ba:	689b      	ldr	r3, [r3, #8]
 80011bc:	f04f 0920 	mov.w	r9, #32
 80011c0:	603b      	str	r3, [r7, #0]
		chThdSetPriority(HIGHPRIO);
 80011c2:	f000 fc1d 	bl	8001a00 <chThdSetPriority>
 80011c6:	f389 8811 	msr	BASEPRI, r9
 80011ca:	4d0d      	ldr	r5, [pc, #52]	; (8001200 <gdisp_lld_control+0x1b0>)
 80011cc:	f04f 0800 	mov.w	r8, #0
 80011d0:	4628      	mov	r0, r5
 80011d2:	f000 fd2d 	bl	8001c30 <chMtxLockS>
 80011d6:	f388 8811 	msr	BASEPRI, r8

static GFXINLINE void write_cmd(GDisplay *g, uint8_t cmd) {
	(void) g;

	uint8_t command[1];
	command[0] = cmd;
 80011da:	23ae      	movs	r3, #174	; 0xae
 80011dc:	ae02      	add	r6, sp, #8
 80011de:	e763      	b.n	80010a8 <gdisp_lld_control+0x58>
			return;

		case GDISP_CONTROL_ORIENTATION:
			if (g->g.Orientation == (orientation_t)g->p.ptr)
				return;
			switch((orientation_t)g->p.ptr) {
 80011e0:	2b00      	cmp	r3, #0
 80011e2:	f47f af7e 	bne.w	80010e2 <gdisp_lld_control+0x92>
				case GDISP_ROTATE_0:
				case GDISP_ROTATE_180:
					if (g->g.Orientation == GDISP_ROTATE_90 || g->g.Orientation == GDISP_ROTATE_270) {
 80011e6:	2a5a      	cmp	r2, #90	; 0x5a
 80011e8:	d0da      	beq.n	80011a0 <gdisp_lld_control+0x150>
 80011ea:	f5b2 7f87 	cmp.w	r2, #270	; 0x10e
 80011ee:	d1dc      	bne.n	80011aa <gdisp_lld_control+0x15a>
 80011f0:	e7d6      	b.n	80011a0 <gdisp_lld_control+0x150>
						g->g.Height = tmp;
					}
					break;
				case GDISP_ROTATE_90:
				case GDISP_ROTATE_270:
					if (g->g.Orientation == GDISP_ROTATE_0 || g->g.Orientation == GDISP_ROTATE_180) {
 80011f2:	2ab4      	cmp	r2, #180	; 0xb4
 80011f4:	d1d9      	bne.n	80011aa <gdisp_lld_control+0x15a>
 80011f6:	e7d3      	b.n	80011a0 <gdisp_lld_control+0x150>
 80011f8:	20000918 	.word	0x20000918
 80011fc:	20000800 	.word	0x20000800
 8001200:	20000a10 	.word	0x20000a10
 8001204:	080028e4 	.word	0x080028e4
 8001208:	51eb851f 	.word	0x51eb851f
 800120c:	00000000 	.word	0x00000000

08001210 <gdisp_lld_flush>:

#if GDISP_HARDWARE_FLUSH
	LLDSPEC void gdisp_lld_flush(GDisplay *g) {

		// Don't flush if we don't need it.
		if (!(g->flags & GDISP_FLG_NEEDFLUSH)) {
 8001210:	8bc3      	ldrh	r3, [r0, #30]
 8001212:	075b      	lsls	r3, r3, #29
 8001214:	d400      	bmi.n	8001218 <gdisp_lld_flush+0x8>
 8001216:	4770      	bx	lr
	g->g.Contrast = GDISP_INITIAL_CONTRAST;
	return TRUE;
}

#if GDISP_HARDWARE_FLUSH
	LLDSPEC void gdisp_lld_flush(GDisplay *g) {
 8001218:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 800121c:	4b2b      	ldr	r3, [pc, #172]	; (80012cc <gdisp_lld_flush+0xbc>)
}

static GFXINLINE void acquire_bus(GDisplay *g) {
	(void) g;
	#if GFX_USE_OS_CHIBIOS
		thdPriority = (int32_t)chThdGetPriorityX();
 800121e:	f8df 80b4 	ldr.w	r8, [pc, #180]	; 80012d4 <gdisp_lld_flush+0xc4>
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->prio;
 8001222:	699b      	ldr	r3, [r3, #24]
 8001224:	b085      	sub	sp, #20
 8001226:	689b      	ldr	r3, [r3, #8]
 8001228:	4604      	mov	r4, r0
		chThdSetPriority(HIGHPRIO);
 800122a:	20ff      	movs	r0, #255	; 0xff
}

static GFXINLINE void acquire_bus(GDisplay *g) {
	(void) g;
	#if GFX_USE_OS_CHIBIOS
		thdPriority = (int32_t)chThdGetPriorityX();
 800122c:	f8c8 3000 	str.w	r3, [r8]
 8001230:	2720      	movs	r7, #32
		chThdSetPriority(HIGHPRIO);
 8001232:	f000 fbe5 	bl	8001a00 <chThdSetPriority>
 8001236:	f387 8811 	msr	BASEPRI, r7
 800123a:	4d25      	ldr	r5, [pc, #148]	; (80012d0 <gdisp_lld_flush+0xc0>)
 800123c:	2600      	movs	r6, #0
 800123e:	4628      	mov	r0, r5
 8001240:	f000 fcf6 	bl	8001c30 <chMtxLockS>
 8001244:	f386 8811 	msr	BASEPRI, r6

static GFXINLINE void write_cmd3(GDisplay *g, uint8_t cmd1, uint8_t cmd2, uint8_t cmd3) {
	(void) g;

	uint8_t command[3];
	command[0] = cmd1;
 8001248:	22b0      	movs	r2, #176	; 0xb0
	command[1] = cmd2;
	command[2] = cmd3;
 800124a:	2310      	movs	r3, #16
static GFXINLINE void write_cmd3(GDisplay *g, uint8_t cmd1, uint8_t cmd2, uint8_t cmd3) {
	(void) g;

	uint8_t command[3];
	command[0] = cmd1;
	command[1] = cmd2;
 800124c:	f88d 600d 	strb.w	r6, [sp, #13]

static GFXINLINE void write_cmd3(GDisplay *g, uint8_t cmd1, uint8_t cmd2, uint8_t cmd3) {
	(void) g;

	uint8_t command[3];
	command[0] = cmd1;
 8001250:	f88d 200c 	strb.w	r2, [sp, #12]
	command[1] = cmd2;
	command[2] = cmd3;
 8001254:	f88d 300e 	strb.w	r3, [sp, #14]
 8001258:	f387 8811 	msr	BASEPRI, r7
  osalDbgCheck((i2cp != NULL) && (config != NULL));
  osalDbgAssert((i2cp->state == I2C_STOP) || (i2cp->state == I2C_READY) ||
                (i2cp->state == I2C_LOCKED), "invalid state");

  osalSysLock();
  i2cp->config = config;
 800125c:	f8df b078 	ldr.w	fp, [pc, #120]	; 80012d8 <gdisp_lld_flush+0xc8>
 8001260:	f1a5 0a0c 	sub.w	sl, r5, #12
  i2c_lld_start(i2cp);
  i2cp->state = I2C_READY;
 8001264:	f04f 0902 	mov.w	r9, #2
  osalDbgCheck((i2cp != NULL) && (config != NULL));
  osalDbgAssert((i2cp->state == I2C_STOP) || (i2cp->state == I2C_READY) ||
                (i2cp->state == I2C_LOCKED), "invalid state");

  osalSysLock();
  i2cp->config = config;
 8001268:	f8ca b004 	str.w	fp, [sl, #4]
  i2c_lld_start(i2cp);
 800126c:	f000 ffb0 	bl	80021d0 <i2c_lld_start.constprop.24>
  i2cp->state = I2C_READY;
 8001270:	f805 9c0c 	strb.w	r9, [r5, #-12]
 8001274:	f386 8811 	msr	BASEPRI, r6

	i2cStart(&I2CD1, &i2cconfig);
	i2cMasterTransmitTimeout(&I2CD1, UC1601s_I2C_ADDRESS_COMMAND, command, 3, 0, 0, MS2ST(10));
 8001278:	2203      	movs	r2, #3
 800127a:	a903      	add	r1, sp, #12
 800127c:	2038      	movs	r0, #56	; 0x38
 800127e:	f001 f8a7 	bl	80023d0 <i2cMasterTransmitTimeout.constprop.18>
	i2cStop(&I2CD1);
 8001282:	f001 f855 	bl	8002330 <i2cStop.constprop.20>

		acquire_bus(g);

        write_cmd3(g, UC1601s_SET_PAGE  | 0, UC1601s_SET_COL_L | 0, UC1601s_SET_COL_H | 0); // Y, XL, XH

		write_data(g, RAM(g), GDISP_MATRIX_BYTES);
 8001286:	6961      	ldr	r1, [r4, #20]
 8001288:	9101      	str	r1, [sp, #4]
 800128a:	f387 8811 	msr	BASEPRI, r7
  osalDbgCheck((i2cp != NULL) && (config != NULL));
  osalDbgAssert((i2cp->state == I2C_STOP) || (i2cp->state == I2C_READY) ||
                (i2cp->state == I2C_LOCKED), "invalid state");

  osalSysLock();
  i2cp->config = config;
 800128e:	f8ca b004 	str.w	fp, [sl, #4]
  i2c_lld_start(i2cp);
 8001292:	f000 ff9d 	bl	80021d0 <i2c_lld_start.constprop.24>
  i2cp->state = I2C_READY;
 8001296:	f805 9c0c 	strb.w	r9, [r5, #-12]
 800129a:	f386 8811 	msr	BASEPRI, r6

static GFXINLINE void write_data(GDisplay *g, uint8_t* data, uint16_t length) {
	(void) g;

	i2cStart(&I2CD1, &i2cconfig);
	i2cMasterTransmitTimeout(&I2CD1, UC1601s_I2C_ADDRESS_DATA, data, length, 0, 0, MS2ST(10));
 800129e:	f44f 6286 	mov.w	r2, #1072	; 0x430
 80012a2:	9901      	ldr	r1, [sp, #4]
 80012a4:	2039      	movs	r0, #57	; 0x39
 80012a6:	f001 f893 	bl	80023d0 <i2cMasterTransmitTimeout.constprop.18>
	i2cStop(&I2CD1);
 80012aa:	f001 f841 	bl	8002330 <i2cStop.constprop.20>
}

static GFXINLINE void release_bus(GDisplay *g) {
	(void) g;
	#if GFX_USE_OS_CHIBIOS
		chThdSetPriority(thdPriority);
 80012ae:	f8d8 0000 	ldr.w	r0, [r8]
 80012b2:	f000 fba5 	bl	8001a00 <chThdSetPriority>
 80012b6:	4628      	mov	r0, r5
 80012b8:	f000 fc82 	bl	8001bc0 <chMtxUnlock>

		release_bus(g);

		g->flags &= ~GDISP_FLG_NEEDFLUSH;
 80012bc:	8be3      	ldrh	r3, [r4, #30]
 80012be:	f023 0304 	bic.w	r3, r3, #4
 80012c2:	83e3      	strh	r3, [r4, #30]
	}
 80012c4:	b005      	add	sp, #20
 80012c6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80012ca:	bf00      	nop
 80012cc:	20000918 	.word	0x20000918
 80012d0:	20000a10 	.word	0x20000a10
 80012d4:	20000800 	.word	0x20000800
 80012d8:	080028e4 	.word	0x080028e4
 80012dc:	00000000 	.word	0x00000000

080012e0 <gdisp_lld_init>:

/*===========================================================================*/
/* Driver exported functions.                                                */
/*===========================================================================*/

LLDSPEC bool_t gdisp_lld_init(GDisplay *g) {
 80012e0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80012e4:	4604      	mov	r4, r0
 80012e6:	b085      	sub	sp, #20
 *
 * @api
 */
static inline void *chHeapAlloc(memory_heap_t *heapp, size_t size) {

  return chHeapAllocAligned(heapp, size, CH_HEAP_ALIGNMENT);
 80012e8:	f44f 6086 	mov.w	r0, #1072	; 0x430
 80012ec:	f000 fef8 	bl	80020e0 <chHeapAllocAligned.constprop.27>
    
	// The private area is the display surface.
	if (!(g->priv = gfxAlloc(GDISP_MATRIX_BYTES)))
 80012f0:	6160      	str	r0, [r4, #20]
 80012f2:	2800      	cmp	r0, #0
 80012f4:	f000 809d 	beq.w	8001432 <gdisp_lld_init+0x152>
 80012f8:	7f63      	ldrb	r3, [r4, #29]
#endif

static GFXINLINE void init_board(GDisplay *g) {

	// As we are not using multiple displays we set g->board to NULL as we don't use it.
	g->board = 0;
 80012fa:	2200      	movs	r2, #0
 80012fc:	61a2      	str	r2, [r4, #24]

	switch(g->controllerdisplay) {
 80012fe:	b96b      	cbnz	r3, 800131c <gdisp_lld_init+0x3c>
	case 0:											// Set up for Display 0
		// RESET pin.
		palSetPadMode(UC1601s_RESET_PORT, UC1601s_RESET_PIN, PAL_MODE_OUTPUT_PUSHPULL);
 8001300:	2106      	movs	r1, #6
 8001302:	2020      	movs	r0, #32
 8001304:	f001 f8cc 	bl	80024a0 <_pal_lld_setgroupmode.constprop.15>
		 * 0x00901D2B;		// 100kHz Standard Mode
		 * 0x00300444;		// 100kHz Fast Mode
		 * 0x0030020A;		// 400kHz Fast Mode
		 * 0x00100002;		// 800kHz Fast Mode +
		 */
		palSetPadMode(UC1601s_SCL_PORT, UC1601s_SCL_PIN, PAL_MODE_STM32_ALTERNATE_OPENDRAIN );
 8001308:	2111      	movs	r1, #17
 800130a:	2040      	movs	r0, #64	; 0x40
 800130c:	f001 f8c8 	bl	80024a0 <_pal_lld_setgroupmode.constprop.15>
		palSetPadMode(UC1601s_SDA_PORT, UC1601s_SDA_PIN, PAL_MODE_STM32_ALTERNATE_OPENDRAIN );
 8001310:	2111      	movs	r1, #17
 8001312:	2080      	movs	r0, #128	; 0x80
 8001314:	f001 f8c4 	bl	80024a0 <_pal_lld_setgroupmode.constprop.15>
 *
 * @init
 */
void i2cInit(void) {

  i2c_lld_init();
 8001318:	f7ff fd52 	bl	8000dc0 <i2c_lld_init>
}

static GFXINLINE void setpin_reset(GDisplay *g, bool_t state) {
	(void) g;
	if(state)
		CLR_RST
 800131c:	4d47      	ldr	r5, [pc, #284]	; (800143c <gdisp_lld_init+0x15c>)
 800131e:	2720      	movs	r7, #32
 8001320:	616f      	str	r7, [r5, #20]
void gfxSleepMilliseconds(delaytime_t ms)
{
	switch(ms) {
		case TIME_IMMEDIATE:	chThdYield();				return;
		case TIME_INFINITE:		chThdSleep(TIME_INFINITE);	return;
		default:				chThdSleepMilliseconds(ms);	return;
 8001322:	2014      	movs	r0, #20
 8001324:	f000 fc24 	bl	8001b70 <chThdSleep>
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 8001328:	4b45      	ldr	r3, [pc, #276]	; (8001440 <gdisp_lld_init+0x160>)
	else
		SET_RST
 800132a:	612f      	str	r7, [r5, #16]
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->prio;
 800132c:	699a      	ldr	r2, [r3, #24]
}

static GFXINLINE void acquire_bus(GDisplay *g) {
	(void) g;
	#if GFX_USE_OS_CHIBIOS
		thdPriority = (int32_t)chThdGetPriorityX();
 800132e:	4b45      	ldr	r3, [pc, #276]	; (8001444 <gdisp_lld_init+0x164>)
 8001330:	6892      	ldr	r2, [r2, #8]
		chThdSetPriority(HIGHPRIO);
 8001332:	20ff      	movs	r0, #255	; 0xff
}

static GFXINLINE void acquire_bus(GDisplay *g) {
	(void) g;
	#if GFX_USE_OS_CHIBIOS
		thdPriority = (int32_t)chThdGetPriorityX();
 8001334:	601a      	str	r2, [r3, #0]
 8001336:	9301      	str	r3, [sp, #4]
		chThdSetPriority(HIGHPRIO);
 8001338:	f000 fb62 	bl	8001a00 <chThdSetPriority>
 800133c:	f387 8811 	msr	BASEPRI, r7
 8001340:	4e41      	ldr	r6, [pc, #260]	; (8001448 <gdisp_lld_init+0x168>)
 8001342:	2500      	movs	r5, #0
 8001344:	4630      	mov	r0, r6
 8001346:	f000 fc73 	bl	8001c30 <chMtxLockS>
 800134a:	f385 8811 	msr	BASEPRI, r5

static GFXINLINE void write_cmd(GDisplay *g, uint8_t cmd) {
	(void) g;

	uint8_t command[1];
	command[0] = cmd;
 800134e:	22e2      	movs	r2, #226	; 0xe2
 8001350:	f10d 0810 	add.w	r8, sp, #16
 8001354:	f808 2d04 	strb.w	r2, [r8, #-4]!
 8001358:	f387 8811 	msr	BASEPRI, r7
  osalDbgCheck((i2cp != NULL) && (config != NULL));
  osalDbgAssert((i2cp->state == I2C_STOP) || (i2cp->state == I2C_READY) ||
                (i2cp->state == I2C_LOCKED), "invalid state");

  osalSysLock();
  i2cp->config = config;
 800135c:	f8df b0f0 	ldr.w	fp, [pc, #240]	; 8001450 <gdisp_lld_init+0x170>
 8001360:	f1a6 0a0c 	sub.w	sl, r6, #12
  i2c_lld_start(i2cp);
  i2cp->state = I2C_READY;
 8001364:	f04f 0902 	mov.w	r9, #2
  osalDbgCheck((i2cp != NULL) && (config != NULL));
  osalDbgAssert((i2cp->state == I2C_STOP) || (i2cp->state == I2C_READY) ||
                (i2cp->state == I2C_LOCKED), "invalid state");

  osalSysLock();
  i2cp->config = config;
 8001368:	f8ca b004 	str.w	fp, [sl, #4]
  i2c_lld_start(i2cp);
 800136c:	f000 ff30 	bl	80021d0 <i2c_lld_start.constprop.24>
  i2cp->state = I2C_READY;
 8001370:	f806 9c0c 	strb.w	r9, [r6, #-12]
 8001374:	f385 8811 	msr	BASEPRI, r5

	i2cStart(&I2CD1, &i2cconfig);
	i2cMasterTransmitTimeout(&I2CD1, UC1601s_I2C_ADDRESS_COMMAND, command, 1, 0, 0, MS2ST(10));
 8001378:	2201      	movs	r2, #1
 800137a:	4641      	mov	r1, r8
 800137c:	2038      	movs	r0, #56	; 0x38
 800137e:	f001 f827 	bl	80023d0 <i2cMasterTransmitTimeout.constprop.18>
	i2cStop(&I2CD1);
 8001382:	f000 ffd5 	bl	8002330 <i2cStop.constprop.20>
 8001386:	2014      	movs	r0, #20
 8001388:	f000 fbf2 	bl	8001b70 <chThdSleep>

static GFXINLINE void write_cmd2(GDisplay *g, uint8_t cmd1, uint8_t cmd2) {
	(void) g;

	uint8_t command[2];
	command[0] = cmd1;
 800138c:	2181      	movs	r1, #129	; 0x81
	command[1] = cmd2;
 800138e:	2278      	movs	r2, #120	; 0x78

static GFXINLINE void write_cmd2(GDisplay *g, uint8_t cmd1, uint8_t cmd2) {
	(void) g;

	uint8_t command[2];
	command[0] = cmd1;
 8001390:	f88d 100c 	strb.w	r1, [sp, #12]
	command[1] = cmd2;
 8001394:	f88d 200d 	strb.w	r2, [sp, #13]
 8001398:	f387 8811 	msr	BASEPRI, r7
  osalDbgCheck((i2cp != NULL) && (config != NULL));
  osalDbgAssert((i2cp->state == I2C_STOP) || (i2cp->state == I2C_READY) ||
                (i2cp->state == I2C_LOCKED), "invalid state");

  osalSysLock();
  i2cp->config = config;
 800139c:	f8ca b004 	str.w	fp, [sl, #4]
  i2c_lld_start(i2cp);
 80013a0:	f000 ff16 	bl	80021d0 <i2c_lld_start.constprop.24>
  i2cp->state = I2C_READY;
 80013a4:	f806 9c0c 	strb.w	r9, [r6, #-12]
 80013a8:	f385 8811 	msr	BASEPRI, r5

	i2cStart(&I2CD1, &i2cconfig);
	i2cMasterTransmitTimeout(&I2CD1, UC1601s_I2C_ADDRESS_COMMAND, command, 2, 0, 0, MS2ST(10));
 80013ac:	2038      	movs	r0, #56	; 0x38
 80013ae:	464a      	mov	r2, r9
 80013b0:	4641      	mov	r1, r8
 80013b2:	f001 f80d 	bl	80023d0 <i2cMasterTransmitTimeout.constprop.18>
	i2cStop(&I2CD1);
 80013b6:	f000 ffbb 	bl	8002330 <i2cStop.constprop.20>
 80013ba:	f387 8811 	msr	BASEPRI, r7
  osalDbgCheck((i2cp != NULL) && (config != NULL));
  osalDbgAssert((i2cp->state == I2C_STOP) || (i2cp->state == I2C_READY) ||
                (i2cp->state == I2C_LOCKED), "invalid state");

  osalSysLock();
  i2cp->config = config;
 80013be:	f8ca b004 	str.w	fp, [sl, #4]
  i2c_lld_start(i2cp);
 80013c2:	f000 ff05 	bl	80021d0 <i2c_lld_start.constprop.24>
  i2cp->state = I2C_READY;
 80013c6:	f806 9c0c 	strb.w	r9, [r6, #-12]
 80013ca:	f385 8811 	msr	BASEPRI, r5

static GFXINLINE void write_data(GDisplay *g, uint8_t* data, uint16_t length) {
	(void) g;

	i2cStart(&I2CD1, &i2cconfig);
	i2cMasterTransmitTimeout(&I2CD1, UC1601s_I2C_ADDRESS_DATA, data, length, 0, 0, MS2ST(10));
 80013ce:	f44f 6286 	mov.w	r2, #1072	; 0x430
 80013d2:	4629      	mov	r1, r5
 80013d4:	2039      	movs	r0, #57	; 0x39
 80013d6:	f000 fffb 	bl	80023d0 <i2cMasterTransmitTimeout.constprop.18>
	i2cStop(&I2CD1);
 80013da:	f000 ffa9 	bl	8002330 <i2cStop.constprop.20>

static GFXINLINE void write_cmd(GDisplay *g, uint8_t cmd) {
	(void) g;

	uint8_t command[1];
	command[0] = cmd;
 80013de:	22af      	movs	r2, #175	; 0xaf
 80013e0:	f88d 200c 	strb.w	r2, [sp, #12]
 80013e4:	f387 8811 	msr	BASEPRI, r7
  osalDbgCheck((i2cp != NULL) && (config != NULL));
  osalDbgAssert((i2cp->state == I2C_STOP) || (i2cp->state == I2C_READY) ||
                (i2cp->state == I2C_LOCKED), "invalid state");

  osalSysLock();
  i2cp->config = config;
 80013e8:	f8ca b004 	str.w	fp, [sl, #4]
  i2c_lld_start(i2cp);
 80013ec:	f000 fef0 	bl	80021d0 <i2c_lld_start.constprop.24>
  i2cp->state = I2C_READY;
 80013f0:	f806 9c0c 	strb.w	r9, [r6, #-12]
 80013f4:	f385 8811 	msr	BASEPRI, r5

	i2cStart(&I2CD1, &i2cconfig);
	i2cMasterTransmitTimeout(&I2CD1, UC1601s_I2C_ADDRESS_COMMAND, command, 1, 0, 0, MS2ST(10));
 80013f8:	2201      	movs	r2, #1
 80013fa:	4641      	mov	r1, r8
 80013fc:	2038      	movs	r0, #56	; 0x38
 80013fe:	f000 ffe7 	bl	80023d0 <i2cMasterTransmitTimeout.constprop.18>
	i2cStop(&I2CD1);
 8001402:	f000 ff95 	bl	8002330 <i2cStop.constprop.20>
}

static GFXINLINE void release_bus(GDisplay *g) {
	(void) g;
	#if GFX_USE_OS_CHIBIOS
		chThdSetPriority(thdPriority);
 8001406:	9b01      	ldr	r3, [sp, #4]
 8001408:	6818      	ldr	r0, [r3, #0]
 800140a:	f000 faf9 	bl	8001a00 <chThdSetPriority>
 800140e:	4630      	mov	r0, r6
 8001410:	f000 fbd6 	bl	8001bc0 <chMtxUnlock>
 	// Release the bus
	release_bus(g);

	/* Initialise the GDISP structure */
	g->g.Width = GDISP_SCREEN_WIDTH;
	g->g.Height = GDISP_SCREEN_HEIGHT;
 8001414:	2040      	movs	r0, #64	; 0x40

 	// Release the bus
	release_bus(g);

	/* Initialise the GDISP structure */
	g->g.Width = GDISP_SCREEN_WIDTH;
 8001416:	2684      	movs	r6, #132	; 0x84
	g->g.Height = GDISP_SCREEN_HEIGHT;
	g->g.Orientation = GDISP_ROTATE_0;
	g->g.Powermode = powerOn;
 8001418:	2103      	movs	r1, #3
	g->g.Backlight = GDISP_INITIAL_BACKLIGHT;
 800141a:	2264      	movs	r2, #100	; 0x64
	g->g.Contrast = GDISP_INITIAL_CONTRAST;
 800141c:	232f      	movs	r3, #47	; 0x2f
 	// Release the bus
	release_bus(g);

	/* Initialise the GDISP structure */
	g->g.Width = GDISP_SCREEN_WIDTH;
	g->g.Height = GDISP_SCREEN_HEIGHT;
 800141e:	8160      	strh	r0, [r4, #10]
	g->g.Orientation = GDISP_ROTATE_0;
	g->g.Powermode = powerOn;
	g->g.Backlight = GDISP_INITIAL_BACKLIGHT;
	g->g.Contrast = GDISP_INITIAL_CONTRAST;
	return TRUE;
}
 8001420:	2001      	movs	r0, #1
	release_bus(g);

	/* Initialise the GDISP structure */
	g->g.Width = GDISP_SCREEN_WIDTH;
	g->g.Height = GDISP_SCREEN_HEIGHT;
	g->g.Orientation = GDISP_ROTATE_0;
 8001422:	81a5      	strh	r5, [r4, #12]

 	// Release the bus
	release_bus(g);

	/* Initialise the GDISP structure */
	g->g.Width = GDISP_SCREEN_WIDTH;
 8001424:	8126      	strh	r6, [r4, #8]
	g->g.Height = GDISP_SCREEN_HEIGHT;
	g->g.Orientation = GDISP_ROTATE_0;
	g->g.Powermode = powerOn;
 8001426:	73a1      	strb	r1, [r4, #14]
	g->g.Backlight = GDISP_INITIAL_BACKLIGHT;
 8001428:	73e2      	strb	r2, [r4, #15]
	g->g.Contrast = GDISP_INITIAL_CONTRAST;
 800142a:	7423      	strb	r3, [r4, #16]
	return TRUE;
}
 800142c:	b005      	add	sp, #20
 800142e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8001432:	b672      	cpsid	i
 8001434:	4b02      	ldr	r3, [pc, #8]	; (8001440 <gdisp_lld_init+0x160>)
 8001436:	4a05      	ldr	r2, [pc, #20]	; (800144c <gdisp_lld_init+0x16c>)
 8001438:	629a      	str	r2, [r3, #40]	; 0x28
 800143a:	e7fe      	b.n	800143a <gdisp_lld_init+0x15a>
 800143c:	40010c00 	.word	0x40010c00
 8001440:	20000918 	.word	0x20000918
 8001444:	20000800 	.word	0x20000800
 8001448:	20000a10 	.word	0x20000a10
 800144c:	080028f0 	.word	0x080028f0
 8001450:	080028e4 	.word	0x080028e4
	...

08001460 <main>:

#include "lib/menu.h"
/*
 * Application entry point.
 */
int main(void) {
 8001460:	b580      	push	{r7, lr}
 8001462:	b0cc      	sub	sp, #304	; 0x130
   * - HAL initialization, this also initializes the configured device drivers
   *   and performs the board-specific initializations.
   * - Kernel initialization, the main() function becomes a thread and the
   *   RTOS is active.
   */
  halInit();
 8001464:	f000 f9cc 	bl	8001800 <halInit>
  chSysInit();
 8001468:	f000 fcc2 	bl	8001df0 <chSysInit>
#endif

void gfxInit(void)
{
	/* Ensure we only initialise once */
	if (gfxInitDone)
 800146c:	4b8c      	ldr	r3, [pc, #560]	; (80016a0 <main+0x240>)
 800146e:	781a      	ldrb	r2, [r3, #0]
 8001470:	2a00      	cmp	r2, #0
 8001472:	f000 80ce 	beq.w	8001612 <main+0x1b2>
  items
*/

  menu mm_item01 = { "Пункт 01",  NULL, NULL, NULL, 0 };
  menu mm_item02 = { "Пункт 02",  NULL, NULL, NULL, 0 };
  menu mm_item03 = { "Пункт 03",  NULL, NULL, NULL, 0 };
 8001476:	488b      	ldr	r0, [pc, #556]	; (80016a4 <main+0x244>)

  menu settings_mode   = { "Режим", NULL, NULL, NULL, 0 };
  menu settings_item02 = { "Тест", NULL, NULL, NULL, 0 };
  menu settings_item03 = { "Пункт 01_03", NULL, NULL, NULL, 0 };
 8001478:	4c8b      	ldr	r4, [pc, #556]	; (80016a8 <main+0x248>)
  func
  prev
  items
*/

  menu mm_item01 = { "Пункт 01",  NULL, NULL, NULL, 0 };
 800147a:	4f8c      	ldr	r7, [pc, #560]	; (80016ac <main+0x24c>)
  menu mm_item02 = { "Пункт 02",  NULL, NULL, NULL, 0 };
 800147c:	4a8c      	ldr	r2, [pc, #560]	; (80016b0 <main+0x250>)
  menu mm_item03 = { "Пункт 03",  NULL, NULL, NULL, 0 };

  menu settings_mode   = { "Режим", NULL, NULL, NULL, 0 };
 800147e:	4e8d      	ldr	r6, [pc, #564]	; (80016b4 <main+0x254>)
  menu settings_item02 = { "Тест", NULL, NULL, NULL, 0 };
 8001480:	4d8d      	ldr	r5, [pc, #564]	; (80016b8 <main+0x258>)
  menu settings_item03 = { "Пункт 01_03", NULL, NULL, NULL, 0 };
  menu settings_item04 = { "Пункт 01_04", NULL, NULL, NULL, 0 };
 8001482:	4b8e      	ldr	r3, [pc, #568]	; (80016bc <main+0x25c>)
  items
*/

  menu mm_item01 = { "Пункт 01",  NULL, NULL, NULL, 0 };
  menu mm_item02 = { "Пункт 02",  NULL, NULL, NULL, 0 };
  menu mm_item03 = { "Пункт 03",  NULL, NULL, NULL, 0 };
 8001484:	9038      	str	r0, [sp, #224]	; 0xe0
  menu * lang_items[] = {
                                &lang_english,
                                &lang_russian
                              };

  menu settings_lang = { "Язык", NULL, NULL, lang_items, 0 };
 8001486:	488e      	ldr	r0, [pc, #568]	; (80016c0 <main+0x260>)
  menu mm_item02 = { "Пункт 02",  NULL, NULL, NULL, 0 };
  menu mm_item03 = { "Пункт 03",  NULL, NULL, NULL, 0 };

  menu settings_mode   = { "Режим", NULL, NULL, NULL, 0 };
  menu settings_item02 = { "Тест", NULL, NULL, NULL, 0 };
  menu settings_item03 = { "Пункт 01_03", NULL, NULL, NULL, 0 };
 8001488:	9429      	str	r4, [sp, #164]	; 0xa4
  func
  prev
  items
*/

  menu mm_item01 = { "Пункт 01",  NULL, NULL, NULL, 0 };
 800148a:	2400      	movs	r4, #0
 800148c:	9742      	str	r7, [sp, #264]	; 0x108
  menu mm_item02 = { "Пункт 02",  NULL, NULL, NULL, 0 };
 800148e:	923d      	str	r2, [sp, #244]	; 0xf4
  menu mm_item03 = { "Пункт 03",  NULL, NULL, NULL, 0 };

  menu settings_mode   = { "Режим", NULL, NULL, NULL, 0 };
 8001490:	9633      	str	r6, [sp, #204]	; 0xcc
  menu settings_item02 = { "Тест", NULL, NULL, NULL, 0 };
 8001492:	952e      	str	r5, [sp, #184]	; 0xb8
  menu settings_item03 = { "Пункт 01_03", NULL, NULL, NULL, 0 };
  menu settings_item04 = { "Пункт 01_04", NULL, NULL, NULL, 0 };
 8001494:	9324      	str	r3, [sp, #144]	; 0x90
  func
  prev
  items
*/

  menu mm_item01 = { "Пункт 01",  NULL, NULL, NULL, 0 };
 8001496:	9443      	str	r4, [sp, #268]	; 0x10c
 8001498:	9444      	str	r4, [sp, #272]	; 0x110
 800149a:	9445      	str	r4, [sp, #276]	; 0x114
 800149c:	f88d 4118 	strb.w	r4, [sp, #280]	; 0x118
  menu mm_item02 = { "Пункт 02",  NULL, NULL, NULL, 0 };
 80014a0:	943e      	str	r4, [sp, #248]	; 0xf8
 80014a2:	943f      	str	r4, [sp, #252]	; 0xfc
 80014a4:	9440      	str	r4, [sp, #256]	; 0x100
 80014a6:	f88d 4104 	strb.w	r4, [sp, #260]	; 0x104
  menu mm_item03 = { "Пункт 03",  NULL, NULL, NULL, 0 };
 80014aa:	9439      	str	r4, [sp, #228]	; 0xe4
 80014ac:	943a      	str	r4, [sp, #232]	; 0xe8
 80014ae:	943b      	str	r4, [sp, #236]	; 0xec
 80014b0:	f88d 40f0 	strb.w	r4, [sp, #240]	; 0xf0

  menu settings_mode   = { "Режим", NULL, NULL, NULL, 0 };
 80014b4:	9434      	str	r4, [sp, #208]	; 0xd0
 80014b6:	9435      	str	r4, [sp, #212]	; 0xd4
 80014b8:	9436      	str	r4, [sp, #216]	; 0xd8
 80014ba:	f88d 40dc 	strb.w	r4, [sp, #220]	; 0xdc
  menu settings_item02 = { "Тест", NULL, NULL, NULL, 0 };
 80014be:	942f      	str	r4, [sp, #188]	; 0xbc
 80014c0:	9430      	str	r4, [sp, #192]	; 0xc0
 80014c2:	9431      	str	r4, [sp, #196]	; 0xc4
 80014c4:	f88d 40c8 	strb.w	r4, [sp, #200]	; 0xc8
  menu settings_item03 = { "Пункт 01_03", NULL, NULL, NULL, 0 };
 80014c8:	942a      	str	r4, [sp, #168]	; 0xa8
 80014ca:	942b      	str	r4, [sp, #172]	; 0xac
 80014cc:	942c      	str	r4, [sp, #176]	; 0xb0
 80014ce:	f88d 40b4 	strb.w	r4, [sp, #180]	; 0xb4
  menu settings_item04 = { "Пункт 01_04", NULL, NULL, NULL, 0 };
 80014d2:	9425      	str	r4, [sp, #148]	; 0x94
 80014d4:	9426      	str	r4, [sp, #152]	; 0x98
  menu * lang_items[] = {
                                &lang_english,
                                &lang_russian
                              };

  menu settings_lang = { "Язык", NULL, NULL, lang_items, 0 };
 80014d6:	9015      	str	r0, [sp, #84]	; 0x54
  menu settings_item04 = { "Пункт 01_04", NULL, NULL, NULL, 0 };

  menu lang_english = { "English", NULL, NULL, NULL, 0 };
  menu lang_russian = { "Русский", NULL, NULL, NULL, 0 };

  menu * lang_items[] = {
 80014d8:	a81f      	add	r0, sp, #124	; 0x7c
 80014da:	9001      	str	r0, [sp, #4]
 80014dc:	a81a      	add	r0, sp, #104	; 0x68
 80014de:	9002      	str	r0, [sp, #8]
                                &lang_russian
                              };

  menu settings_lang = { "Язык", NULL, NULL, lang_items, 0 };

  menu * settings_items[] = { 
 80014e0:	a833      	add	r0, sp, #204	; 0xcc
                                    &settings_item03, 
                                    &settings_item04, 
                                    &settings_lang
                                  };

  menu mm_settings = { "Настройки", NULL, &mm, settings_items, 5 };
 80014e2:	4978      	ldr	r1, [pc, #480]	; (80016c4 <main+0x264>)
  menu settings_item02 = { "Тест", NULL, NULL, NULL, 0 };
  menu settings_item03 = { "Пункт 01_03", NULL, NULL, NULL, 0 };
  menu settings_item04 = { "Пункт 01_04", NULL, NULL, NULL, 0 };

  menu lang_english = { "English", NULL, NULL, NULL, 0 };
  menu lang_russian = { "Русский", NULL, NULL, NULL, 0 };
 80014e4:	4a78      	ldr	r2, [pc, #480]	; (80016c8 <main+0x268>)
                                &lang_russian
                              };

  menu settings_lang = { "Язык", NULL, NULL, lang_items, 0 };

  menu * settings_items[] = { 
 80014e6:	9010      	str	r0, [sp, #64]	; 0x40
 80014e8:	a829      	add	r0, sp, #164	; 0xa4
 80014ea:	9012      	str	r0, [sp, #72]	; 0x48
 80014ec:	a815      	add	r0, sp, #84	; 0x54
                                    &settings_item03, 
                                    &settings_item04, 
                                    &settings_lang
                                  };

  menu mm_settings = { "Настройки", NULL, &mm, settings_items, 5 };
 80014ee:	910b      	str	r1, [sp, #44]	; 0x2c
  menu settings_item02 = { "Тест", NULL, NULL, NULL, 0 };
  menu settings_item03 = { "Пункт 01_03", NULL, NULL, NULL, 0 };
  menu settings_item04 = { "Пункт 01_04", NULL, NULL, NULL, 0 };

  menu lang_english = { "English", NULL, NULL, NULL, 0 };
  menu lang_russian = { "Русский", NULL, NULL, NULL, 0 };
 80014f0:	921a      	str	r2, [sp, #104]	; 0x68
                                    &settings_item03, 
                                    &settings_item04, 
                                    &settings_lang
                                  };

  menu mm_settings = { "Настройки", NULL, &mm, settings_items, 5 };
 80014f2:	a910      	add	r1, sp, #64	; 0x40
  menu settings_item04 = { "Пункт 01_04", NULL, NULL, NULL, 0 };

  menu lang_english = { "English", NULL, NULL, NULL, 0 };
  menu lang_russian = { "Русский", NULL, NULL, NULL, 0 };

  menu * lang_items[] = {
 80014f4:	aa01      	add	r2, sp, #4
                                &lang_russian
                              };

  menu settings_lang = { "Язык", NULL, NULL, lang_items, 0 };

  menu * settings_items[] = { 
 80014f6:	9014      	str	r0, [sp, #80]	; 0x50
                                    &settings_lang
                                  };

  menu mm_settings = { "Настройки", NULL, &mm, settings_items, 5 };

  menu * mm_items[] = { &mm_item01,
 80014f8:	a842      	add	r0, sp, #264	; 0x108
  menu settings_mode   = { "Режим", NULL, NULL, NULL, 0 };
  menu settings_item02 = { "Тест", NULL, NULL, NULL, 0 };
  menu settings_item03 = { "Пункт 01_03", NULL, NULL, NULL, 0 };
  menu settings_item04 = { "Пункт 01_04", NULL, NULL, NULL, 0 };

  menu lang_english = { "English", NULL, NULL, NULL, 0 };
 80014fa:	4f74      	ldr	r7, [pc, #464]	; (80016cc <main+0x26c>)
                                    &settings_item03, 
                                    &settings_item04, 
                                    &settings_lang
                                  };

  menu mm_settings = { "Настройки", NULL, &mm, settings_items, 5 };
 80014fc:	910e      	str	r1, [sp, #56]	; 0x38
  menu * lang_items[] = {
                                &lang_english,
                                &lang_russian
                              };

  menu settings_lang = { "Язык", NULL, NULL, lang_items, 0 };
 80014fe:	9218      	str	r2, [sp, #96]	; 0x60
                                    &settings_item03, 
                                    &settings_item04, 
                                    &settings_lang
                                  };

  menu mm_settings = { "Настройки", NULL, &mm, settings_items, 5 };
 8001500:	2105      	movs	r1, #5
                                &lang_russian
                              };

  menu settings_lang = { "Язык", NULL, NULL, lang_items, 0 };

  menu * settings_items[] = { 
 8001502:	aa2e      	add	r2, sp, #184	; 0xb8
                                    &settings_lang
                                  };

  menu mm_settings = { "Настройки", NULL, &mm, settings_items, 5 };

  menu * mm_items[] = { &mm_item01,
 8001504:	9003      	str	r0, [sp, #12]
 8001506:	a83d      	add	r0, sp, #244	; 0xf4
                                    &settings_item03, 
                                    &settings_item04, 
                                    &settings_lang
                                  };

  menu mm_settings = { "Настройки", NULL, &mm, settings_items, 5 };
 8001508:	ab0b      	add	r3, sp, #44	; 0x2c
 800150a:	f88d 103c 	strb.w	r1, [sp, #60]	; 0x3c
                                &lang_russian
                              };

  menu settings_lang = { "Язык", NULL, NULL, lang_items, 0 };

  menu * settings_items[] = { 
 800150e:	9211      	str	r2, [sp, #68]	; 0x44
                                    &settings_item03, 
                                    &settings_item04, 
                                    &settings_lang
                                  };

  menu mm_settings = { "Настройки", NULL, &mm, settings_items, 5 };
 8001510:	a947      	add	r1, sp, #284	; 0x11c
                                &lang_russian
                              };

  menu settings_lang = { "Язык", NULL, NULL, lang_items, 0 };

  menu * settings_items[] = { 
 8001512:	aa24      	add	r2, sp, #144	; 0x90
                                    &settings_lang
                                  };

  menu mm_settings = { "Настройки", NULL, &mm, settings_items, 5 };

  menu * mm_items[] = { &mm_item01,
 8001514:	9004      	str	r0, [sp, #16]
  mm.prev = NULL;
  mm.items = mm_items;

  mms.MAX_ROWS = 4;
  mms.DRAW_AUTO = TRUE;
  mms.font = "Archangelsk Regular 12";
 8001516:	4e6e      	ldr	r6, [pc, #440]	; (80016d0 <main+0x270>)
                                    &settings_lang
                                  };

  menu mm_settings = { "Настройки", NULL, &mm, settings_items, 5 };

  menu * mm_items[] = { &mm_item01,
 8001518:	a838      	add	r0, sp, #224	; 0xe0
                        &mm_item02, 
                        &mm_item03, 
                        &mm_settings }; 

  mm.count_items = 4;
  mm.label = "menu";
 800151a:	4d6e      	ldr	r5, [pc, #440]	; (80016d4 <main+0x274>)
                                    &settings_item03, 
                                    &settings_item04, 
                                    &settings_lang
                                  };

  menu mm_settings = { "Настройки", NULL, &mm, settings_items, 5 };
 800151c:	910d      	str	r1, [sp, #52]	; 0x34
  menu settings_mode   = { "Режим", NULL, NULL, NULL, 0 };
  menu settings_item02 = { "Тест", NULL, NULL, NULL, 0 };
  menu settings_item03 = { "Пункт 01_03", NULL, NULL, NULL, 0 };
  menu settings_item04 = { "Пункт 01_04", NULL, NULL, NULL, 0 };

  menu lang_english = { "English", NULL, NULL, NULL, 0 };
 800151e:	971f      	str	r7, [sp, #124]	; 0x7c
                                &lang_russian
                              };

  menu settings_lang = { "Язык", NULL, NULL, lang_items, 0 };

  menu * settings_items[] = { 
 8001520:	9213      	str	r2, [sp, #76]	; 0x4c
                                    &settings_lang
                                  };

  menu mm_settings = { "Настройки", NULL, &mm, settings_items, 5 };

  menu * mm_items[] = { &mm_item01,
 8001522:	9005      	str	r0, [sp, #20]
 8001524:	aa03      	add	r2, sp, #12
  mms.last_top = 0;
  mms.current_item = 0;
  mms.last_current_item = 0;
  mms.current_menu = &mm;

  menu_draw(&mms);
 8001526:	a807      	add	r0, sp, #28
  menu mm_item03 = { "Пункт 03",  NULL, NULL, NULL, 0 };

  menu settings_mode   = { "Режим", NULL, NULL, NULL, 0 };
  menu settings_item02 = { "Тест", NULL, NULL, NULL, 0 };
  menu settings_item03 = { "Пункт 01_03", NULL, NULL, NULL, 0 };
  menu settings_item04 = { "Пункт 01_04", NULL, NULL, NULL, 0 };
 8001528:	9427      	str	r4, [sp, #156]	; 0x9c
 800152a:	f88d 40a0 	strb.w	r4, [sp, #160]	; 0xa0

  menu lang_english = { "English", NULL, NULL, NULL, 0 };
 800152e:	9420      	str	r4, [sp, #128]	; 0x80
 8001530:	9421      	str	r4, [sp, #132]	; 0x84
 8001532:	9422      	str	r4, [sp, #136]	; 0x88
 8001534:	f88d 408c 	strb.w	r4, [sp, #140]	; 0x8c
  menu lang_russian = { "Русский", NULL, NULL, NULL, 0 };
 8001538:	941b      	str	r4, [sp, #108]	; 0x6c
 800153a:	941c      	str	r4, [sp, #112]	; 0x70
 800153c:	941d      	str	r4, [sp, #116]	; 0x74
 800153e:	f88d 4078 	strb.w	r4, [sp, #120]	; 0x78
  menu * lang_items[] = {
                                &lang_english,
                                &lang_russian
                              };

  menu settings_lang = { "Язык", NULL, NULL, lang_items, 0 };
 8001542:	9416      	str	r4, [sp, #88]	; 0x58
 8001544:	9417      	str	r4, [sp, #92]	; 0x5c
 8001546:	f88d 4064 	strb.w	r4, [sp, #100]	; 0x64
                                    &settings_item03, 
                                    &settings_item04, 
                                    &settings_lang
                                  };

  menu mm_settings = { "Настройки", NULL, &mm, settings_items, 5 };
 800154a:	940c      	str	r4, [sp, #48]	; 0x30
  mm.func = NULL;
  mm.prev = NULL;
  mm.items = mm_items;

  mms.MAX_ROWS = 4;
  mms.DRAW_AUTO = TRUE;
 800154c:	27ff      	movs	r7, #255	; 0xff
                                    &settings_lang
                                  };

  menu mm_settings = { "Настройки", NULL, &mm, settings_items, 5 };

  menu * mm_items[] = { &mm_item01,
 800154e:	9306      	str	r3, [sp, #24]
                        &mm_item02, 
                        &mm_item03, 
                        &mm_settings }; 

  mm.count_items = 4;
 8001550:	2304      	movs	r3, #4
  mm.label = "menu";
  mm.func = NULL;
  mm.prev = NULL;
  mm.items = mm_items;
 8001552:	924a      	str	r2, [sp, #296]	; 0x128
  mms.font = "Archangelsk Regular 12";
  mms.top = 0;
  mms.last_top = 0;
  mms.current_item = 0;
  mms.last_current_item = 0;
  mms.current_menu = &mm;
 8001554:	910a      	str	r1, [sp, #40]	; 0x28
  mm.label = "menu";
  mm.func = NULL;
  mm.prev = NULL;
  mm.items = mm_items;

  mms.MAX_ROWS = 4;
 8001556:	f88d 301c 	strb.w	r3, [sp, #28]
  menu * mm_items[] = { &mm_item01,
                        &mm_item02, 
                        &mm_item03, 
                        &mm_settings }; 

  mm.count_items = 4;
 800155a:	f88d 312c 	strb.w	r3, [sp, #300]	; 0x12c
  mm.label = "menu";
  mm.func = NULL;
 800155e:	9448      	str	r4, [sp, #288]	; 0x120
  mm.prev = NULL;
 8001560:	9449      	str	r4, [sp, #292]	; 0x124
  mm.items = mm_items;

  mms.MAX_ROWS = 4;
  mms.DRAW_AUTO = TRUE;
  mms.font = "Archangelsk Regular 12";
  mms.top = 0;
 8001562:	f88d 4024 	strb.w	r4, [sp, #36]	; 0x24
  mms.last_top = 0;
 8001566:	f88d 4025 	strb.w	r4, [sp, #37]	; 0x25
  mms.current_item = 0;
 800156a:	f88d 4026 	strb.w	r4, [sp, #38]	; 0x26
  mms.last_current_item = 0;
 800156e:	f88d 4027 	strb.w	r4, [sp, #39]	; 0x27
  mm.func = NULL;
  mm.prev = NULL;
  mm.items = mm_items;

  mms.MAX_ROWS = 4;
  mms.DRAW_AUTO = TRUE;
 8001572:	f88d 701d 	strb.w	r7, [sp, #29]
  mms.font = "Archangelsk Regular 12";
 8001576:	9608      	str	r6, [sp, #32]
                        &mm_item02, 
                        &mm_item03, 
                        &mm_settings }; 

  mm.count_items = 4;
  mm.label = "menu";
 8001578:	9547      	str	r5, [sp, #284]	; 0x11c
  mms.last_top = 0;
  mms.current_item = 0;
  mms.last_current_item = 0;
  mms.current_menu = &mm;

  menu_draw(&mms);
 800157a:	f000 ffc9 	bl	8002510 <menu_draw>
 800157e:	f44f 607a 	mov.w	r0, #4000	; 0xfa0
 8001582:	f000 faf5 	bl	8001b70 <chThdSleep>
  gfxSleepMilliseconds(2000);
  menu_down(&mms);
 8001586:	a807      	add	r0, sp, #28
 8001588:	f7ff fd42 	bl	8001010 <menu_down>
 800158c:	f44f 607a 	mov.w	r0, #4000	; 0xfa0
 8001590:	f000 faee 	bl	8001b70 <chThdSleep>
  gfxSleepMilliseconds(2000);
  menu_down(&mms);
 8001594:	a807      	add	r0, sp, #28
 8001596:	f7ff fd3b 	bl	8001010 <menu_down>
 800159a:	f44f 607a 	mov.w	r0, #4000	; 0xfa0
 800159e:	f000 fae7 	bl	8001b70 <chThdSleep>
  gfxSleepMilliseconds(2000);
  menu_down(&mms);
 80015a2:	a807      	add	r0, sp, #28
 80015a4:	f7ff fd34 	bl	8001010 <menu_down>
 80015a8:	f44f 607a 	mov.w	r0, #4000	; 0xfa0
 80015ac:	f000 fae0 	bl	8001b70 <chThdSleep>
	if(ms->DRAW_AUTO) menu_draw(ms);
}

void menu_select(menu_state * ms, uint8_t draw)
{
	if(ms->current_menu->items[ms->current_item]->items != NULL)
 80015b0:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80015b2:	f89d 2026 	ldrb.w	r2, [sp, #38]	; 0x26
 80015b6:	68db      	ldr	r3, [r3, #12]
 80015b8:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 80015bc:	68d9      	ldr	r1, [r3, #12]
 80015be:	b319      	cbz	r1, 8001608 <main+0x1a8>
	{
		ms->current_menu = ms->current_menu->items[ms->current_item];
		ms->last_top = ms->top;
 80015c0:	f89d 1024 	ldrb.w	r1, [sp, #36]	; 0x24

void menu_select(menu_state * ms, uint8_t draw)
{
	if(ms->current_menu->items[ms->current_item]->items != NULL)
	{
		ms->current_menu = ms->current_menu->items[ms->current_item];
 80015c4:	930a      	str	r3, [sp, #40]	; 0x28
		ms->last_top = ms->top;
		ms->last_current_item = ms->current_item;
 80015c6:	f88d 2027 	strb.w	r2, [sp, #39]	; 0x27
		ms->top = 0;
		ms->current_item = 0;
 80015ca:	f88d 4026 	strb.w	r4, [sp, #38]	; 0x26
void menu_select(menu_state * ms, uint8_t draw)
{
	if(ms->current_menu->items[ms->current_item]->items != NULL)
	{
		ms->current_menu = ms->current_menu->items[ms->current_item];
		ms->last_top = ms->top;
 80015ce:	f88d 1025 	strb.w	r1, [sp, #37]	; 0x25
		ms->last_current_item = ms->current_item;
		ms->top = 0;
 80015d2:	f88d 4024 	strb.w	r4, [sp, #36]	; 0x24
		ms->current_item = 0;
	} else if(ms->current_menu->items[ms->current_item]->func != NULL) {
		menu_call(ms->current_menu->items[ms->current_item]->func);
	}
	if((ms->DRAW_AUTO) && draw) menu_draw(ms);
 80015d6:	f89d 301d 	ldrb.w	r3, [sp, #29]
 80015da:	b113      	cbz	r3, 80015e2 <main+0x182>
 80015dc:	a807      	add	r0, sp, #28
 80015de:	f000 ff97 	bl	8002510 <menu_draw>
 80015e2:	f44f 607a 	mov.w	r0, #4000	; 0xfa0
 80015e6:	f000 fac3 	bl	8001b70 <chThdSleep>
  gfxSleepMilliseconds(2000);
  menu_select(&mms, TRUE);
  gfxSleepMilliseconds(2000);
  menu_down(&mms);
 80015ea:	a807      	add	r0, sp, #28
 80015ec:	f7ff fd10 	bl	8001010 <menu_down>
 80015f0:	f44f 607a 	mov.w	r0, #4000	; 0xfa0
 80015f4:	f000 fabc 	bl	8001b70 <chThdSleep>
  gfxSleepMilliseconds(2000);
  //menu_select(&mms, FALSE);
  //gfxSleepMilliseconds(5000);
  menu_draw(&mms);
 80015f8:	a807      	add	r0, sp, #28
 80015fa:	f000 ff89 	bl	8002510 <menu_draw>
 80015fe:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8001602:	f000 fab5 	bl	8001b70 <chThdSleep>
 8001606:	e7fa      	b.n	80015fe <main+0x19e>
		ms->current_menu = ms->current_menu->items[ms->current_item];
		ms->last_top = ms->top;
		ms->last_current_item = ms->current_item;
		ms->top = 0;
		ms->current_item = 0;
	} else if(ms->current_menu->items[ms->current_item]->func != NULL) {
 8001608:	685b      	ldr	r3, [r3, #4]
 800160a:	2b00      	cmp	r3, #0
 800160c:	d0e3      	beq.n	80015d6 <main+0x176>
		menu_call(ms->current_menu->items[ms->current_item]->func);
 800160e:	4798      	blx	r3
 8001610:	e7e1      	b.n	80015d6 <main+0x176>
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 8001612:	4a31      	ldr	r2, [pc, #196]	; (80016d8 <main+0x278>)
		return;
	gfxInitDone = TRUE;
 8001614:	2101      	movs	r1, #1
			if (!chThdSelf()) {
				halInit();
				chSysInit();
			}
		#elif (CH_KERNEL_MAJOR == 3) || (CH_KERNEL_MAJOR == 4)
			if (!chThdGetSelfX()) {
 8001616:	6992      	ldr	r2, [r2, #24]
 8001618:	7019      	strb	r1, [r3, #0]
 800161a:	b91a      	cbnz	r2, 8001624 <main+0x1c4>
				halInit();
 800161c:	f000 f8f0 	bl	8001800 <halInit>
				chSysInit();
 8001620:	f000 fbe6 	bl	8001df0 <chSysInit>
	GDriver *	pd;
	unsigned	dinstance, sinstance;

	// Loop to find the driver instance and the system instance numbers
	dinstance = sinstance = 0;
	for(pd = dhead; pd; pd = pd->driverchain) {
 8001624:	f8df 80b8 	ldr.w	r8, [pc, #184]	; 80016e0 <main+0x280>
 8001628:	f8d8 3000 	ldr.w	r3, [r8]
 800162c:	b173      	cbz	r3, 800164c <main+0x1ec>
 800162e:	2500      	movs	r5, #0
 8001630:	462e      	mov	r6, r5
 8001632:	4f2a      	ldr	r7, [pc, #168]	; (80016dc <main+0x27c>)
		if (pd->vmt == vmt)
 8001634:	685a      	ldr	r2, [r3, #4]
	GDriver *	pd;
	unsigned	dinstance, sinstance;

	// Loop to find the driver instance and the system instance numbers
	dinstance = sinstance = 0;
	for(pd = dhead; pd; pd = pd->driverchain) {
 8001636:	681b      	ldr	r3, [r3, #0]
		if (pd->vmt == vmt)
 8001638:	42ba      	cmp	r2, r7
			dinstance++;
		if (pd->vmt->type == vmt->type)
 800163a:	8812      	ldrh	r2, [r2, #0]

	// Loop to find the driver instance and the system instance numbers
	dinstance = sinstance = 0;
	for(pd = dhead; pd; pd = pd->driverchain) {
		if (pd->vmt == vmt)
			dinstance++;
 800163c:	bf08      	it	eq
 800163e:	3601      	addeq	r6, #1
		if (pd->vmt->type == vmt->type)
 8001640:	2a67      	cmp	r2, #103	; 0x67
			sinstance++;
 8001642:	bf08      	it	eq
 8001644:	3501      	addeq	r5, #1
	GDriver *	pd;
	unsigned	dinstance, sinstance;

	// Loop to find the driver instance and the system instance numbers
	dinstance = sinstance = 0;
	for(pd = dhead; pd; pd = pd->driverchain) {
 8001646:	2b00      	cmp	r3, #0
 8001648:	d1f4      	bne.n	8001634 <main+0x1d4>
 800164a:	e002      	b.n	8001652 <main+0x1f2>
GDriver *gdriverRegister(const GDriverVMT *vmt, void *param) {
	GDriver *	pd;
	unsigned	dinstance, sinstance;

	// Loop to find the driver instance and the system instance numbers
	dinstance = sinstance = 0;
 800164c:	461d      	mov	r5, r3
 800164e:	461e      	mov	r6, r3
 8001650:	4f22      	ldr	r7, [pc, #136]	; (80016dc <main+0x27c>)
 8001652:	2048      	movs	r0, #72	; 0x48
 8001654:	f000 fd44 	bl	80020e0 <chHeapAllocAligned.constprop.27>
			sinstance++;
	}

	// Get a new driver instance of the correct size and initialize it
	pd = gfxAlloc(vmt->objsize);
	if (!pd)
 8001658:	4604      	mov	r4, r0
 800165a:	2800      	cmp	r0, #0
 800165c:	f43f af0b 	beq.w	8001476 <main+0x16>
		return 0;
    memset(pd, 0, vmt->objsize);
 8001660:	2248      	movs	r2, #72	; 0x48
 8001662:	2100      	movs	r1, #0
 8001664:	f001 f8a4 	bl	80027b0 <memset>
	pd->vmt = vmt;
 8001668:	6067      	str	r7, [r4, #4]
	if (vmt->init && !vmt->init(pd, param, dinstance, sinstance)) {
 800166a:	462b      	mov	r3, r5
 800166c:	4632      	mov	r2, r6
 800166e:	2100      	movs	r1, #0
 8001670:	4620      	mov	r0, r4
 8001672:	f7ff f83d 	bl	80006f0 <_gdispInitDriver>
 8001676:	b158      	cbz	r0, 8001690 <main+0x230>
		gfxFree(pd);
		return 0;
	}

	// Add it to the driver chain (at the end)
	if (dhead)
 8001678:	f8d8 3000 	ldr.w	r3, [r8]
 800167c:	4a18      	ldr	r2, [pc, #96]	; (80016e0 <main+0x280>)
 800167e:	b15b      	cbz	r3, 8001698 <main+0x238>
		dtail->driverchain = pd;
 8001680:	4b18      	ldr	r3, [pc, #96]	; (80016e4 <main+0x284>)
 8001682:	681a      	ldr	r2, [r3, #0]
 8001684:	6014      	str	r4, [r2, #0]
		dhead = pd;
	dtail = pd;

	// Do the post init
	if (vmt->postinit)
		vmt->postinit(pd);
 8001686:	4620      	mov	r0, r4
	// Add it to the driver chain (at the end)
	if (dhead)
		dtail->driverchain = pd;
	else
		dhead = pd;
	dtail = pd;
 8001688:	601c      	str	r4, [r3, #0]

	// Do the post init
	if (vmt->postinit)
		vmt->postinit(pd);
 800168a:	f7ff f811 	bl	80006b0 <_gdispPostInitDriver>
 800168e:	e6f2      	b.n	8001476 <main+0x16>
	if (!pd)
		return 0;
    memset(pd, 0, vmt->objsize);
	pd->vmt = vmt;
	if (vmt->init && !vmt->init(pd, param, dinstance, sinstance)) {
		gfxFree(pd);
 8001690:	4620      	mov	r0, r4
 8001692:	f000 fb35 	bl	8001d00 <chHeapFree>
 8001696:	e6ee      	b.n	8001476 <main+0x16>
 8001698:	4b12      	ldr	r3, [pc, #72]	; (80016e4 <main+0x284>)

	// Add it to the driver chain (at the end)
	if (dhead)
		dtail->driverchain = pd;
	else
		dhead = pd;
 800169a:	6014      	str	r4, [r2, #0]
 800169c:	e7f3      	b.n	8001686 <main+0x226>
 800169e:	bf00      	nop
 80016a0:	2000080c 	.word	0x2000080c
 80016a4:	08002944 	.word	0x08002944
 80016a8:	0800296c 	.word	0x0800296c
 80016ac:	08002924 	.word	0x08002924
 80016b0:	08002934 	.word	0x08002934
 80016b4:	08002954 	.word	0x08002954
 80016b8:	08002960 	.word	0x08002960
 80016bc:	08002980 	.word	0x08002980
 80016c0:	080029ac 	.word	0x080029ac
 80016c4:	080029b8 	.word	0x080029b8
 80016c8:	0800299c 	.word	0x0800299c
 80016cc:	08002994 	.word	0x08002994
 80016d0:	080029d4 	.word	0x080029d4
 80016d4:	080029cc 	.word	0x080029cc
 80016d8:	20000918 	.word	0x20000918
 80016dc:	080029ec 	.word	0x080029ec
 80016e0:	20000808 	.word	0x20000808
 80016e4:	20000804 	.word	0x20000804
	...

080016f0 <SVC_Handler>:
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 80016f0:	f3ef 8309 	mrs	r3, PSP
  \details Assigns the given value to the Process Stack Pointer (PSP).
  \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 80016f4:	3320      	adds	r3, #32
 80016f6:	f383 8809 	msr	PSP, r3
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 80016fa:	2300      	movs	r3, #0
 80016fc:	f383 8811 	msr	BASEPRI, r3
 8001700:	4770      	bx	lr
 8001702:	bf00      	nop
	...

08001710 <chCoreAllocAligned>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @api
 */
void *chCoreAllocAligned(size_t size, unsigned align) {
 8001710:	b430      	push	{r4, r5}
 8001712:	2320      	movs	r3, #32
 8001714:	f383 8811 	msr	BASEPRI, r3

  chDbgCheckClassI();
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));

  size = MEM_ALIGN_NEXT(size, align);
  p = (uint8_t *)MEM_ALIGN_NEXT(nextmem, align);
 8001718:	4d0b      	ldr	r5, [pc, #44]	; (8001748 <chCoreAllocAligned+0x38>)

  if (((size_t)endmem - (size_t)p) < size) {
 800171a:	4a0c      	ldr	r2, [pc, #48]	; (800174c <chCoreAllocAligned+0x3c>)

  chDbgCheckClassI();
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));

  size = MEM_ALIGN_NEXT(size, align);
  p = (uint8_t *)MEM_ALIGN_NEXT(nextmem, align);
 800171c:	682b      	ldr	r3, [r5, #0]
  uint8_t *p;

  chDbgCheckClassI();
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));

  size = MEM_ALIGN_NEXT(size, align);
 800171e:	1e4c      	subs	r4, r1, #1
  p = (uint8_t *)MEM_ALIGN_NEXT(nextmem, align);
 8001720:	3b01      	subs	r3, #1
 8001722:	440b      	add	r3, r1

  if (((size_t)endmem - (size_t)p) < size) {
 8001724:	6812      	ldr	r2, [r2, #0]
  uint8_t *p;

  chDbgCheckClassI();
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));

  size = MEM_ALIGN_NEXT(size, align);
 8001726:	4249      	negs	r1, r1
 8001728:	4404      	add	r4, r0
  p = (uint8_t *)MEM_ALIGN_NEXT(nextmem, align);
 800172a:	ea03 0001 	and.w	r0, r3, r1

  if (((size_t)endmem - (size_t)p) < size) {
 800172e:	1a13      	subs	r3, r2, r0
  uint8_t *p;

  chDbgCheckClassI();
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));

  size = MEM_ALIGN_NEXT(size, align);
 8001730:	4021      	ands	r1, r4
  p = (uint8_t *)MEM_ALIGN_NEXT(nextmem, align);

  if (((size_t)endmem - (size_t)p) < size) {
 8001732:	4299      	cmp	r1, r3
    return NULL;
  }
  nextmem = p + size;
 8001734:	bf9a      	itte	ls
 8001736:	1809      	addls	r1, r1, r0
 8001738:	6029      	strls	r1, [r5, #0]

  size = MEM_ALIGN_NEXT(size, align);
  p = (uint8_t *)MEM_ALIGN_NEXT(nextmem, align);

  if (((size_t)endmem - (size_t)p) < size) {
    return NULL;
 800173a:	2000      	movhi	r0, #0
 800173c:	2300      	movs	r3, #0
 800173e:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  p = chCoreAllocAlignedI(size, align);
  chSysUnlock();

  return p;
}
 8001742:	bc30      	pop	{r4, r5}
 8001744:	4770      	bx	lr
 8001746:	bf00      	nop
 8001748:	200008f0 	.word	0x200008f0
 800174c:	20000810 	.word	0x20000810

08001750 <wakeup>:
}

/*
 * Timeout wakeup callback.
 */
static void wakeup(void *p) {
 8001750:	b410      	push	{r4}
 8001752:	2320      	movs	r3, #32
 8001754:	f383 8811 	msr	BASEPRI, r3
  thread_t *tp = (thread_t *)p;

  chSysLockFromISR();
  switch (tp->state) {
 8001758:	f890 3020 	ldrb.w	r3, [r0, #32]
 800175c:	2b07      	cmp	r3, #7
 800175e:	d80e      	bhi.n	800177e <wakeup+0x2e>
 8001760:	e8df f003 	tbb	[pc, r3]
 8001764:	230d0d27 	.word	0x230d0d27
 8001768:	080d0408 	.word	0x080d0408
  case CH_STATE_SUSPENDED:
    *tp->u.wttrp = NULL;
    break;
#if CH_CFG_USE_SEMAPHORES == TRUE
  case CH_STATE_WTSEM:
    chSemFastSignalI(tp->u.wtsemp);
 800176c:	6a42      	ldr	r2, [r0, #36]	; 0x24
 */
static inline void chSemFastSignalI(semaphore_t *sp) {

  chDbgCheckClassI();

  sp->cnt++;
 800176e:	6893      	ldr	r3, [r2, #8]
 8001770:	3301      	adds	r3, #1
 8001772:	6093      	str	r3, [r2, #8]
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->queue.prev->queue.next = tp->queue.next;
 8001774:	e890 000c 	ldmia.w	r0, {r2, r3}
 8001778:	601a      	str	r2, [r3, #0]
  tp->queue.next->queue.prev = tp->queue.prev;
 800177a:	6802      	ldr	r2, [r0, #0]
 800177c:	6053      	str	r3, [r2, #4]
    break;
  default:
    /* Any other state, nothing to do.*/
    break;
  }
  tp->u.rdymsg = MSG_TIMEOUT;
 800177e:	f04f 34ff 	mov.w	r4, #4294967295
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 8001782:	2200      	movs	r2, #0
 8001784:	6881      	ldr	r1, [r0, #8]
  cp = (thread_t *)&ch.rlist.queue;
 8001786:	4b0d      	ldr	r3, [pc, #52]	; (80017bc <wakeup+0x6c>)
    break;
  default:
    /* Any other state, nothing to do.*/
    break;
  }
  tp->u.rdymsg = MSG_TIMEOUT;
 8001788:	6244      	str	r4, [r0, #36]	; 0x24
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 800178a:	f880 2020 	strb.w	r2, [r0, #32]
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
 800178e:	681b      	ldr	r3, [r3, #0]
  } while (cp->prio >= tp->prio);
 8001790:	689a      	ldr	r2, [r3, #8]
 8001792:	428a      	cmp	r2, r1
 8001794:	d2fb      	bcs.n	800178e <wakeup+0x3e>
  /* Insertion on prev.*/
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
 8001796:	685a      	ldr	r2, [r3, #4]
 8001798:	2100      	movs	r1, #0
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
  } while (cp->prio >= tp->prio);
  /* Insertion on prev.*/
  tp->queue.next             = cp;
 800179a:	6003      	str	r3, [r0, #0]
  tp->queue.prev             = cp->queue.prev;
 800179c:	6042      	str	r2, [r0, #4]
  tp->queue.prev->queue.next = tp;
 800179e:	6010      	str	r0, [r2, #0]
  cp->queue.prev             = tp;
 80017a0:	6058      	str	r0, [r3, #4]
 80017a2:	f381 8811 	msr	BASEPRI, r1
    break;
  }
  tp->u.rdymsg = MSG_TIMEOUT;
  (void) chSchReadyI(tp);
  chSysUnlockFromISR();
}
 80017a6:	bc10      	pop	{r4}
 80017a8:	4770      	bx	lr
    /* Handling the special case where the thread has been made ready by
       another thread with higher priority.*/
    chSysUnlockFromISR();
    return;
  case CH_STATE_SUSPENDED:
    *tp->u.wttrp = NULL;
 80017aa:	6a43      	ldr	r3, [r0, #36]	; 0x24
 80017ac:	2200      	movs	r2, #0
 80017ae:	601a      	str	r2, [r3, #0]
 80017b0:	e7e5      	b.n	800177e <wakeup+0x2e>
 80017b2:	2300      	movs	r3, #0
 80017b4:	f383 8811 	msr	BASEPRI, r3
    break;
  }
  tp->u.rdymsg = MSG_TIMEOUT;
  (void) chSchReadyI(tp);
  chSysUnlockFromISR();
}
 80017b8:	bc10      	pop	{r4}
 80017ba:	4770      	bx	lr
 80017bc:	20000918 	.word	0x20000918

080017c0 <_idle_thread>:
 *          that this thread is executed only if there are no other ready
 *          threads in the system.
 *
 * @param[in] p         the thread parameter, unused in this scenario
 */
static void _idle_thread(void *p) {
 80017c0:	e7fe      	b.n	80017c0 <_idle_thread>
 80017c2:	bf00      	nop
	...

080017d0 <chSchGoSleepS>:
 * @param[in] newstate  the new thread state
 *
 * @sclass
 */
void chSchGoSleepS(tstate_t newstate) {
  thread_t *otp = currp;
 80017d0:	4b08      	ldr	r3, [pc, #32]	; (80017f4 <chSchGoSleepS+0x24>)
 *
 * @param[in] newstate  the new thread state
 *
 * @sclass
 */
void chSchGoSleepS(tstate_t newstate) {
 80017d2:	b430      	push	{r4, r5}
  thread_t *otp = currp;
 80017d4:	6999      	ldr	r1, [r3, #24]
  tp->queue.prev->queue.next = tp;
  tqp->prev                  = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;
 80017d6:	681a      	ldr	r2, [r3, #0]

  chDbgCheckClassS();

  /* New state.*/
  otp->state = newstate;
 80017d8:	f881 0020 	strb.w	r0, [r1, #32]

  tqp->next             = tp->queue.next;
 80017dc:	6814      	ldr	r4, [r2, #0]
  otp->preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif

  /* Next thread in ready list becomes current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
  currp->state = CH_STATE_CURRENT;
 80017de:	2501      	movs	r5, #1
  tqp->next->queue.prev = (thread_t *)tqp;
 80017e0:	6063      	str	r3, [r4, #4]
 80017e2:	f882 5020 	strb.w	r5, [r2, #32]
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;

  tqp->next             = tp->queue.next;
 80017e6:	601c      	str	r4, [r3, #0]
  if (currp->prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 80017e8:	4610      	mov	r0, r2
}
 80017ea:	bc30      	pop	{r4, r5}
     time quantum when it will wakeup.*/
  otp->preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif

  /* Next thread in ready list becomes current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
 80017ec:	619a      	str	r2, [r3, #24]
  if (currp->prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 80017ee:	f7fe bd27 	b.w	8000240 <_port_switch>
 80017f2:	bf00      	nop
 80017f4:	20000918 	.word	0x20000918
	...

08001800 <halInit>:
 * @notapi
 */
void hal_lld_init(void) {

  /* Reset of all peripherals.*/
  rccResetAPB1(0xFFFFFFFF);
 8001800:	4a3d      	ldr	r2, [pc, #244]	; (80018f8 <halInit+0xf8>)
 *          board-specific initialization is performed by invoking
 *          @p boardInit() (usually defined in @p board.c).
 *
 * @init
 */
void halInit(void) {
 8001802:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8001804:	f04f 30ff 	mov.w	r0, #4294967295
 8001808:	2400      	movs	r4, #0
 800180a:	6915      	ldr	r5, [r2, #16]
 800180c:	6110      	str	r0, [r2, #16]
 800180e:	6114      	str	r4, [r2, #16]
  rccResetAPB2(0xFFFFFFFF);
 8001810:	68d5      	ldr	r5, [r2, #12]
 8001812:	60d0      	str	r0, [r2, #12]
 8001814:	60d4      	str	r4, [r2, #12]

  /* PWR and BD clocks enabled.*/
  rccEnablePWRInterface(FALSE);
 8001816:	69d0      	ldr	r0, [r2, #28]
 *          of the whole BKP domain.
 */
static void hal_lld_backup_domain_init(void) {

  /* Backup domain access enabled and left open.*/
  PWR->CR |= PWR_CR_DBP;
 8001818:	4e38      	ldr	r6, [pc, #224]	; (80018fc <halInit+0xfc>)
  /* Reset of all peripherals.*/
  rccResetAPB1(0xFFFFFFFF);
  rccResetAPB2(0xFFFFFFFF);

  /* PWR and BD clocks enabled.*/
  rccEnablePWRInterface(FALSE);
 800181a:	f040 5080 	orr.w	r0, r0, #268435456	; 0x10000000
 800181e:	61d0      	str	r0, [r2, #28]
  rccEnableBKPInterface(FALSE);
 8001820:	69d0      	ldr	r0, [r2, #28]
 * @init
 */
void dmaInit(void) {
  int i;

  dma_streams_mask = 0U;
 8001822:	4f37      	ldr	r7, [pc, #220]	; (8001900 <halInit+0x100>)
 8001824:	f040 6000 	orr.w	r0, r0, #134217728	; 0x8000000
 8001828:	61d0      	str	r0, [r2, #28]
 *          of the whole BKP domain.
 */
static void hal_lld_backup_domain_init(void) {

  /* Backup domain access enabled and left open.*/
  PWR->CR |= PWR_CR_DBP;
 800182a:	6835      	ldr	r5, [r6, #0]
  for (i = 0; i < STM32_DMA_STREAMS; i++) {
 800182c:	4623      	mov	r3, r4
 800182e:	f445 7580 	orr.w	r5, r5, #256	; 0x100
 8001832:	6035      	str	r5, [r6, #0]
    _stm32_dma_streams[i].channel->CCR = 0U;
 8001834:	4621      	mov	r1, r4
 8001836:	4a33      	ldr	r2, [pc, #204]	; (8001904 <halInit+0x104>)
 * @init
 */
void dmaInit(void) {
  int i;

  dma_streams_mask = 0U;
 8001838:	4833      	ldr	r0, [pc, #204]	; (8001908 <halInit+0x108>)
 800183a:	4d34      	ldr	r5, [pc, #208]	; (800190c <halInit+0x10c>)
 800183c:	603c      	str	r4, [r7, #0]
 800183e:	e001      	b.n	8001844 <halInit+0x44>
 8001840:	f852 0c14 	ldr.w	r0, [r2, #-20]
  for (i = 0; i < STM32_DMA_STREAMS; i++) {
    _stm32_dma_streams[i].channel->CCR = 0U;
 8001844:	6001      	str	r1, [r0, #0]
    _stm32_dma_isr_redir[i].dma_func = NULL;
 8001846:	f845 1033 	str.w	r1, [r5, r3, lsl #3]
 */
void dmaInit(void) {
  int i;

  dma_streams_mask = 0U;
  for (i = 0; i < STM32_DMA_STREAMS; i++) {
 800184a:	3301      	adds	r3, #1
 800184c:	2b07      	cmp	r3, #7
 800184e:	f102 0214 	add.w	r2, r2, #20
    _stm32_dma_streams[i].channel->CCR = 0U;
 8001852:	f04f 0400 	mov.w	r4, #0
 */
void dmaInit(void) {
  int i;

  dma_streams_mask = 0U;
  for (i = 0; i < STM32_DMA_STREAMS; i++) {
 8001856:	d1f3      	bne.n	8001840 <halInit+0x40>
    _stm32_dma_streams[i].channel->CCR = 0U;
    _stm32_dma_isr_redir[i].dma_func = NULL;
  }
  DMA1->IFCR = 0xFFFFFFFFU;
 8001858:	4a2d      	ldr	r2, [pc, #180]	; (8001910 <halInit+0x110>)
 800185a:	f04f 33ff 	mov.w	r3, #4294967295
void _pal_lld_init(const PALConfig *config) {

  /*
   * Enables the GPIO related clocks.
   */
  rccEnableAPB2(APB2_EN_MASK, FALSE);
 800185e:	4d26      	ldr	r5, [pc, #152]	; (80018f8 <halInit+0xf8>)
 8001860:	6053      	str	r3, [r2, #4]
 8001862:	69a8      	ldr	r0, [r5, #24]

  /*
   * Initial GPIO setup.
   */
  GPIOA->ODR = config->PAData.odr;
 8001864:	492b      	ldr	r1, [pc, #172]	; (8001914 <halInit+0x114>)
  GPIOA->CRH = config->PAData.crh;
 8001866:	4f2c      	ldr	r7, [pc, #176]	; (8001918 <halInit+0x118>)
  GPIOA->CRL = config->PAData.crl;
 8001868:	4e2c      	ldr	r6, [pc, #176]	; (800191c <halInit+0x11c>)
  GPIOB->ODR = config->PBData.odr;
  GPIOB->CRH = config->PBData.crh;
  GPIOB->CRL = config->PBData.crl;
 800186a:	f8df e0c4 	ldr.w	lr, [pc, #196]	; 8001930 <halInit+0x130>
void _pal_lld_init(const PALConfig *config) {

  /*
   * Enables the GPIO related clocks.
   */
  rccEnableAPB2(APB2_EN_MASK, FALSE);
 800186e:	f040 007d 	orr.w	r0, r0, #125	; 0x7d
   */
  GPIOA->ODR = config->PAData.odr;
  GPIOA->CRH = config->PAData.crh;
  GPIOA->CRL = config->PAData.crl;
  GPIOB->ODR = config->PBData.odr;
  GPIOB->CRH = config->PBData.crh;
 8001872:	f8df c0c0 	ldr.w	ip, [pc, #192]	; 8001934 <halInit+0x134>
void _pal_lld_init(const PALConfig *config) {

  /*
   * Enables the GPIO related clocks.
   */
  rccEnableAPB2(APB2_EN_MASK, FALSE);
 8001876:	61a8      	str	r0, [r5, #24]
   * Initial GPIO setup.
   */
  GPIOA->ODR = config->PAData.odr;
  GPIOA->CRH = config->PAData.crh;
  GPIOA->CRL = config->PAData.crl;
  GPIOB->ODR = config->PBData.odr;
 8001878:	f5a2 4274 	sub.w	r2, r2, #62464	; 0xf400
  rccEnableAPB2(APB2_EN_MASK, FALSE);

  /*
   * Initial GPIO setup.
   */
  GPIOA->ODR = config->PAData.odr;
 800187c:	60cb      	str	r3, [r1, #12]
  GPIOB->CRH = config->PBData.crh;
  GPIOB->CRL = config->PBData.crl;
  GPIOC->ODR = config->PCData.odr;
  GPIOC->CRH = config->PCData.crh;
  GPIOC->CRL = config->PCData.crl;
  GPIOD->ODR = config->PDData.odr;
 800187e:	4828      	ldr	r0, [pc, #160]	; (8001920 <halInit+0x120>)

  /*
   * Initial GPIO setup.
   */
  GPIOA->ODR = config->PAData.odr;
  GPIOA->CRH = config->PAData.crh;
 8001880:	604f      	str	r7, [r1, #4]
  GPIOA->CRL = config->PAData.crl;
 8001882:	600e      	str	r6, [r1, #0]
  GPIOB->ODR = config->PBData.odr;
  GPIOB->CRH = config->PBData.crh;
  GPIOB->CRL = config->PBData.crl;
  GPIOC->ODR = config->PCData.odr;
 8001884:	4e27      	ldr	r6, [pc, #156]	; (8001924 <halInit+0x124>)
   * Initial GPIO setup.
   */
  GPIOA->ODR = config->PAData.odr;
  GPIOA->CRH = config->PAData.crh;
  GPIOA->CRL = config->PAData.crl;
  GPIOB->ODR = config->PBData.odr;
 8001886:	60d3      	str	r3, [r2, #12]
  GPIOC->CRL = config->PCData.crl;
  GPIOD->ODR = config->PDData.odr;
  GPIOD->CRH = config->PDData.crh;
  GPIOD->CRL = config->PDData.crl;
#if STM32_HAS_GPIOE || defined(__DOXYGEN__)
  GPIOE->ODR = config->PEData.odr;
 8001888:	f501 5180 	add.w	r1, r1, #4096	; 0x1000
   */
  GPIOA->ODR = config->PAData.odr;
  GPIOA->CRH = config->PAData.crh;
  GPIOA->CRL = config->PAData.crl;
  GPIOB->ODR = config->PBData.odr;
  GPIOB->CRH = config->PBData.crh;
 800188c:	f8c2 c004 	str.w	ip, [r2, #4]
  GPIOC->ODR = config->PCData.odr;
  GPIOC->CRH = config->PCData.crh;
  GPIOC->CRL = config->PCData.crl;
  GPIOD->ODR = config->PDData.odr;
  GPIOD->CRH = config->PDData.crh;
  GPIOD->CRL = config->PDData.crl;
 8001890:	f507 7763 	add.w	r7, r7, #908	; 0x38c
  GPIOA->ODR = config->PAData.odr;
  GPIOA->CRH = config->PAData.crh;
  GPIOA->CRL = config->PAData.crl;
  GPIOB->ODR = config->PBData.odr;
  GPIOB->CRH = config->PBData.crh;
  GPIOB->CRL = config->PBData.crl;
 8001894:	f8c2 e000 	str.w	lr, [r2]
  GPIOC->ODR = config->PCData.odr;
  GPIOC->CRH = config->PCData.crh;
 8001898:	f04f 3288 	mov.w	r2, #2290649224	; 0x88888888
  GPIOA->CRH = config->PAData.crh;
  GPIOA->CRL = config->PAData.crl;
  GPIOB->ODR = config->PBData.odr;
  GPIOB->CRH = config->PBData.crh;
  GPIOB->CRL = config->PBData.crl;
  GPIOC->ODR = config->PCData.odr;
 800189c:	60f3      	str	r3, [r6, #12]
  GPIOC->CRH = config->PCData.crh;
 800189e:	6072      	str	r2, [r6, #4]
  GPIOC->CRL = config->PCData.crl;
 80018a0:	6032      	str	r2, [r6, #0]
  GPIOD->ODR = config->PDData.odr;
 80018a2:	60c3      	str	r3, [r0, #12]
  GPIOD->CRH = config->PDData.crh;
 80018a4:	6042      	str	r2, [r0, #4]
  GPIOD->CRL = config->PDData.crl;
 80018a6:	6007      	str	r7, [r0, #0]
#if STM32_HAS_GPIOE || defined(__DOXYGEN__)
  GPIOE->ODR = config->PEData.odr;
 80018a8:	60cb      	str	r3, [r1, #12]
  GPIOE->CRH = config->PEData.crh;
 80018aa:	604a      	str	r2, [r1, #4]
  GPIOE->CRL = config->PEData.crl;
 80018ac:	600a      	str	r2, [r1, #0]
 *
 * @init
 */
void i2cInit(void) {

  i2c_lld_init();
 80018ae:	f7ff fa87 	bl	8000dc0 <i2c_lld_init>
  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
 80018b2:	f64f 77ff 	movw	r7, #65535	; 0xffff

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 80018b6:	f648 4e9f 	movw	lr, #35999	; 0x8c9f

#if OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING
  /* Free running counter mode.*/

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();
 80018ba:	69eb      	ldr	r3, [r5, #28]

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();
 80018bc:	4e1a      	ldr	r6, [pc, #104]	; (8001928 <halInit+0x128>)

#if OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING
  /* Free running counter mode.*/

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();
 80018be:	f043 0301 	orr.w	r3, r3, #1
 80018c2:	61eb      	str	r3, [r5, #28]

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();
 80018c4:	6871      	ldr	r1, [r6, #4]

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 80018c6:	4a19      	ldr	r2, [pc, #100]	; (800192c <halInit+0x12c>)

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 80018c8:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();
 80018cc:	f441 6100 	orr.w	r1, r1, #2048	; 0x800
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
  STM32_ST_TIM->CCMR1  = 0;
  STM32_ST_TIM->CCR[0] = 0;
  STM32_ST_TIM->DIER   = 0;
  STM32_ST_TIM->CR2    = 0;
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
 80018d0:	2001      	movs	r0, #1
 80018d2:	2580      	movs	r5, #128	; 0x80

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();
 80018d4:	6071      	str	r1, [r6, #4]

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 80018d6:	f8c3 e028 	str.w	lr, [r3, #40]	; 0x28
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 80018da:	f04f 5180 	mov.w	r1, #268435456	; 0x10000000
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
 80018de:	62df      	str	r7, [r3, #44]	; 0x2c
  STM32_ST_TIM->CCMR1  = 0;
 80018e0:	619c      	str	r4, [r3, #24]
  STM32_ST_TIM->CCR[0] = 0;
 80018e2:	635c      	str	r4, [r3, #52]	; 0x34
  STM32_ST_TIM->DIER   = 0;
 80018e4:	60dc      	str	r4, [r3, #12]
  STM32_ST_TIM->CR2    = 0;
 80018e6:	605c      	str	r4, [r3, #4]
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
 80018e8:	6158      	str	r0, [r3, #20]
  STM32_ST_TIM->CR1    = TIM_CR1_CEN;
 80018ea:	6018      	str	r0, [r3, #0]

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 80018ec:	f882 531c 	strb.w	r5, [r2, #796]	; 0x31c
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 80018f0:	f8c2 1180 	str.w	r1, [r2, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 80018f4:	6011      	str	r1, [r2, #0]
 80018f6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80018f8:	40021000 	.word	0x40021000
 80018fc:	40007000 	.word	0x40007000
 8001900:	200009f8 	.word	0x200009f8
 8001904:	08002870 	.word	0x08002870
 8001908:	40020008 	.word	0x40020008
 800190c:	200009c0 	.word	0x200009c0
 8001910:	40020000 	.word	0x40020000
 8001914:	40010800 	.word	0x40010800
 8001918:	888884b8 	.word	0x888884b8
 800191c:	88884b88 	.word	0x88884b88
 8001920:	40011400 	.word	0x40011400
 8001924:	40011000 	.word	0x40011000
 8001928:	e0042000 	.word	0xe0042000
 800192c:	e000e100 	.word	0xe000e100
 8001930:	ff888838 	.word	0xff888838
 8001934:	88888838 	.word	0x88888838
	...

08001940 <_port_irq_epilogue>:
 8001940:	2320      	movs	r3, #32
 8001942:	f383 8811 	msr	BASEPRI, r3
 * @brief   Exception exit redirection to _port_switch_from_isr().
 */
void _port_irq_epilogue(void) {

  port_lock_from_isr();
  if ((SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) != 0U) {
 8001946:	4b0f      	ldr	r3, [pc, #60]	; (8001984 <_port_irq_epilogue+0x44>)
 8001948:	685b      	ldr	r3, [r3, #4]
 800194a:	f413 6300 	ands.w	r3, r3, #2048	; 0x800
 800194e:	d102      	bne.n	8001956 <_port_irq_epilogue+0x16>
 8001950:	f383 8811 	msr	BASEPRI, r3
 8001954:	4770      	bx	lr
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 8001956:	f3ef 8309 	mrs	r3, PSP
    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    ctxp--;

    /* Setting up a fake XPSR register value.*/
    ctxp->xpsr = (regarm_t)0x01000000;
 800195a:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
 800195e:	f843 2c04 	str.w	r2, [r3, #-4]
  \details Assigns the given value to the Process Stack Pointer (PSP).
  \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 8001962:	f1a3 0220 	sub.w	r2, r3, #32
 8001966:	f382 8809 	msr	PSP, r2
 * @retval false        if preemption is not required.
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {
  tprio_t p1 = firstprio(&ch.rlist.queue);
 800196a:	4a07      	ldr	r2, [pc, #28]	; (8001988 <_port_irq_epilogue+0x48>)
 800196c:	6811      	ldr	r1, [r2, #0]
  tprio_t p2 = currp->prio;
 800196e:	6992      	ldr	r2, [r2, #24]
    /* Writing back the modified PSP value.*/
    __set_PSP((uint32_t)ctxp);

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
 8001970:	6889      	ldr	r1, [r1, #8]
 8001972:	6892      	ldr	r2, [r2, #8]
 8001974:	4291      	cmp	r1, r2
      /* Preemption is required we need to enforce a context switch.*/
      ctxp->pc = (regarm_t)_port_switch_from_isr;
 8001976:	bf8c      	ite	hi
 8001978:	4a04      	ldrhi	r2, [pc, #16]	; (800198c <_port_irq_epilogue+0x4c>)
    }
    else {
      /* Preemption not required, we just need to exit the exception
         atomically.*/
      ctxp->pc = (regarm_t)_port_exit_from_isr;
 800197a:	4a05      	ldrls	r2, [pc, #20]	; (8001990 <_port_irq_epilogue+0x50>)
 800197c:	f843 2c08 	str.w	r2, [r3, #-8]
 8001980:	4770      	bx	lr
 8001982:	bf00      	nop
 8001984:	e000ed00 	.word	0xe000ed00
 8001988:	20000918 	.word	0x20000918
 800198c:	08000261 	.word	0x08000261
 8001990:	08000264 	.word	0x08000264
	...

080019a0 <chSchDoReschedule>:
 *          itself.
 *
 * @special
 */
void chSchDoRescheduleAhead(void) {
  thread_t *otp = currp;
 80019a0:	4a0e      	ldr	r2, [pc, #56]	; (80019dc <chSchDoReschedule+0x3c>)
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself.
 *
 * @special
 */
void chSchDoRescheduleAhead(void) {
 80019a2:	b430      	push	{r4, r5}
  tp->queue.prev->queue.next = tp;
  tqp->prev                  = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;
 80019a4:	6810      	ldr	r0, [r2, #0]
  thread_t *otp = currp;
 80019a6:	6994      	ldr	r4, [r2, #24]

  tqp->next             = tp->queue.next;
 80019a8:	6803      	ldr	r3, [r0, #0]

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
  currp->state = CH_STATE_CURRENT;
 80019aa:	2101      	movs	r1, #1
  tqp->next->queue.prev = (thread_t *)tqp;
 80019ac:	605a      	str	r2, [r3, #4]
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 80019ae:	2500      	movs	r5, #0
void chSchDoRescheduleAhead(void) {
  thread_t *otp = currp;

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
  currp->state = CH_STATE_CURRENT;
 80019b0:	f880 1020 	strb.w	r1, [r0, #32]
 80019b4:	68a1      	ldr	r1, [r4, #8]
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;

  tqp->next             = tp->queue.next;
 80019b6:	6013      	str	r3, [r2, #0]
 */
void chSchDoRescheduleAhead(void) {
  thread_t *otp = currp;

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
 80019b8:	6190      	str	r0, [r2, #24]
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 80019ba:	f884 5020 	strb.w	r5, [r4, #32]
 80019be:	e000      	b.n	80019c2 <chSchDoReschedule+0x22>
 80019c0:	681b      	ldr	r3, [r3, #0]
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
  } while (cp->prio > tp->prio);
 80019c2:	689a      	ldr	r2, [r3, #8]
 80019c4:	428a      	cmp	r2, r1
 80019c6:	d8fb      	bhi.n	80019c0 <chSchDoReschedule+0x20>
  /* Insertion on prev.*/
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
 80019c8:	685a      	ldr	r2, [r3, #4]

  /* Placing in ready list ahead of peers.*/
  otp = chSchReadyAheadI(otp);

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 80019ca:	4621      	mov	r1, r4
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
  } while (cp->prio > tp->prio);
  /* Insertion on prev.*/
  tp->queue.next             = cp;
 80019cc:	6023      	str	r3, [r4, #0]
  tp->queue.prev             = cp->queue.prev;
 80019ce:	6062      	str	r2, [r4, #4]
  tp->queue.prev->queue.next = tp;
 80019d0:	6014      	str	r4, [r2, #0]
  cp->queue.prev             = tp;
 80019d2:	605c      	str	r4, [r3, #4]
  /* Placing in ready list ahead of peers.*/
  otp = chSchReadyAheadI(otp);

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
}
 80019d4:	bc30      	pop	{r4, r5}

  /* Placing in ready list ahead of peers.*/
  otp = chSchReadyAheadI(otp);

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 80019d6:	f7fe bc33 	b.w	8000240 <_port_switch>
 80019da:	bf00      	nop
 80019dc:	20000918 	.word	0x20000918

080019e0 <chSchRescheduleS>:
 */
static inline bool chSchIsRescRequiredI(void) {

  chDbgCheckClassI();

  return firstprio(&ch.rlist.queue) > currp->prio;
 80019e0:	4b04      	ldr	r3, [pc, #16]	; (80019f4 <chSchRescheduleS+0x14>)
 80019e2:	681a      	ldr	r2, [r3, #0]
 80019e4:	699b      	ldr	r3, [r3, #24]
 */
void chSchRescheduleS(void) {

  chDbgCheckClassS();

  if (chSchIsRescRequiredI()) {
 80019e6:	6892      	ldr	r2, [r2, #8]
 80019e8:	689b      	ldr	r3, [r3, #8]
 80019ea:	429a      	cmp	r2, r3
 80019ec:	d800      	bhi.n	80019f0 <chSchRescheduleS+0x10>
 80019ee:	4770      	bx	lr
    chSchDoRescheduleAhead();
 80019f0:	f7ff bfd6 	b.w	80019a0 <chSchDoReschedule>
 80019f4:	20000918 	.word	0x20000918
	...

08001a00 <chThdSetPriority>:
 * @param[in] newprio   the new priority level of the running thread
 * @return              The old priority level.
 *
 * @api
 */
tprio_t chThdSetPriority(tprio_t newprio) {
 8001a00:	b510      	push	{r4, lr}
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8001a02:	2320      	movs	r3, #32
 8001a04:	f383 8811 	msr	BASEPRI, r3

  chDbgCheck(newprio <= HIGHPRIO);

  chSysLock();
#if CH_CFG_USE_MUTEXES == TRUE
  oldprio = currp->realprio;
 8001a08:	4b08      	ldr	r3, [pc, #32]	; (8001a2c <chThdSetPriority+0x2c>)
 8001a0a:	699b      	ldr	r3, [r3, #24]
 8001a0c:	6bdc      	ldr	r4, [r3, #60]	; 0x3c
  if ((currp->prio == currp->realprio) || (newprio > currp->prio)) {
 8001a0e:	6899      	ldr	r1, [r3, #8]
 8001a10:	428c      	cmp	r4, r1
 8001a12:	d001      	beq.n	8001a18 <chThdSetPriority+0x18>
 8001a14:	4281      	cmp	r1, r0
 8001a16:	d200      	bcs.n	8001a1a <chThdSetPriority+0x1a>
    currp->prio = newprio;
 8001a18:	6098      	str	r0, [r3, #8]
  }
  currp->realprio = newprio;
 8001a1a:	63d8      	str	r0, [r3, #60]	; 0x3c
#else
  oldprio = currp->prio;
  currp->prio = newprio;
#endif
  chSchRescheduleS();
 8001a1c:	f7ff ffe0 	bl	80019e0 <chSchRescheduleS>
 8001a20:	2300      	movs	r3, #0
 8001a22:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();

  return oldprio;
}
 8001a26:	4620      	mov	r0, r4
 8001a28:	bd10      	pop	{r4, pc}
 8001a2a:	bf00      	nop
 8001a2c:	20000918 	.word	0x20000918

08001a30 <chSchGoSleepTimeoutS>:
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t time) {

  chDbgCheckClassS();

  if (TIME_INFINITE != time) {
 8001a30:	f64f 73ff 	movw	r3, #65535	; 0xffff
 * @return              The wakeup message.
 * @retval MSG_TIMEOUT  if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t time) {
 8001a34:	b5f0      	push	{r4, r5, r6, r7, lr}

  chDbgCheckClassS();

  if (TIME_INFINITE != time) {
 8001a36:	4299      	cmp	r1, r3
 * @return              The wakeup message.
 * @retval MSG_TIMEOUT  if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t time) {
 8001a38:	b087      	sub	sp, #28

  chDbgCheckClassS();

  if (TIME_INFINITE != time) {
 8001a3a:	d051      	beq.n	8001ae0 <chSchGoSleepTimeoutS+0xb0>
    virtual_timer_t vt;

    chVTDoSetI(&vt, time, wakeup, currp);
 8001a3c:	4c49      	ldr	r4, [pc, #292]	; (8001b64 <chSchGoSleepTimeoutS+0x134>)
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 8001a3e:	f04f 4e80 	mov.w	lr, #1073741824	; 0x40000000
    if (delay < (systime_t)CH_CFG_ST_TIMEDELTA) {
      delay = (systime_t)CH_CFG_ST_TIMEDELTA;
    }

    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 8001a42:	4625      	mov	r5, r4
 8001a44:	f855 2f1c 	ldr.w	r2, [r5, #28]!
 8001a48:	f8de 3024 	ldr.w	r3, [lr, #36]	; 0x24
    systime_t now = chVTGetSystemTimeX();

    /* If the requested delay is lower than the minimum safe delta then it
       is raised to the minimum safe value.*/
    if (delay < (systime_t)CH_CFG_ST_TIMEDELTA) {
      delay = (systime_t)CH_CFG_ST_TIMEDELTA;
 8001a4c:	2901      	cmp	r1, #1
 8001a4e:	4606      	mov	r6, r0

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));

  vtp->par = par;
  vtp->func = vtfunc;
 8001a50:	4f45      	ldr	r7, [pc, #276]	; (8001b68 <chSchGoSleepTimeoutS+0x138>)
  systime_t delta;

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));

  vtp->par = par;
 8001a52:	69a0      	ldr	r0, [r4, #24]
    systime_t now = chVTGetSystemTimeX();

    /* If the requested delay is lower than the minimum safe delta then it
       is raised to the minimum safe value.*/
    if (delay < (systime_t)CH_CFG_ST_TIMEDELTA) {
      delay = (systime_t)CH_CFG_ST_TIMEDELTA;
 8001a54:	bf98      	it	ls
 8001a56:	2102      	movls	r1, #2
    }

    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 8001a58:	42aa      	cmp	r2, r5
  systime_t delta;

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));

  vtp->par = par;
 8001a5a:	9005      	str	r0, [sp, #20]
 8001a5c:	b29b      	uxth	r3, r3
  vtp->func = vtfunc;
 8001a5e:	9704      	str	r7, [sp, #16]
    if (delay < (systime_t)CH_CFG_ST_TIMEDELTA) {
      delay = (systime_t)CH_CFG_ST_TIMEDELTA;
    }

    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 8001a60:	d069      	beq.n	8001b36 <chSchGoSleepTimeoutS+0x106>
    /* Pointer to the first element in the delta list, which is non-empty.*/
    p = ch.vtlist.next;

    /* Delay as delta from 'lasttime'. Note, it can overflow and the value
       becomes lower than 'now'.*/
    delta = now - ch.vtlist.lasttime + delay;
 8001a62:	8ce0      	ldrh	r0, [r4, #38]	; 0x26
 8001a64:	1a1b      	subs	r3, r3, r0
 8001a66:	4419      	add	r1, r3
 8001a68:	b289      	uxth	r1, r1

    if (delta < now - ch.vtlist.lasttime) {
 8001a6a:	4299      	cmp	r1, r3
      /* Scenario where a very large delay excedeed the numeric range, it
         requires a special handling. We need to skip the first element and
         adjust the delta to wrap back in the previous numeric range.*/
      delta -= p->delta;
 8001a6c:	8913      	ldrh	r3, [r2, #8]

    /* Delay as delta from 'lasttime'. Note, it can overflow and the value
       becomes lower than 'now'.*/
    delta = now - ch.vtlist.lasttime + delay;

    if (delta < now - ch.vtlist.lasttime) {
 8001a6e:	db32      	blt.n	8001ad6 <chSchGoSleepTimeoutS+0xa6>
         requires a special handling. We need to skip the first element and
         adjust the delta to wrap back in the previous numeric range.*/
      delta -= p->delta;
      p = p->next;
    }
    else if (delta < p->delta) {
 8001a70:	4299      	cmp	r1, r3
 8001a72:	d33c      	bcc.n	8001aee <chSchGoSleepTimeoutS+0xbe>
  p = ch.vtlist.next;
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  while (p->delta < delta) {
 8001a74:	4299      	cmp	r1, r3
 8001a76:	d905      	bls.n	8001a84 <chSchGoSleepTimeoutS+0x54>
    delta -= p->delta;
    p = p->next;
 8001a78:	6812      	ldr	r2, [r2, #0]
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  while (p->delta < delta) {
    delta -= p->delta;
 8001a7a:	1ac9      	subs	r1, r1, r3
  p = ch.vtlist.next;
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  while (p->delta < delta) {
 8001a7c:	8913      	ldrh	r3, [r2, #8]
    delta -= p->delta;
 8001a7e:	b289      	uxth	r1, r1
  p = ch.vtlist.next;
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  while (p->delta < delta) {
 8001a80:	428b      	cmp	r3, r1
 8001a82:	d3f9      	bcc.n	8001a78 <chSchGoSleepTimeoutS+0x48>
  vtp->delta = delta

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/;
  p->delta -= delta;
  ch.vtlist.delta = (systime_t)-1;
 8001a84:	f64f 70ff 	movw	r0, #65535	; 0xffff
    p = p->next;
  }

  /* The timer is inserted in the delta list.*/
  vtp->next = p;
  vtp->prev = vtp->next->prev;
 8001a88:	6853      	ldr	r3, [r2, #4]
  vtp->prev->next = vtp;
 8001a8a:	af01      	add	r7, sp, #4
    p = p->next;
  }

  /* The timer is inserted in the delta list.*/
  vtp->next = p;
  vtp->prev = vtp->next->prev;
 8001a8c:	9302      	str	r3, [sp, #8]
    delta -= p->delta;
    p = p->next;
  }

  /* The timer is inserted in the delta list.*/
  vtp->next = p;
 8001a8e:	9201      	str	r2, [sp, #4]
  vtp->prev = vtp->next->prev;
  vtp->prev->next = vtp;
 8001a90:	601f      	str	r7, [r3, #0]
  p->prev = vtp;
 8001a92:	6057      	str	r7, [r2, #4]
  vtp->delta = delta
 8001a94:	f8ad 100c 	strh.w	r1, [sp, #12]

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/;
  p->delta -= delta;
 8001a98:	8913      	ldrh	r3, [r2, #8]
 8001a9a:	1a59      	subs	r1, r3, r1
 8001a9c:	8111      	strh	r1, [r2, #8]
  ch.vtlist.delta = (systime_t)-1;
 8001a9e:	84a0      	strh	r0, [r4, #36]	; 0x24
    chSchGoSleepS(newstate);
 8001aa0:	4630      	mov	r0, r6
 8001aa2:	f7ff fe95 	bl	80017d0 <chSchGoSleepS>
    if (chVTIsArmedI(&vt)) {
 8001aa6:	9b04      	ldr	r3, [sp, #16]
 8001aa8:	b18b      	cbz	r3, 8001ace <chSchGoSleepTimeoutS+0x9e>
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  systime_t nowdelta, delta;

  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (ch.vtlist.next != vtp) {
 8001aaa:	69e3      	ldr	r3, [r4, #28]
 8001aac:	4a2d      	ldr	r2, [pc, #180]	; (8001b64 <chSchGoSleepTimeoutS+0x134>)
 8001aae:	42bb      	cmp	r3, r7
 8001ab0:	d022      	beq.n	8001af8 <chSchGoSleepTimeoutS+0xc8>
    /* Removing the element from the delta list.*/
    vtp->prev->next = vtp->next;
 8001ab2:	9a02      	ldr	r2, [sp, #8]
 8001ab4:	9b01      	ldr	r3, [sp, #4]
    vtp->next->prev = vtp->prev;
    vtp->func = NULL;
 8001ab6:	2100      	movs	r1, #0

  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (ch.vtlist.next != vtp) {
    /* Removing the element from the delta list.*/
    vtp->prev->next = vtp->next;
 8001ab8:	6013      	str	r3, [r2, #0]
    vtp->next->prev = vtp->prev;
 8001aba:	9b01      	ldr	r3, [sp, #4]
    vtp->func = NULL;

    /* Adding delta to the next element, if it is not the last one.*/
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->next)
 8001abc:	42ab      	cmp	r3, r5
  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (ch.vtlist.next != vtp) {
    /* Removing the element from the delta list.*/
    vtp->prev->next = vtp->next;
    vtp->next->prev = vtp->prev;
 8001abe:	605a      	str	r2, [r3, #4]
    vtp->func = NULL;
 8001ac0:	9104      	str	r1, [sp, #16]

    /* Adding delta to the next element, if it is not the last one.*/
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->next)
 8001ac2:	d004      	beq.n	8001ace <chSchGoSleepTimeoutS+0x9e>
      vtp->next->delta += vtp->delta;
 8001ac4:	8919      	ldrh	r1, [r3, #8]
 8001ac6:	f8bd 200c 	ldrh.w	r2, [sp, #12]
 8001aca:	440a      	add	r2, r1
 8001acc:	811a      	strh	r2, [r3, #8]
  }
  else {
    chSchGoSleepS(newstate);
  }

  return currp->u.rdymsg;
 8001ace:	69a3      	ldr	r3, [r4, #24]
}
 8001ad0:	6a58      	ldr	r0, [r3, #36]	; 0x24
 8001ad2:	b007      	add	sp, #28
 8001ad4:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if (delta < now - ch.vtlist.lasttime) {
      /* Scenario where a very large delay excedeed the numeric range, it
         requires a special handling. We need to skip the first element and
         adjust the delta to wrap back in the previous numeric range.*/
      delta -= p->delta;
      p = p->next;
 8001ad6:	6812      	ldr	r2, [r2, #0]

    if (delta < now - ch.vtlist.lasttime) {
      /* Scenario where a very large delay excedeed the numeric range, it
         requires a special handling. We need to skip the first element and
         adjust the delta to wrap back in the previous numeric range.*/
      delta -= p->delta;
 8001ad8:	1ac9      	subs	r1, r1, r3
 8001ada:	b289      	uxth	r1, r1
 8001adc:	8913      	ldrh	r3, [r2, #8]
 8001ade:	e7c9      	b.n	8001a74 <chSchGoSleepTimeoutS+0x44>
    if (chVTIsArmedI(&vt)) {
      chVTDoResetI(&vt);
    }
  }
  else {
    chSchGoSleepS(newstate);
 8001ae0:	f7ff fe76 	bl	80017d0 <chSchGoSleepS>
 8001ae4:	4c1f      	ldr	r4, [pc, #124]	; (8001b64 <chSchGoSleepTimeoutS+0x134>)
  }

  return currp->u.rdymsg;
 8001ae6:	69a3      	ldr	r3, [r4, #24]
}
 8001ae8:	6a58      	ldr	r0, [r3, #36]	; 0x24
 8001aea:	b007      	add	sp, #28
 8001aec:	bdf0      	pop	{r4, r5, r6, r7, pc}
 *
 * @notapi
 */
static inline void st_lld_set_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8001aee:	4408      	add	r0, r1
 8001af0:	b280      	uxth	r0, r0
 8001af2:	f8ce 0034 	str.w	r0, [lr, #52]	; 0x34
 8001af6:	e7bd      	b.n	8001a74 <chSchGoSleepTimeoutS+0x44>

    return;
  }

  /* Removing the first timer from the list.*/
  ch.vtlist.next = vtp->next;
 8001af8:	9901      	ldr	r1, [sp, #4]
  ch.vtlist.next->prev = (virtual_timer_t *)&ch.vtlist;
  vtp->func = NULL;
 8001afa:	2300      	movs	r3, #0

  /* If the list become empty then the alarm timer is stopped and done.*/
  if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 8001afc:	42a9      	cmp	r1, r5

    return;
  }

  /* Removing the first timer from the list.*/
  ch.vtlist.next = vtp->next;
 8001afe:	61d1      	str	r1, [r2, #28]
  ch.vtlist.next->prev = (virtual_timer_t *)&ch.vtlist;
 8001b00:	604d      	str	r5, [r1, #4]
  vtp->func = NULL;
 8001b02:	9304      	str	r3, [sp, #16]

  /* If the list become empty then the alarm timer is stopped and done.*/
  if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 8001b04:	d02a      	beq.n	8001b5c <chSchGoSleepTimeoutS+0x12c>
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 8001b06:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
 8001b0a:	6a45      	ldr	r5, [r0, #36]	; 0x24
/*  if (ch.vtlist.next->delta == 0) {
    return;
  }*/

  /* Distance in ticks between the last alarm event and current time.*/
  nowdelta = chVTGetSystemTimeX() - ch.vtlist.lasttime;
 8001b0c:	8cd2      	ldrh	r2, [r2, #38]	; 0x26

    return;
  }

  /* The delta of the removed timer is added to the new first timer.*/
  ch.vtlist.next->delta += vtp->delta;
 8001b0e:	890e      	ldrh	r6, [r1, #8]
 8001b10:	f8bd 300c 	ldrh.w	r3, [sp, #12]
 8001b14:	b2ad      	uxth	r5, r5
/*  if (ch.vtlist.next->delta == 0) {
    return;
  }*/

  /* Distance in ticks between the last alarm event and current time.*/
  nowdelta = chVTGetSystemTimeX() - ch.vtlist.lasttime;
 8001b16:	1aaa      	subs	r2, r5, r2

    return;
  }

  /* The delta of the removed timer is added to the new first timer.*/
  ch.vtlist.next->delta += vtp->delta;
 8001b18:	4433      	add	r3, r6
 8001b1a:	b29b      	uxth	r3, r3
/*  if (ch.vtlist.next->delta == 0) {
    return;
  }*/

  /* Distance in ticks between the last alarm event and current time.*/
  nowdelta = chVTGetSystemTimeX() - ch.vtlist.lasttime;
 8001b1c:	b292      	uxth	r2, r2

  /* If the current time surpassed the time of the next element in list
     then the event interrupt is already pending, just return.*/
  if (nowdelta >= ch.vtlist.next->delta) {
 8001b1e:	4293      	cmp	r3, r2

    return;
  }

  /* The delta of the removed timer is added to the new first timer.*/
  ch.vtlist.next->delta += vtp->delta;
 8001b20:	810b      	strh	r3, [r1, #8]
  /* Distance in ticks between the last alarm event and current time.*/
  nowdelta = chVTGetSystemTimeX() - ch.vtlist.lasttime;

  /* If the current time surpassed the time of the next element in list
     then the event interrupt is already pending, just return.*/
  if (nowdelta >= ch.vtlist.next->delta) {
 8001b22:	d9d4      	bls.n	8001ace <chSchGoSleepTimeoutS+0x9e>
    return;
  }

  /* Distance from the next scheduled event and now.*/
  delta = ch.vtlist.next->delta - nowdelta;
 8001b24:	1a9a      	subs	r2, r3, r2
 8001b26:	b293      	uxth	r3, r2

  /* Making sure to not schedule an event closer than CH_CFG_ST_TIMEDELTA
     ticks from now.*/
  if (delta < (systime_t)CH_CFG_ST_TIMEDELTA) {
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
 8001b28:	2b01      	cmp	r3, #1
 8001b2a:	bf98      	it	ls
 8001b2c:	2302      	movls	r3, #2
 *
 * @notapi
 */
static inline void st_lld_set_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8001b2e:	442b      	add	r3, r5
 8001b30:	b29b      	uxth	r3, r3
 8001b32:	6343      	str	r3, [r0, #52]	; 0x34
 8001b34:	e7cb      	b.n	8001ace <chSchGoSleepTimeoutS+0x9e>
 *
 * @notapi
 */
static inline void st_lld_start_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8001b36:	185a      	adds	r2, r3, r1
    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {

      /* The delta list is empty, the current time becomes the new
         delta list base time, the timer is inserted.*/
      ch.vtlist.lasttime = now;
 8001b38:	84e3      	strh	r3, [r4, #38]	; 0x26
      ch.vtlist.next = vtp;
 8001b3a:	af01      	add	r7, sp, #4
 8001b3c:	b292      	uxth	r2, r2
  STM32_ST_TIM->SR     = 0;
 8001b3e:	2000      	movs	r0, #0
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 8001b40:	2302      	movs	r3, #2
      ch.vtlist.prev = vtp;
      vtp->next = (virtual_timer_t *)&ch.vtlist;
 8001b42:	9501      	str	r5, [sp, #4]
      vtp->prev = (virtual_timer_t *)&ch.vtlist;
 8001b44:	9502      	str	r5, [sp, #8]
      vtp->delta = delay;
 8001b46:	f8ad 100c 	strh.w	r1, [sp, #12]
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {

      /* The delta list is empty, the current time becomes the new
         delta list base time, the timer is inserted.*/
      ch.vtlist.lasttime = now;
      ch.vtlist.next = vtp;
 8001b4a:	61e7      	str	r7, [r4, #28]
      ch.vtlist.prev = vtp;
 8001b4c:	6227      	str	r7, [r4, #32]
 *
 * @notapi
 */
static inline void st_lld_start_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8001b4e:	f8ce 2034 	str.w	r2, [lr, #52]	; 0x34
  STM32_ST_TIM->SR     = 0;
 8001b52:	f8ce 0010 	str.w	r0, [lr, #16]
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 8001b56:	f8ce 300c 	str.w	r3, [lr, #12]
 8001b5a:	e7a1      	b.n	8001aa0 <chSchGoSleepTimeoutS+0x70>
 *
 * @notapi
 */
static inline void st_lld_stop_alarm(void) {

  STM32_ST_TIM->DIER = 0;
 8001b5c:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
 8001b60:	60d3      	str	r3, [r2, #12]
 8001b62:	e7b4      	b.n	8001ace <chSchGoSleepTimeoutS+0x9e>
 8001b64:	20000918 	.word	0x20000918
 8001b68:	08001751 	.word	0x08001751
 8001b6c:	00000000 	.word	0x00000000

08001b70 <chThdSleep>:
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *                      .
 *
 * @api
 */
void chThdSleep(systime_t time) {
 8001b70:	b508      	push	{r3, lr}
 8001b72:	4601      	mov	r1, r0
 8001b74:	2320      	movs	r3, #32
 8001b76:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chThdSleepS(systime_t time) {

  chDbgCheck(time != TIME_IMMEDIATE);

  (void) chSchGoSleepTimeoutS(CH_STATE_SLEEPING, time);
 8001b7a:	2008      	movs	r0, #8
 8001b7c:	f7ff ff58 	bl	8001a30 <chSchGoSleepTimeoutS>
 8001b80:	2300      	movs	r3, #0
 8001b82:	f383 8811 	msr	BASEPRI, r3
 8001b86:	bd08      	pop	{r3, pc}
	...

08001b90 <chSchReadyI>:
 * @param[in] tp        the thread to be made ready
 * @return              The thread pointer.
 *
 * @iclass
 */
thread_t *chSchReadyI(thread_t *tp) {
 8001b90:	b410      	push	{r4}
 8001b92:	4604      	mov	r4, r0
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 8001b94:	2200      	movs	r2, #0
 8001b96:	6881      	ldr	r1, [r0, #8]
  cp = (thread_t *)&ch.rlist.queue;
 8001b98:	4b07      	ldr	r3, [pc, #28]	; (8001bb8 <chSchReadyI+0x28>)
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 8001b9a:	f880 2020 	strb.w	r2, [r0, #32]
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
 8001b9e:	681b      	ldr	r3, [r3, #0]
  } while (cp->prio >= tp->prio);
 8001ba0:	689a      	ldr	r2, [r3, #8]
 8001ba2:	428a      	cmp	r2, r1
 8001ba4:	d2fb      	bcs.n	8001b9e <chSchReadyI+0xe>
  /* Insertion on prev.*/
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
 8001ba6:	685a      	ldr	r2, [r3, #4]
  tp->queue.prev->queue.next = tp;
  cp->queue.prev             = tp;

  return tp;
}
 8001ba8:	4620      	mov	r0, r4
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
  } while (cp->prio >= tp->prio);
  /* Insertion on prev.*/
  tp->queue.next             = cp;
 8001baa:	6023      	str	r3, [r4, #0]
  tp->queue.prev             = cp->queue.prev;
 8001bac:	6062      	str	r2, [r4, #4]
  tp->queue.prev->queue.next = tp;
 8001bae:	6014      	str	r4, [r2, #0]
  cp->queue.prev             = tp;
 8001bb0:	605c      	str	r4, [r3, #4]

  return tp;
}
 8001bb2:	bc10      	pop	{r4}
 8001bb4:	4770      	bx	lr
 8001bb6:	bf00      	nop
 8001bb8:	20000918 	.word	0x20000918
 8001bbc:	00000000 	.word	0x00000000

08001bc0 <chMtxUnlock>:
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @api
 */
void chMtxUnlock(mutex_t *mp) {
  thread_t *ctp = currp;
 8001bc0:	4b17      	ldr	r3, [pc, #92]	; (8001c20 <chMtxUnlock+0x60>)
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @api
 */
void chMtxUnlock(mutex_t *mp) {
 8001bc2:	b570      	push	{r4, r5, r6, lr}
  thread_t *ctp = currp;
 8001bc4:	699d      	ldr	r5, [r3, #24]
 8001bc6:	2320      	movs	r3, #32
 8001bc8:	f383 8811 	msr	BASEPRI, r3
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->next != (const thread_t *)tqp);
 8001bcc:	6804      	ldr	r4, [r0, #0]
    chDbgAssert(ctp->mtxlist == mp, "not next in list");

    /* Removes the top mutex from the thread's owned mutexes list and marks
       it as not owned. Note, it is assumed to be the same mutex passed as
       parameter of this function.*/
    ctp->mtxlist = mp->next;
 8001bce:	68c3      	ldr	r3, [r0, #12]

    /* If a thread is waiting on the mutex then the fun part begins.*/
    if (chMtxQueueNotEmptyS(mp)) {
 8001bd0:	4284      	cmp	r4, r0
    chDbgAssert(ctp->mtxlist == mp, "not next in list");

    /* Removes the top mutex from the thread's owned mutexes list and marks
       it as not owned. Note, it is assumed to be the same mutex passed as
       parameter of this function.*/
    ctp->mtxlist = mp->next;
 8001bd2:	63ab      	str	r3, [r5, #56]	; 0x38

    /* If a thread is waiting on the mutex then the fun part begins.*/
    if (chMtxQueueNotEmptyS(mp)) {
 8001bd4:	d01d      	beq.n	8001c12 <chMtxUnlock+0x52>
      thread_t *tp;

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->realprio;
 8001bd6:	6be9      	ldr	r1, [r5, #60]	; 0x3c
      lmp = ctp->mtxlist;
      while (lmp != NULL) {
 8001bd8:	b14b      	cbz	r3, 8001bee <chMtxUnlock+0x2e>
 8001bda:	681a      	ldr	r2, [r3, #0]
        /* If the highest priority thread waiting in the mutexes list has a
           greater priority than the current thread base priority then the
           final priority will have at least that priority.*/
        if (chMtxQueueNotEmptyS(lmp) &&
 8001bdc:	4293      	cmp	r3, r2
 8001bde:	d003      	beq.n	8001be8 <chMtxUnlock+0x28>
            (lmp->queue.next->prio > newprio)) {
 8001be0:	6892      	ldr	r2, [r2, #8]
 8001be2:	4291      	cmp	r1, r2
 8001be4:	bf38      	it	cc
 8001be6:	4611      	movcc	r1, r2
          newprio = lmp->queue.next->prio;
        }
        lmp = lmp->next;
 8001be8:	68db      	ldr	r3, [r3, #12]

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->realprio;
      lmp = ctp->mtxlist;
      while (lmp != NULL) {
 8001bea:	2b00      	cmp	r3, #0
 8001bec:	d1f5      	bne.n	8001bda <chMtxUnlock+0x1a>
 8001bee:	4603      	mov	r3, r0
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;

  tqp->next             = tp->queue.next;
 8001bf0:	6822      	ldr	r2, [r4, #0]
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->cnt = (cnt_t)1;
#endif
      tp = queue_fifo_remove(&mp->queue);
      mp->owner = tp;
      mp->next = tp->mtxlist;
 8001bf2:	6ba6      	ldr	r6, [r4, #56]	; 0x38

      /* Note, not using chSchWakeupS() becuase that function expects the
         current thread to have the higher or equal priority than the ones
         in the ready list. This is not necessarily true here because we
         just changed priority.*/
      (void) chSchReadyI(tp);
 8001bf4:	4620      	mov	r0, r4
        lmp = lmp->next;
      }

      /* Assigns to the current thread the highest priority among all the
         waiting threads.*/
      ctp->prio = newprio;
 8001bf6:	60a9      	str	r1, [r5, #8]
 8001bf8:	601a      	str	r2, [r3, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 8001bfa:	6053      	str	r3, [r2, #4]
         assigns the mutex to it.*/
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->cnt = (cnt_t)1;
#endif
      tp = queue_fifo_remove(&mp->queue);
      mp->owner = tp;
 8001bfc:	609c      	str	r4, [r3, #8]
      mp->next = tp->mtxlist;
 8001bfe:	60de      	str	r6, [r3, #12]
      tp->mtxlist = mp;
 8001c00:	63a3      	str	r3, [r4, #56]	; 0x38

      /* Note, not using chSchWakeupS() becuase that function expects the
         current thread to have the higher or equal priority than the ones
         in the ready list. This is not necessarily true here because we
         just changed priority.*/
      (void) chSchReadyI(tp);
 8001c02:	f7ff ffc5 	bl	8001b90 <chSchReadyI>
      chSchRescheduleS();
 8001c06:	f7ff feeb 	bl	80019e0 <chSchRescheduleS>
 8001c0a:	2300      	movs	r3, #0
 8001c0c:	f383 8811 	msr	BASEPRI, r3
 8001c10:	bd70      	pop	{r4, r5, r6, pc}
    }
    else {
      mp->owner = NULL;
 8001c12:	2300      	movs	r3, #0
 8001c14:	60a3      	str	r3, [r4, #8]
 8001c16:	2300      	movs	r3, #0
 8001c18:	f383 8811 	msr	BASEPRI, r3
 8001c1c:	bd70      	pop	{r4, r5, r6, pc}
 8001c1e:	bf00      	nop
 8001c20:	20000918 	.word	0x20000918
	...

08001c30 <chMtxLockS>:
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @sclass
 */
void chMtxLockS(mutex_t *mp) {
  thread_t *ctp = currp;
 8001c30:	4b30      	ldr	r3, [pc, #192]	; (8001cf4 <chMtxLockS+0xc4>)

  chDbgCheckClassS();
  chDbgCheck(mp != NULL);

  /* Is the mutex already locked? */
  if (mp->owner != NULL) {
 8001c32:	6882      	ldr	r2, [r0, #8]
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @sclass
 */
void chMtxLockS(mutex_t *mp) {
 8001c34:	b570      	push	{r4, r5, r6, lr}
  thread_t *ctp = currp;
 8001c36:	699c      	ldr	r4, [r3, #24]

  chDbgCheckClassS();
  chDbgCheck(mp != NULL);

  /* Is the mutex already locked? */
  if (mp->owner != NULL) {
 8001c38:	2a00      	cmp	r2, #0
 8001c3a:	d056      	beq.n	8001cea <chMtxLockS+0xba>
         priority of the running thread requesting the mutex.*/
      thread_t *tp = mp->owner;

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->prio < ctp->prio) {
 8001c3c:	68a1      	ldr	r1, [r4, #8]
 8001c3e:	6893      	ldr	r3, [r2, #8]
 8001c40:	4605      	mov	r5, r0
 8001c42:	4299      	cmp	r1, r3
 8001c44:	d907      	bls.n	8001c56 <chMtxLockS+0x26>
        /* Make priority of thread tp match the running thread's priority.*/
        tp->prio = ctp->prio;

        /* The following states need priority queues reordering.*/
        switch (tp->state) {
 8001c46:	f892 3020 	ldrb.w	r3, [r2, #32]

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->prio < ctp->prio) {
        /* Make priority of thread tp match the running thread's priority.*/
        tp->prio = ctp->prio;
 8001c4a:	6091      	str	r1, [r2, #8]

        /* The following states need priority queues reordering.*/
        switch (tp->state) {
 8001c4c:	2b06      	cmp	r3, #6
 8001c4e:	d033      	beq.n	8001cb8 <chMtxLockS+0x88>
 8001c50:	2b07      	cmp	r3, #7
 8001c52:	d01d      	beq.n	8001c90 <chMtxLockS+0x60>
 8001c54:	b19b      	cbz	r3, 8001c7e <chMtxLockS+0x4e>
  return tp;
}

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
 8001c56:	462b      	mov	r3, r5
 8001c58:	e003      	b.n	8001c62 <chMtxLockS+0x32>
  do {
    cp = cp->queue.next;
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 8001c5a:	6899      	ldr	r1, [r3, #8]
 8001c5c:	68a2      	ldr	r2, [r4, #8]
 8001c5e:	4291      	cmp	r1, r2
 8001c60:	d302      	bcc.n	8001c68 <chMtxLockS+0x38>

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->queue.next;
 8001c62:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 8001c64:	429d      	cmp	r5, r3
 8001c66:	d1f8      	bne.n	8001c5a <chMtxLockS+0x2a>
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
 8001c68:	685a      	ldr	r2, [r3, #4]

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->queue.next;
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
  tp->queue.next             = cp;
 8001c6a:	6023      	str	r3, [r4, #0]
  tp->queue.prev             = cp->queue.prev;
 8001c6c:	6062      	str	r2, [r4, #4]
  tp->queue.prev->queue.next = tp;
 8001c6e:	6014      	str	r4, [r2, #0]
  cp->queue.prev             = tp;
 8001c70:	605c      	str	r4, [r3, #4]
        break;
      }

      /* Sleep on the mutex.*/
      queue_prio_insert(ctp, &mp->queue);
      ctp->u.wtmtxp = mp;
 8001c72:	6265      	str	r5, [r4, #36]	; 0x24
      chSchGoSleepS(CH_STATE_WTMTX);
 8001c74:	2006      	movs	r0, #6
    /* It was not owned, inserted in the owned mutexes list.*/
    mp->owner = ctp;
    mp->next = ctp->mtxlist;
    ctp->mtxlist = mp;
  }
}
 8001c76:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
      }

      /* Sleep on the mutex.*/
      queue_prio_insert(ctp, &mp->queue);
      ctp->u.wtmtxp = mp;
      chSchGoSleepS(CH_STATE_WTMTX);
 8001c7a:	f7ff bda9 	b.w	80017d0 <chSchGoSleepS>
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->queue.prev->queue.next = tp->queue.next;
 8001c7e:	e892 000a 	ldmia.w	r2, {r1, r3}
 8001c82:	6019      	str	r1, [r3, #0]
#if CH_DBG_ENABLE_ASSERTS == TRUE
          /* Prevents an assertion in chSchReadyI().*/
          tp->state = CH_STATE_CURRENT;
#endif
          /* Re-enqueues tp with its new priority on the ready list.*/
          (void) chSchReadyI(queue_dequeue(tp));
 8001c84:	4610      	mov	r0, r2
  tp->queue.next->queue.prev = tp->queue.prev;
 8001c86:	6812      	ldr	r2, [r2, #0]
 8001c88:	6053      	str	r3, [r2, #4]
 8001c8a:	f7ff ff81 	bl	8001b90 <chSchReadyI>
 8001c8e:	e7e2      	b.n	8001c56 <chMtxLockS+0x26>
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->queue.prev->queue.next = tp->queue.next;
 8001c90:	e892 0009 	ldmia.w	r2, {r0, r3}
 8001c94:	6018      	str	r0, [r3, #0]
  tp->queue.next->queue.prev = tp->queue.prev;
 8001c96:	6810      	ldr	r0, [r2, #0]
 8001c98:	6043      	str	r3, [r0, #4]
#endif
#if (CH_CFG_USE_MESSAGES == TRUE) && (CH_CFG_USE_MESSAGES_PRIORITY == TRUE)
        case CH_STATE_SNDMSGQ:
#endif
          /* Re-enqueues tp with its new priority on the queue.*/
          queue_prio_insert(queue_dequeue(tp), &tp->u.wtmtxp->queue);
 8001c9a:	6a56      	ldr	r6, [r2, #36]	; 0x24
  return tp;
}

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
 8001c9c:	4633      	mov	r3, r6
 8001c9e:	e002      	b.n	8001ca6 <chMtxLockS+0x76>
  do {
    cp = cp->queue.next;
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 8001ca0:	6898      	ldr	r0, [r3, #8]
 8001ca2:	4281      	cmp	r1, r0
 8001ca4:	d802      	bhi.n	8001cac <chMtxLockS+0x7c>

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->queue.next;
 8001ca6:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 8001ca8:	429e      	cmp	r6, r3
 8001caa:	d1f9      	bne.n	8001ca0 <chMtxLockS+0x70>
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
 8001cac:	6859      	ldr	r1, [r3, #4]

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->queue.next;
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
  tp->queue.next             = cp;
 8001cae:	6013      	str	r3, [r2, #0]
  tp->queue.prev             = cp->queue.prev;
 8001cb0:	6051      	str	r1, [r2, #4]
  tp->queue.prev->queue.next = tp;
 8001cb2:	600a      	str	r2, [r1, #0]
  cp->queue.prev             = tp;
 8001cb4:	605a      	str	r2, [r3, #4]
 8001cb6:	e7ce      	b.n	8001c56 <chMtxLockS+0x26>
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->queue.prev->queue.next = tp->queue.next;
 8001cb8:	e892 0009 	ldmia.w	r2, {r0, r3}
 8001cbc:	6018      	str	r0, [r3, #0]
  tp->queue.next->queue.prev = tp->queue.prev;
 8001cbe:	6810      	ldr	r0, [r2, #0]
 8001cc0:	6043      	str	r3, [r0, #4]

        /* The following states need priority queues reordering.*/
        switch (tp->state) {
        case CH_STATE_WTMTX:
          /* Re-enqueues the mutex owner with its new priority.*/
          queue_prio_insert(queue_dequeue(tp), &tp->u.wtmtxp->queue);
 8001cc2:	6a56      	ldr	r6, [r2, #36]	; 0x24
  return tp;
}

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
 8001cc4:	4633      	mov	r3, r6
 8001cc6:	e002      	b.n	8001cce <chMtxLockS+0x9e>
  do {
    cp = cp->queue.next;
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 8001cc8:	6898      	ldr	r0, [r3, #8]
 8001cca:	4281      	cmp	r1, r0
 8001ccc:	d802      	bhi.n	8001cd4 <chMtxLockS+0xa4>

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->queue.next;
 8001cce:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 8001cd0:	429e      	cmp	r6, r3
 8001cd2:	d1f9      	bne.n	8001cc8 <chMtxLockS+0x98>
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
 8001cd4:	6859      	ldr	r1, [r3, #4]

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->queue.next;
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
  tp->queue.next             = cp;
 8001cd6:	6013      	str	r3, [r2, #0]
  tp->queue.prev             = cp->queue.prev;
 8001cd8:	6051      	str	r1, [r2, #4]
  tp->queue.prev->queue.next = tp;
 8001cda:	600a      	str	r2, [r1, #0]
  cp->queue.prev             = tp;
 8001cdc:	605a      	str	r2, [r3, #4]
          tp = tp->u.wtmtxp->owner;
 8001cde:	68b2      	ldr	r2, [r6, #8]
         priority of the running thread requesting the mutex.*/
      thread_t *tp = mp->owner;

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->prio < ctp->prio) {
 8001ce0:	68a1      	ldr	r1, [r4, #8]
 8001ce2:	6893      	ldr	r3, [r2, #8]
 8001ce4:	428b      	cmp	r3, r1
 8001ce6:	d3ae      	bcc.n	8001c46 <chMtxLockS+0x16>
 8001ce8:	e7b5      	b.n	8001c56 <chMtxLockS+0x26>

    mp->cnt++;
#endif
    /* It was not owned, inserted in the owned mutexes list.*/
    mp->owner = ctp;
    mp->next = ctp->mtxlist;
 8001cea:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    chDbgAssert(mp->cnt == (cnt_t)0, "counter is not zero");

    mp->cnt++;
#endif
    /* It was not owned, inserted in the owned mutexes list.*/
    mp->owner = ctp;
 8001cec:	6084      	str	r4, [r0, #8]
    mp->next = ctp->mtxlist;
 8001cee:	60c3      	str	r3, [r0, #12]
    ctp->mtxlist = mp;
 8001cf0:	63a0      	str	r0, [r4, #56]	; 0x38
 8001cf2:	bd70      	pop	{r4, r5, r6, pc}
 8001cf4:	20000918 	.word	0x20000918
	...

08001d00 <chHeapFree>:
 *
 * @param[in] p         pointer to the memory block to be freed
 *
 * @api
 */
void chHeapFree(void *p) {
 8001d00:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  /*lint -restore*/
  heapp = H_HEAP(hp);
  qp = &heapp->header;

  /* Size is converted in number of elementary allocation units.*/
  H_PAGES(hp) = MEM_ALIGN_NEXT(H_SIZE(hp),
 8001d02:	f850 3c04 	ldr.w	r3, [r0, #-4]
  chDbgCheck((p != NULL) && MEM_IS_ALIGNED(p, CH_HEAP_ALIGNMENT));

  /*lint -save -e9087 [11.3] Safe cast.*/
  hp = (heap_header_t *)p - 1U;
  /*lint -restore*/
  heapp = H_HEAP(hp);
 8001d06:	f850 7c08 	ldr.w	r7, [r0, #-8]
  qp = &heapp->header;

  /* Size is converted in number of elementary allocation units.*/
  H_PAGES(hp) = MEM_ALIGN_NEXT(H_SIZE(hp),
 8001d0a:	3307      	adds	r3, #7
 8001d0c:	08db      	lsrs	r3, r3, #3
 8001d0e:	f840 3c04 	str.w	r3, [r0, #-4]

  /*lint -save -e9087 [11.3] Safe cast.*/
  hp = (heap_header_t *)p - 1U;
  /*lint -restore*/
  heapp = H_HEAP(hp);
  qp = &heapp->header;
 8001d12:	f107 0508 	add.w	r5, r7, #8
 *
 * @param[in] p         pointer to the memory block to be freed
 *
 * @api
 */
void chHeapFree(void *p) {
 8001d16:	4606      	mov	r6, r0
  /* Size is converted in number of elementary allocation units.*/
  H_PAGES(hp) = MEM_ALIGN_NEXT(H_SIZE(hp),
                               CH_HEAP_ALIGNMENT) / CH_HEAP_ALIGNMENT;

  /* Taking heap mutex/semaphore.*/
  H_LOCK(heapp);
 8001d18:	3710      	adds	r7, #16
  memory_heap_t *heapp;

  chDbgCheck((p != NULL) && MEM_IS_ALIGNED(p, CH_HEAP_ALIGNMENT));

  /*lint -save -e9087 [11.3] Safe cast.*/
  hp = (heap_header_t *)p - 1U;
 8001d1a:	f1a0 0408 	sub.w	r4, r0, #8
 8001d1e:	2320      	movs	r3, #32
 8001d20:	f383 8811 	msr	BASEPRI, r3
 * @api
 */
void chMtxLock(mutex_t *mp) {

  chSysLock();
  chMtxLockS(mp);
 8001d24:	4638      	mov	r0, r7
 8001d26:	f7ff ff83 	bl	8001c30 <chMtxLockS>
 8001d2a:	2300      	movs	r3, #0
 8001d2c:	f383 8811 	msr	BASEPRI, r3
  /*lint -restore*/
  heapp = H_HEAP(hp);
  qp = &heapp->header;
 8001d30:	462b      	mov	r3, r5
  H_LOCK(heapp);

  while (true) {
    chDbgAssert((hp < qp) || (hp >= H_LIMIT(qp)), "within free block");

    if (((qp == &heapp->header) || (hp > qp)) &&
 8001d32:	42ab      	cmp	r3, r5
 8001d34:	d004      	beq.n	8001d40 <chHeapFree+0x40>
 8001d36:	42a3      	cmp	r3, r4
 8001d38:	d302      	bcc.n	8001d40 <chHeapFree+0x40>
 8001d3a:	681b      	ldr	r3, [r3, #0]
 8001d3c:	42ab      	cmp	r3, r5
 8001d3e:	d1fa      	bne.n	8001d36 <chHeapFree+0x36>
        ((H_NEXT(qp) == NULL) || (hp < H_NEXT(qp)))) {
 8001d40:	681a      	ldr	r2, [r3, #0]
  H_LOCK(heapp);

  while (true) {
    chDbgAssert((hp < qp) || (hp >= H_LIMIT(qp)), "within free block");

    if (((qp == &heapp->header) || (hp > qp)) &&
 8001d42:	b11a      	cbz	r2, 8001d4c <chHeapFree+0x4c>
        ((H_NEXT(qp) == NULL) || (hp < H_NEXT(qp)))) {
 8001d44:	4294      	cmp	r4, r2
 8001d46:	d301      	bcc.n	8001d4c <chHeapFree+0x4c>
 8001d48:	4613      	mov	r3, r2
 8001d4a:	e7f2      	b.n	8001d32 <chHeapFree+0x32>
      /* Insertion after qp.*/
      H_NEXT(hp) = H_NEXT(qp);
 8001d4c:	f846 2c08 	str.w	r2, [r6, #-8]
      H_NEXT(qp) = hp;
 8001d50:	601c      	str	r4, [r3, #0]
      /* Verifies if the newly inserted block should be merged.*/
      if (H_LIMIT(hp) == H_NEXT(hp)) {
 8001d52:	f856 1c04 	ldr.w	r1, [r6, #-4]
 8001d56:	f856 5c08 	ldr.w	r5, [r6, #-8]
 8001d5a:	1c4a      	adds	r2, r1, #1
 8001d5c:	eb04 00c2 	add.w	r0, r4, r2, lsl #3
 8001d60:	42a8      	cmp	r0, r5
 8001d62:	d00a      	beq.n	8001d7a <chHeapFree+0x7a>
        /* Merge with the next block.*/
        H_PAGES(hp) += H_PAGES(H_NEXT(hp)) + 1U;
        H_NEXT(hp) = H_NEXT(H_NEXT(hp));
      }
      if ((H_LIMIT(qp) == hp)) {
 8001d64:	6859      	ldr	r1, [r3, #4]
 8001d66:	1c4a      	adds	r2, r1, #1
 8001d68:	eb03 02c2 	add.w	r2, r3, r2, lsl #3
 8001d6c:	4294      	cmp	r4, r2
 8001d6e:	d00e      	beq.n	8001d8e <chHeapFree+0x8e>
    }
    qp = H_NEXT(qp);
  }

  /* Releasing heap mutex/semaphore.*/
  H_UNLOCK(heapp);
 8001d70:	4638      	mov	r0, r7

  return;
}
 8001d72:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    }
    qp = H_NEXT(qp);
  }

  /* Releasing heap mutex/semaphore.*/
  H_UNLOCK(heapp);
 8001d76:	f7ff bf23 	b.w	8001bc0 <chMtxUnlock>
      H_NEXT(hp) = H_NEXT(qp);
      H_NEXT(qp) = hp;
      /* Verifies if the newly inserted block should be merged.*/
      if (H_LIMIT(hp) == H_NEXT(hp)) {
        /* Merge with the next block.*/
        H_PAGES(hp) += H_PAGES(H_NEXT(hp)) + 1U;
 8001d7a:	6840      	ldr	r0, [r0, #4]
 8001d7c:	4401      	add	r1, r0
 8001d7e:	3101      	adds	r1, #1
 8001d80:	f846 1c04 	str.w	r1, [r6, #-4]
        H_NEXT(hp) = H_NEXT(H_NEXT(hp));
 8001d84:	f854 2032 	ldr.w	r2, [r4, r2, lsl #3]
 8001d88:	f846 2c08 	str.w	r2, [r6, #-8]
 8001d8c:	e7ea      	b.n	8001d64 <chHeapFree+0x64>
      }
      if ((H_LIMIT(qp) == hp)) {
        /* Merge with the previous block.*/
        H_PAGES(qp) += H_PAGES(hp) + 1U;
 8001d8e:	f856 2c04 	ldr.w	r2, [r6, #-4]
 8001d92:	440a      	add	r2, r1
 8001d94:	3201      	adds	r2, #1
 8001d96:	605a      	str	r2, [r3, #4]
        H_NEXT(qp) = H_NEXT(hp);
 8001d98:	f856 2c08 	ldr.w	r2, [r6, #-8]
 8001d9c:	601a      	str	r2, [r3, #0]
 8001d9e:	e7e7      	b.n	8001d70 <chHeapFree+0x70>

08001da0 <chThdExit>:
 *
 * @param[in] msg       thread exit code
 *
 * @api
 */
void chThdExit(msg_t msg) {
 8001da0:	b538      	push	{r3, r4, r5, lr}
 8001da2:	2220      	movs	r2, #32
 8001da4:	4603      	mov	r3, r0
 8001da6:	f382 8811 	msr	BASEPRI, r2
 * @param[in] msg       thread exit code
 *
 * @sclass
 */
void chThdExitS(msg_t msg) {
  thread_t *tp = currp;
 8001daa:	4a10      	ldr	r2, [pc, #64]	; (8001dec <chThdExit+0x4c>)
 8001dac:	6994      	ldr	r4, [r2, #24]
 *
 * @notapi
 */
static inline bool list_notempty(threads_list_t *tlp) {

  return (bool)(tlp->next != (thread_t *)tlp);
 8001dae:	6aa0      	ldr	r0, [r4, #40]	; 0x28
  /* Exit handler hook.*/
  CH_CFG_THREAD_EXIT_HOOK(tp);

#if CH_CFG_USE_WAITEXIT == TRUE
  /* Waking up any waiting thread.*/
  while (list_notempty(&tp->waiting)) {
 8001db0:	f104 0528 	add.w	r5, r4, #40	; 0x28
 8001db4:	4285      	cmp	r5, r0
 */
void chThdExitS(msg_t msg) {
  thread_t *tp = currp;

  /* Storing exit message.*/
  tp->u.exitcode = msg;
 8001db6:	6263      	str	r3, [r4, #36]	; 0x24
  /* Exit handler hook.*/
  CH_CFG_THREAD_EXIT_HOOK(tp);

#if CH_CFG_USE_WAITEXIT == TRUE
  /* Waking up any waiting thread.*/
  while (list_notempty(&tp->waiting)) {
 8001db8:	d006      	beq.n	8001dc8 <chThdExit+0x28>
}

static inline thread_t *list_remove(threads_list_t *tlp) {

  thread_t *tp = tlp->next;
  tlp->next = tp->queue.next;
 8001dba:	6803      	ldr	r3, [r0, #0]
 8001dbc:	62a3      	str	r3, [r4, #40]	; 0x28
    (void) chSchReadyI(list_remove(&tp->waiting));
 8001dbe:	f7ff fee7 	bl	8001b90 <chSchReadyI>
 *
 * @notapi
 */
static inline bool list_notempty(threads_list_t *tlp) {

  return (bool)(tlp->next != (thread_t *)tlp);
 8001dc2:	6aa0      	ldr	r0, [r4, #40]	; 0x28
  /* Exit handler hook.*/
  CH_CFG_THREAD_EXIT_HOOK(tp);

#if CH_CFG_USE_WAITEXIT == TRUE
  /* Waking up any waiting thread.*/
  while (list_notempty(&tp->waiting)) {
 8001dc4:	42a8      	cmp	r0, r5
 8001dc6:	d1f8      	bne.n	8001dba <chThdExit+0x1a>

#if CH_CFG_USE_REGISTRY == TRUE
  /* Static threads with no references are immediately removed from the
     registry because there is no memory to recover.*/
#if CH_CFG_USE_DYNAMIC == TRUE
  if ((tp->refs == (trefs_t)0) &&
 8001dc8:	f894 3022 	ldrb.w	r3, [r4, #34]	; 0x22
 8001dcc:	b943      	cbnz	r3, 8001de0 <chThdExit+0x40>
 8001dce:	f894 3021 	ldrb.w	r3, [r4, #33]	; 0x21
 8001dd2:	079b      	lsls	r3, r3, #30
 8001dd4:	d104      	bne.n	8001de0 <chThdExit+0x40>
      ((tp->flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC)) {
    REG_REMOVE(tp);
 8001dd6:	6922      	ldr	r2, [r4, #16]
 8001dd8:	6963      	ldr	r3, [r4, #20]
 8001dda:	611a      	str	r2, [r3, #16]
 8001ddc:	6922      	ldr	r2, [r4, #16]
 8001dde:	6153      	str	r3, [r2, #20]
  }
#endif
#endif

  /* Going into final state.*/
  chSchGoSleepS(CH_STATE_FINAL);
 8001de0:	200f      	movs	r0, #15
void chThdExit(msg_t msg) {

  chSysLock();
  chThdExitS(msg);
  /* The thread never returns here.*/
}
 8001de2:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  }
#endif
#endif

  /* Going into final state.*/
  chSchGoSleepS(CH_STATE_FINAL);
 8001de6:	f7ff bcf3 	b.w	80017d0 <chSchGoSleepS>
 8001dea:	bf00      	nop
 8001dec:	20000918 	.word	0x20000918

08001df0 <chSysInit>:
 */
void _vt_init(void) {

  ch.vtlist.next = (virtual_timer_t *)&ch.vtlist;
  ch.vtlist.prev = (virtual_timer_t *)&ch.vtlist;
  ch.vtlist.delta = (systime_t)-1;
 8001df0:	f64f 70ff 	movw	r0, #65535	; 0xffff
 * @post    The main thread is created with priority @p NORMALPRIO and
 *          interrupts are enabled.
 *
 * @special
 */
void chSysInit(void) {
 8001df4:	b5f0      	push	{r4, r5, r6, r7, lr}
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 8001df6:	f64f 05ff 	movw	r5, #63743	; 0xf8ff
 *
 * @notapi
 */
void _heap_init(void) {

  default_heap.provider = chCoreAllocAligned;
 8001dfa:	4a4f      	ldr	r2, [pc, #316]	; (8001f38 <chSysInit+0x148>)
 8001dfc:	4e4f      	ldr	r6, [pc, #316]	; (8001f3c <chSysInit+0x14c>)
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  /*lint -save -e9033 [10.8] Required cast operations.*/
  nextmem = __heap_base__;
 8001dfe:	4c50      	ldr	r4, [pc, #320]	; (8001f40 <chSysInit+0x150>)
 8001e00:	4f50      	ldr	r7, [pc, #320]	; (8001f44 <chSysInit+0x154>)
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8001e02:	4b51      	ldr	r3, [pc, #324]	; (8001f48 <chSysInit+0x158>)
 8001e04:	6016      	str	r6, [r2, #0]
  endmem  = __heap_end__;
 8001e06:	4951      	ldr	r1, [pc, #324]	; (8001f4c <chSysInit+0x15c>)
 8001e08:	4e51      	ldr	r6, [pc, #324]	; (8001f50 <chSysInit+0x160>)
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  /*lint -save -e9033 [10.8] Required cast operations.*/
  nextmem = __heap_base__;
 8001e0a:	6027      	str	r7, [r4, #0]
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
  tp->name      = name;
 8001e0c:	4f51      	ldr	r7, [pc, #324]	; (8001f54 <chSysInit+0x164>)
__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8001e0e:	4c52      	ldr	r4, [pc, #328]	; (8001f58 <chSysInit+0x168>)
  endmem  = __heap_end__;
 8001e10:	600e      	str	r6, [r1, #0]
 8001e12:	8498      	strh	r0, [r3, #36]	; 0x24
 *
 * @notapi
 */
void _vt_init(void) {

  ch.vtlist.next = (virtual_timer_t *)&ch.vtlist;
 8001e14:	f103 011c 	add.w	r1, r3, #28
  REG_INSERT(tp);
 8001e18:	f103 002c 	add.w	r0, r3, #44	; 0x2c
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {

  tlp->next = (thread_t *)tlp;
 8001e1c:	f103 0654 	add.w	r6, r3, #84	; 0x54
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
  tp->name      = name;
 8001e20:	645f      	str	r7, [r3, #68]	; 0x44
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8001e22:	f103 0e58 	add.w	lr, r3, #88	; 0x58
 8001e26:	f102 0710 	add.w	r7, r2, #16
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {

  tlp->next = (thread_t *)tlp;
 8001e2a:	655e      	str	r6, [r3, #84]	; 0x54
 8001e2c:	61d9      	str	r1, [r3, #28]
  ch.vtlist.prev = (virtual_timer_t *)&ch.vtlist;
 8001e2e:	6219      	str	r1, [r3, #32]
  REG_INSERT(tp);
 8001e30:	6118      	str	r0, [r3, #16]
 * @notapi
 */
void _scheduler_init(void) {

  queue_init(&ch.rlist.queue);
  ch.rlist.prio = NOPRIO;
 8001e32:	2100      	movs	r1, #0
 8001e34:	6158      	str	r0, [r3, #20]
#endif

#if CH_CFG_NO_IDLE_THREAD == FALSE
  /* Now this instructions flow becomes the main thread.*/
#if CH_CFG_USE_REGISTRY == TRUE
  currp = _thread_init(&ch.mainthread, (const char *)&ch_debug, NORMALPRIO);
 8001e36:	6198      	str	r0, [r3, #24]
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->prio      = prio;
 8001e38:	2680      	movs	r6, #128	; 0x80
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
 8001e3a:	2001      	movs	r0, #1
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8001e3c:	6117      	str	r7, [r2, #16]
  tqp->prev = (thread_t *)tqp;
 8001e3e:	6157      	str	r7, [r2, #20]
  H_NEXT(&default_heap.header) = NULL;
 8001e40:	6091      	str	r1, [r2, #8]
  H_PAGES(&default_heap.header) = 0;
 8001e42:	60d1      	str	r1, [r2, #12]
void chMtxObjectInit(mutex_t *mp) {

  chDbgCheck(mp != NULL);

  queue_init(&mp->queue);
  mp->owner = NULL;
 8001e44:	6191      	str	r1, [r2, #24]
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->prio      = prio;
 8001e46:	635e      	str	r6, [r3, #52]	; 0x34
  tp->flags     = CH_FLAG_MODE_STATIC;
#if CH_CFG_TIME_QUANTUM > 0
  tp->preempt   = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->realprio  = prio;
 8001e48:	669e      	str	r6, [r3, #104]	; 0x68
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8001e4a:	601b      	str	r3, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 8001e4c:	605b      	str	r3, [r3, #4]
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
  tp->name      = name;
  REG_INSERT(tp);
 8001e4e:	63db      	str	r3, [r3, #60]	; 0x3c
 8001e50:	641b      	str	r3, [r3, #64]	; 0x40
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8001e52:	f8c3 e058 	str.w	lr, [r3, #88]	; 0x58
  tqp->prev = (thread_t *)tqp;
 8001e56:	f8c3 e05c 	str.w	lr, [r3, #92]	; 0x5c
 8001e5a:	6099      	str	r1, [r3, #8]
  ch.vtlist.delta = (systime_t)-1;
#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.systime = (systime_t)0;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  ch.vtlist.lasttime = (systime_t)0;
 8001e5c:	84d9      	strh	r1, [r3, #38]	; 0x26
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->prio      = prio;
  tp->state     = CH_STATE_WTSTART;
  tp->flags     = CH_FLAG_MODE_STATIC;
 8001e5e:	f883 104d 	strb.w	r1, [r3, #77]	; 0x4d
#if CH_CFG_TIME_QUANTUM > 0
  tp->preempt   = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->realprio  = prio;
  tp->mtxlist   = NULL;
 8001e62:	6659      	str	r1, [r3, #100]	; 0x64
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->epending  = (eventmask_t)0;
 8001e64:	6619      	str	r1, [r3, #96]	; 0x60
       symbol must be provided externally.*/
    extern stkalign_t __main_thread_stack_base__;
    currp->wabase = &__main_thread_stack_base__;
  }
#elif CH_CFG_USE_DYNAMIC == TRUE
  currp->wabase = NULL;
 8001e66:	6499      	str	r1, [r3, #72]	; 0x48
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
 8001e68:	f883 004e 	strb.w	r0, [r3, #78]	; 0x4e
#endif

  /* Setting up the caller as current thread.*/
  currp->state = CH_STATE_CURRENT;
 8001e6c:	f883 004c 	strb.w	r0, [r3, #76]	; 0x4c
 8001e70:	68e6      	ldr	r6, [r4, #12]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
  reg_value  =  (reg_value                                   |
 8001e72:	4a3a      	ldr	r2, [pc, #232]	; (8001f5c <chSysInit+0x16c>)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 8001e74:	4035      	ands	r5, r6
  reg_value  =  (reg_value                                   |
 8001e76:	432a      	orrs	r2, r5

  /* Initializing priority grouping.*/
  NVIC_SetPriorityGrouping(CORTEX_PRIGROUP_INIT);

  /* DWT cycle counter enable, note, the M7 requires DWT unlocking.*/
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
 8001e78:	4d39      	ldr	r5, [pc, #228]	; (8001f60 <chSysInit+0x170>)
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8U)                      );              /* Insert write key and priorty group */
  SCB->AIRCR =  reg_value;
 8001e7a:	60e2      	str	r2, [r4, #12]
 8001e7c:	68ea      	ldr	r2, [r5, #12]
#if CORTEX_MODEL == 7
  DWT->LAR = 0xC5ACCE55U;
#endif
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
 8001e7e:	4e39      	ldr	r6, [pc, #228]	; (8001f64 <chSysInit+0x174>)

  /* Initializing priority grouping.*/
  NVIC_SetPriorityGrouping(CORTEX_PRIGROUP_INIT);

  /* DWT cycle counter enable, note, the M7 requires DWT unlocking.*/
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
 8001e80:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 8001e84:	60ea      	str	r2, [r5, #12]
#if CORTEX_MODEL == 7
  DWT->LAR = 0xC5ACCE55U;
#endif
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
 8001e86:	6832      	ldr	r2, [r6, #0]
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) < 0)
  {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8001e88:	2710      	movs	r7, #16
 8001e8a:	4302      	orrs	r2, r0
 8001e8c:	2520      	movs	r5, #32
 8001e8e:	6032      	str	r2, [r6, #0]
 8001e90:	77e7      	strb	r7, [r4, #31]
 8001e92:	f884 5022 	strb.w	r5, [r4, #34]	; 0x22
 8001e96:	f381 8811 	msr	BASEPRI, r1
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8001e9a:	b662      	cpsie	i
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8001e9c:	f385 8811 	msr	BASEPRI, r5
  tp = (thread_t *)((uint8_t *)tdp->wend -
                    MEM_ALIGN_NEXT(sizeof (thread_t), PORT_STACK_ALIGN));

#if (CH_DBG_ENABLE_STACK_CHECK == TRUE) || (CH_CFG_USE_DYNAMIC == TRUE)
  /* Stack boundary.*/
  tp->wabase = tdp->wbase;
 8001ea0:	4a31      	ldr	r2, [pc, #196]	; (8001f68 <chSysInit+0x178>)
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 8001ea2:	4d32      	ldr	r5, [pc, #200]	; (8001f6c <chSysInit+0x17c>)
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
  tp->name      = name;
  REG_INSERT(tp);
 8001ea4:	695c      	ldr	r4, [r3, #20]
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->prio      = prio;
 8001ea6:	f8c2 0098 	str.w	r0, [r2, #152]	; 0x98
  tp->flags     = CH_FLAG_MODE_STATIC;
#if CH_CFG_TIME_QUANTUM > 0
  tp->preempt   = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->realprio  = prio;
 8001eaa:	f8c2 00cc 	str.w	r0, [r2, #204]	; 0xcc
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
 8001eae:	f882 00b2 	strb.w	r0, [r2, #178]	; 0xb2
  tp->name      = name;
 8001eb2:	4e2f      	ldr	r6, [pc, #188]	; (8001f70 <chSysInit+0x180>)
  /* Stack boundary.*/
  tp->wabase = tdp->wbase;
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 8001eb4:	f102 006c 	add.w	r0, r2, #108	; 0x6c
 8001eb8:	f8df e0b8 	ldr.w	lr, [pc, #184]	; 8001f74 <chSysInit+0x184>
 8001ebc:	f8c2 009c 	str.w	r0, [r2, #156]	; 0x9c
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->prio      = prio;
  tp->state     = CH_STATE_WTSTART;
 8001ec0:	2702      	movs	r7, #2
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
  tp->name      = name;
  REG_INSERT(tp);
 8001ec2:	f102 0090 	add.w	r0, r2, #144	; 0x90
  /* Stack boundary.*/
  tp->wabase = tdp->wbase;
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 8001ec6:	f8c2 508c 	str.w	r5, [r2, #140]	; 0x8c
 * @param[in] msg       the wakeup message
 *
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {
  thread_t *otp = currp;
 8001eca:	699d      	ldr	r5, [r3, #24]
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->prio      = prio;
  tp->state     = CH_STATE_WTSTART;
 8001ecc:	f882 70b0 	strb.w	r7, [r2, #176]	; 0xb0
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
  tp->name      = name;
  REG_INSERT(tp);
 8001ed0:	f8c2 40a4 	str.w	r4, [r2, #164]	; 0xa4
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->prio      = prio;
  tp->state     = CH_STATE_WTSTART;
  tp->flags     = CH_FLAG_MODE_STATIC;
 8001ed4:	f882 10b1 	strb.w	r1, [r2, #177]	; 0xb1
#if CH_CFG_USE_MUTEXES == TRUE
  tp->realprio  = prio;
  tp->mtxlist   = NULL;
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->epending  = (eventmask_t)0;
 8001ed8:	f8c2 10c4 	str.w	r1, [r2, #196]	; 0xc4
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
  tp->name      = name;
 8001edc:	f8c2 60a8 	str.w	r6, [r2, #168]	; 0xa8
  /* Stack boundary.*/
  tp->wabase = tdp->wbase;
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 8001ee0:	6711      	str	r1, [r2, #112]	; 0x70
#if CH_CFG_TIME_QUANTUM > 0
  tp->preempt   = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->realprio  = prio;
  tp->mtxlist   = NULL;
 8001ee2:	f8c2 10c8 	str.w	r1, [r2, #200]	; 0xc8
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
  tp->name      = name;
  REG_INSERT(tp);
 8001ee6:	f8c2 30a0 	str.w	r3, [r2, #160]	; 0xa0
  tp = (thread_t *)((uint8_t *)tdp->wend -
                    MEM_ALIGN_NEXT(sizeof (thread_t), PORT_STACK_ALIGN));

#if (CH_DBG_ENABLE_STACK_CHECK == TRUE) || (CH_CFG_USE_DYNAMIC == TRUE)
  /* Stack boundary.*/
  tp->wabase = tdp->wbase;
 8001eea:	f8c2 20ac 	str.w	r2, [r2, #172]	; 0xac
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 8001eee:	f8c2 e06c 	str.w	lr, [r2, #108]	; 0x6c
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
  tp->name      = name;
  REG_INSERT(tp);
 8001ef2:	6120      	str	r0, [r4, #16]
              (ch.rlist.current->prio >= ch.rlist.queue.next->prio),
              "priority order violation");

  /* Storing the message to be retrieved by the target thread when it will
     restart execution.*/
  ntp->u.rdymsg = msg;
 8001ef4:	f8c2 10b4 	str.w	r1, [r2, #180]	; 0xb4

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->prio <= otp->prio) {
 8001ef8:	68ae      	ldr	r6, [r5, #8]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8001efa:	f102 04bc 	add.w	r4, r2, #188	; 0xbc
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {

  tlp->next = (thread_t *)tlp;
 8001efe:	f102 07b8 	add.w	r7, r2, #184	; 0xb8
 8001f02:	6158      	str	r0, [r3, #20]
 8001f04:	f8c2 70b8 	str.w	r7, [r2, #184]	; 0xb8
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8001f08:	f8c2 40bc 	str.w	r4, [r2, #188]	; 0xbc
  tqp->prev = (thread_t *)tqp;
 8001f0c:	f8c2 40c0 	str.w	r4, [r2, #192]	; 0xc0
 8001f10:	b17e      	cbz	r6, 8001f32 <chSysInit+0x142>
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 8001f12:	f882 10b0 	strb.w	r1, [r2, #176]	; 0xb0
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
 8001f16:	681b      	ldr	r3, [r3, #0]
  } while (cp->prio >= tp->prio);
 8001f18:	6899      	ldr	r1, [r3, #8]
 8001f1a:	2900      	cmp	r1, #0
 8001f1c:	d1fb      	bne.n	8001f16 <chSysInit+0x126>
  /* Insertion on prev.*/
  tp->queue.next             = cp;
 8001f1e:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
  tp->queue.prev             = cp->queue.prev;
 8001f22:	685c      	ldr	r4, [r3, #4]
 8001f24:	f8c2 4094 	str.w	r4, [r2, #148]	; 0x94
  tp->queue.prev->queue.next = tp;
 8001f28:	6020      	str	r0, [r4, #0]
  cp->queue.prev             = tp;
 8001f2a:	6058      	str	r0, [r3, #4]
 8001f2c:	f381 8811 	msr	BASEPRI, r1
 8001f30:	bdf0      	pop	{r4, r5, r6, r7, pc}
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 8001f32:	f885 6020 	strb.w	r6, [r5, #32]
 8001f36:	e7fe      	b.n	8001f36 <chSysInit+0x146>
 8001f38:	200008f8 	.word	0x200008f8
 8001f3c:	08001711 	.word	0x08001711
 8001f40:	200008f0 	.word	0x200008f0
 8001f44:	20000a40 	.word	0x20000a40
 8001f48:	20000918 	.word	0x20000918
 8001f4c:	20000810 	.word	0x20000810
 8001f50:	20005000 	.word	0x20005000
 8001f54:	08002a4c 	.word	0x08002a4c
 8001f58:	e000ed00 	.word	0xe000ed00
 8001f5c:	05fa0300 	.word	0x05fa0300
 8001f60:	e000edf0 	.word	0xe000edf0
 8001f64:	e0001000 	.word	0xe0001000
 8001f68:	20000818 	.word	0x20000818
 8001f6c:	08000251 	.word	0x08000251
 8001f70:	08002a64 	.word	0x08002a64
 8001f74:	080017c1 	.word	0x080017c1
	...

08001f80 <BusFault_Handler>:
 *          This function simply stops the system into an infinite loop.
 *
 * @notapi
 */
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void _unhandled_exception(void) {
 8001f80:	e7fe      	b.n	8001f80 <BusFault_Handler>
 8001f82:	bf00      	nop
	...

08001f90 <__init_ram_areas>:
}

/**
 * @brief   Performs the initialization of the various RAM areas.
 */
void __init_ram_areas(void) {
 8001f90:	b5f0      	push	{r4, r5, r6, r7, lr}
 8001f92:	4f13      	ldr	r7, [pc, #76]	; (8001fe0 <__init_ram_areas+0x50>)
 8001f94:	4d13      	ldr	r5, [pc, #76]	; (8001fe4 <__init_ram_areas+0x54>)
 8001f96:	4c14      	ldr	r4, [pc, #80]	; (8001fe8 <__init_ram_areas+0x58>)
 8001f98:	4b14      	ldr	r3, [pc, #80]	; (8001fec <__init_ram_areas+0x5c>)
 8001f9a:	4915      	ldr	r1, [pc, #84]	; (8001ff0 <__init_ram_areas+0x60>)
 8001f9c:	f107 0e70 	add.w	lr, r7, #112	; 0x70
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
      *p = 0;
 8001fa0:	2600      	movs	r6, #0
  do {
    uint32_t *tp = rap->init_text_area;
    uint32_t *p = rap->init_area;

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
 8001fa2:	429c      	cmp	r4, r3
 8001fa4:	d911      	bls.n	8001fca <__init_ram_areas+0x3a>
 8001fa6:	461a      	mov	r2, r3
 8001fa8:	3904      	subs	r1, #4
      *p = *tp;
 8001faa:	f851 0f04 	ldr.w	r0, [r1, #4]!
 8001fae:	f842 0b04 	str.w	r0, [r2], #4
  do {
    uint32_t *tp = rap->init_text_area;
    uint32_t *p = rap->init_area;

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
 8001fb2:	4294      	cmp	r4, r2
 8001fb4:	d8f9      	bhi.n	8001faa <__init_ram_areas+0x1a>
 8001fb6:	43da      	mvns	r2, r3
 8001fb8:	4414      	add	r4, r2
 8001fba:	f024 0403 	bic.w	r4, r4, #3
 8001fbe:	3404      	adds	r4, #4
 8001fc0:	4423      	add	r3, r4
      p++;
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
 8001fc2:	429d      	cmp	r5, r3
 8001fc4:	d903      	bls.n	8001fce <__init_ram_areas+0x3e>
      *p = 0;
 8001fc6:	f843 6b04 	str.w	r6, [r3], #4
      p++;
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
 8001fca:	429d      	cmp	r5, r3
 8001fcc:	d8fb      	bhi.n	8001fc6 <__init_ram_areas+0x36>
      *p = 0;
      p++;
    }
    rap++;
  }
  while (rap < &ram_areas[CRT1_AREAS_NUMBER]);
 8001fce:	4577      	cmp	r7, lr
 8001fd0:	d005      	beq.n	8001fde <__init_ram_areas+0x4e>
 8001fd2:	6939      	ldr	r1, [r7, #16]
 8001fd4:	697b      	ldr	r3, [r7, #20]
 8001fd6:	69bc      	ldr	r4, [r7, #24]
 8001fd8:	69fd      	ldr	r5, [r7, #28]
 8001fda:	3710      	adds	r7, #16
 8001fdc:	e7e1      	b.n	8001fa2 <__init_ram_areas+0x12>
 8001fde:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8001fe0:	08002a6c 	.word	0x08002a6c
 8001fe4:	20000a3c 	.word	0x20000a3c
 8001fe8:	20000a3c 	.word	0x20000a3c
 8001fec:	20000a3c 	.word	0x20000a3c
 8001ff0:	080040d8 	.word	0x080040d8
	...

08002000 <__default_exit>:
 */
#if !defined(__DOXYGEN__)
__attribute__((noreturn, weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __default_exit(void) {
 8002000:	e7fe      	b.n	8002000 <__default_exit>
 8002002:	bf00      	nop
	...

08002010 <__late_init>:
 8002010:	4770      	bx	lr
 8002012:	bf00      	nop
	...

08002020 <__core_init>:
 */
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __core_init(void) {
 8002020:	4770      	bx	lr
 8002022:	bf00      	nop
	...

08002030 <dmaStreamAllocate.constprop.25>:
 * @retval false        no error, stream taken.
 * @retval true         error, stream already taken.
 *
 * @special
 */
bool dmaStreamAllocate(const stm32_dma_stream_t *dmastp,
 8002030:	b5f0      	push	{r4, r5, r6, r7, lr}
                       void *param) {

  osalDbgCheck(dmastp != NULL);

  /* Checks if the stream is already taken.*/
  if ((dma_streams_mask & (1U << dmastp->selfindex)) != 0U)
 8002032:	4d24      	ldr	r5, [pc, #144]	; (80020c4 <dmaStreamAllocate.constprop.25+0x94>)
 8002034:	7c44      	ldrb	r4, [r0, #17]
 8002036:	2201      	movs	r2, #1
 8002038:	682b      	ldr	r3, [r5, #0]
 800203a:	fa02 f604 	lsl.w	r6, r2, r4
 800203e:	421e      	tst	r6, r3
 8002040:	d13d      	bne.n	80020be <dmaStreamAllocate.constprop.25+0x8e>
    return true;

  /* Installs the DMA handler.*/
  _stm32_dma_isr_redir[dmastp->selfindex].dma_func  = func;
 8002042:	4a21      	ldr	r2, [pc, #132]	; (80020c8 <dmaStreamAllocate.constprop.25+0x98>)
  _stm32_dma_isr_redir[dmastp->selfindex].dma_param = param;
 8002044:	4f21      	ldr	r7, [pc, #132]	; (80020cc <dmaStreamAllocate.constprop.25+0x9c>)
 8002046:	eb02 06c4 	add.w	r6, r2, r4, lsl #3
  /* Checks if the stream is already taken.*/
  if ((dma_streams_mask & (1U << dmastp->selfindex)) != 0U)
    return true;

  /* Installs the DMA handler.*/
  _stm32_dma_isr_redir[dmastp->selfindex].dma_func  = func;
 800204a:	f842 1034 	str.w	r1, [r2, r4, lsl #3]
  _stm32_dma_isr_redir[dmastp->selfindex].dma_param = param;

  /* Enabling DMA clocks required by the current streams set.*/
  if ((dma_streams_mask & STM32_DMA1_STREAMS_MASK) == 0U) {
 800204e:	065a      	lsls	r2, r3, #25
  if ((dma_streams_mask & (1U << dmastp->selfindex)) != 0U)
    return true;

  /* Installs the DMA handler.*/
  _stm32_dma_isr_redir[dmastp->selfindex].dma_func  = func;
  _stm32_dma_isr_redir[dmastp->selfindex].dma_param = param;
 8002050:	6077      	str	r7, [r6, #4]

  /* Enabling DMA clocks required by the current streams set.*/
  if ((dma_streams_mask & STM32_DMA1_STREAMS_MASK) == 0U) {
 8002052:	d104      	bne.n	800205e <dmaStreamAllocate.constprop.25+0x2e>
    rccEnableDMA1(false);
 8002054:	4c1e      	ldr	r4, [pc, #120]	; (80020d0 <dmaStreamAllocate.constprop.25+0xa0>)
 8002056:	6962      	ldr	r2, [r4, #20]
 8002058:	f042 0201 	orr.w	r2, r2, #1
 800205c:	6162      	str	r2, [r4, #20]
    rccEnableDMA2(false);
  }
#endif

  /* Putting the stream in a safe state.*/
  dmaStreamDisable(dmastp);
 800205e:	6842      	ldr	r2, [r0, #4]
 8002060:	6807      	ldr	r7, [r0, #0]
 8002062:	6816      	ldr	r6, [r2, #0]
 8002064:	240f      	movs	r4, #15
 8002066:	f026 060f 	bic.w	r6, r6, #15
 800206a:	6016      	str	r6, [r2, #0]
 800206c:	f890 e010 	ldrb.w	lr, [r0, #16]
  dmastp->channel->CCR = STM32_DMA_CCR_RESET_VALUE;

  /* Enables the associated IRQ vector if not alread enabled and if a
     callback is defined.*/
  if (((dma_streams_mask & dmastp->cmask) == 0U) &&
 8002070:	6886      	ldr	r6, [r0, #8]
    rccEnableDMA2(false);
  }
#endif

  /* Putting the stream in a safe state.*/
  dmaStreamDisable(dmastp);
 8002072:	fa04 f40e 	lsl.w	r4, r4, lr
 8002076:	607c      	str	r4, [r7, #4]
  dmastp->channel->CCR = STM32_DMA_CCR_RESET_VALUE;

  /* Enables the associated IRQ vector if not alread enabled and if a
     callback is defined.*/
  if (((dma_streams_mask & dmastp->cmask) == 0U) &&
 8002078:	4233      	tst	r3, r6
  }
#endif

  /* Putting the stream in a safe state.*/
  dmaStreamDisable(dmastp);
  dmastp->channel->CCR = STM32_DMA_CCR_RESET_VALUE;
 800207a:	f04f 0400 	mov.w	r4, #0
 800207e:	6014      	str	r4, [r2, #0]

  /* Enables the associated IRQ vector if not alread enabled and if a
     callback is defined.*/
  if (((dma_streams_mask & dmastp->cmask) == 0U) &&
 8002080:	d116      	bne.n	80020b0 <dmaStreamAllocate.constprop.25+0x80>
 8002082:	b1a9      	cbz	r1, 80020b0 <dmaStreamAllocate.constprop.25+0x80>
      (func != NULL)) {
    nvicEnableVector(dmastp->vector, priority);
 8002084:	7c81      	ldrb	r1, [r0, #18]
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8002086:	2401      	movs	r4, #1
 8002088:	094a      	lsrs	r2, r1, #5
 800208a:	0092      	lsls	r2, r2, #2

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 800208c:	f101 4660 	add.w	r6, r1, #3758096384	; 0xe0000000
 8002090:	f102 4260 	add.w	r2, r2, #3758096384	; 0xe0000000
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8002094:	f001 011f 	and.w	r1, r1, #31
 8002098:	f502 4261 	add.w	r2, r2, #57600	; 0xe100
 800209c:	fa04 f101 	lsl.w	r1, r4, r1

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 80020a0:	2750      	movs	r7, #80	; 0x50
 80020a2:	f506 4661 	add.w	r6, r6, #57600	; 0xe100
 80020a6:	f886 7300 	strb.w	r7, [r6, #768]	; 0x300
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 80020aa:	f8c2 1180 	str.w	r1, [r2, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 80020ae:	6011      	str	r1, [r2, #0]
  }

  /* Marks the stream as allocated.*/
  dma_streams_mask |= (1U << dmastp->selfindex);
 80020b0:	7c41      	ldrb	r1, [r0, #17]
 80020b2:	2201      	movs	r2, #1
 80020b4:	408a      	lsls	r2, r1
 80020b6:	4313      	orrs	r3, r2
 80020b8:	602b      	str	r3, [r5, #0]
 80020ba:	2000      	movs	r0, #0
 80020bc:	bdf0      	pop	{r4, r5, r6, r7, pc}

  osalDbgCheck(dmastp != NULL);

  /* Checks if the stream is already taken.*/
  if ((dma_streams_mask & (1U << dmastp->selfindex)) != 0U)
    return true;
 80020be:	4610      	mov	r0, r2

  /* Marks the stream as allocated.*/
  dma_streams_mask |= (1U << dmastp->selfindex);

  return false;
}
 80020c0:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80020c2:	bf00      	nop
 80020c4:	200009f8 	.word	0x200009f8
 80020c8:	200009c0 	.word	0x200009c0
 80020cc:	20000a04 	.word	0x20000a04
 80020d0:	40021000 	.word	0x40021000
	...

080020e0 <chHeapAllocAligned.constprop.27>:
 * @return              A pointer to the aligned allocated block.
 * @retval NULL         if the block cannot be allocated.
 *
 * @api
 */
void *chHeapAllocAligned(memory_heap_t *heapp, size_t size, unsigned align) {
 80020e0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80020e4:	1dc6      	adds	r6, r0, #7
 80020e6:	4604      	mov	r4, r0
 80020e8:	08f6      	lsrs	r6, r6, #3
 80020ea:	2320      	movs	r3, #32
 80020ec:	f383 8811 	msr	BASEPRI, r3
 * @api
 */
void chMtxLock(mutex_t *mp) {

  chSysLock();
  chMtxLockS(mp);
 80020f0:	4834      	ldr	r0, [pc, #208]	; (80021c4 <chHeapAllocAligned.constprop.27+0xe4>)
 80020f2:	f7ff fd9d 	bl	8001c30 <chMtxLockS>
 80020f6:	2300      	movs	r3, #0
 80020f8:	f383 8811 	msr	BASEPRI, r3

  /* Taking heap mutex/semaphore.*/
  H_LOCK(heapp);

  /* Start of the free blocks list.*/
  qp = &heapp->header;
 80020fc:	4832      	ldr	r0, [pc, #200]	; (80021c8 <chHeapAllocAligned.constprop.27+0xe8>)
  while (H_NEXT(qp) != NULL) {
 80020fe:	6803      	ldr	r3, [r0, #0]

    /* Next free block.*/
    hp = H_NEXT(qp);

    /* Pointer aligned to the requested alignment.*/
    ahp = (heap_header_t *)MEM_ALIGN_NEXT(H_BLOCK(hp), align) - 1U;
 8002100:	f103 020f 	add.w	r2, r3, #15
 8002104:	f022 0e07 	bic.w	lr, r2, #7
 8002108:	f1ae 0708 	sub.w	r7, lr, #8

    if ((ahp < H_LIMIT(hp)) && (pages <= NPAGES(H_LIMIT(hp), ahp + 1U))) {
 800210c:	1bd9      	subs	r1, r3, r7

    /* Next free block.*/
    hp = H_NEXT(qp);

    /* Pointer aligned to the requested alignment.*/
    ahp = (heap_header_t *)MEM_ALIGN_NEXT(H_BLOCK(hp), align) - 1U;
 800210e:	f103 0508 	add.w	r5, r3, #8
  /* Taking heap mutex/semaphore.*/
  H_LOCK(heapp);

  /* Start of the free blocks list.*/
  qp = &heapp->header;
  while (H_NEXT(qp) != NULL) {
 8002112:	b183      	cbz	r3, 8002136 <chHeapAllocAligned.constprop.27+0x56>
    hp = H_NEXT(qp);

    /* Pointer aligned to the requested alignment.*/
    ahp = (heap_header_t *)MEM_ALIGN_NEXT(H_BLOCK(hp), align) - 1U;

    if ((ahp < H_LIMIT(hp)) && (pages <= NPAGES(H_LIMIT(hp), ahp + 1U))) {
 8002114:	f8d3 c004 	ldr.w	ip, [r3, #4]
 8002118:	f10c 0201 	add.w	r2, ip, #1
 800211c:	00d2      	lsls	r2, r2, #3
 800211e:	f1a2 0808 	sub.w	r8, r2, #8
 8002122:	441a      	add	r2, r3
 8002124:	4441      	add	r1, r8
 8002126:	4297      	cmp	r7, r2
 8002128:	ea4f 01e1 	mov.w	r1, r1, asr #3
 800212c:	d201      	bcs.n	8002132 <chHeapAllocAligned.constprop.27+0x52>
 800212e:	42b1      	cmp	r1, r6
 8002130:	d214      	bcs.n	800215c <chHeapAllocAligned.constprop.27+0x7c>
          heap_header_t *fp;

          fp = H_BLOCK(hp) + pages;
          H_NEXT(fp) = H_NEXT(hp);
          H_PAGES(fp) = NPAGES(H_LIMIT(hp), H_BLOCK(fp));
          H_NEXT(qp) = fp;
 8002132:	4618      	mov	r0, r3
 8002134:	e7e3      	b.n	80020fe <chHeapAllocAligned.constprop.27+0x1e>
    /* Next in the free blocks list.*/
    qp = hp;
  }

  /* Releasing heap mutex/semaphore.*/
  H_UNLOCK(heapp);
 8002136:	4d25      	ldr	r5, [pc, #148]	; (80021cc <chHeapAllocAligned.constprop.27+0xec>)
 8002138:	f105 0010 	add.w	r0, r5, #16
 800213c:	f7ff fd40 	bl	8001bc0 <chMtxUnlock>

  /* More memory is required, tries to get it from the associated provider
     else fails.*/
  if (heapp->provider != NULL) {
 8002140:	682b      	ldr	r3, [r5, #0]
 8002142:	2b00      	cmp	r3, #0
 8002144:	d03a      	beq.n	80021bc <chHeapAllocAligned.constprop.27+0xdc>
    hp = heapp->provider((pages + 1U) * CH_HEAP_ALIGNMENT, align);
 8002146:	1c70      	adds	r0, r6, #1
 8002148:	00c0      	lsls	r0, r0, #3
 800214a:	2108      	movs	r1, #8
 800214c:	4798      	blx	r3
    if (hp != NULL) {
 800214e:	2800      	cmp	r0, #0
 8002150:	d034      	beq.n	80021bc <chHeapAllocAligned.constprop.27+0xdc>
      H_HEAP(hp) = heapp;
 8002152:	6005      	str	r5, [r0, #0]
      H_SIZE(hp) = size;
 8002154:	6044      	str	r4, [r0, #4]

      /*lint -save -e9087 [11.3] Safe cast.*/
      return (void *)H_BLOCK(hp);
 8002156:	3008      	adds	r0, #8
      /*lint -restore*/
    }
  }

  return NULL;
}
 8002158:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

    if ((ahp < H_LIMIT(hp)) && (pages <= NPAGES(H_LIMIT(hp), ahp + 1U))) {
      /* The block is large enough to contain a correctly aligned area
         of sufficient size.*/

      if (ahp > hp) {
 800215c:	42bb      	cmp	r3, r7
 800215e:	d316      	bcc.n	800218e <chHeapAllocAligned.constprop.27+0xae>
        hp = ahp;
      }
      else {
        /* The block is already properly aligned.*/

        if (H_PAGES(hp) == pages) {
 8002160:	45b4      	cmp	ip, r6
 8002162:	d027      	beq.n	80021b4 <chHeapAllocAligned.constprop.27+0xd4>
        }
        else {
          /* The block is bigger than required, must split the excess.*/
          heap_header_t *fp;

          fp = H_BLOCK(hp) + pages;
 8002164:	3601      	adds	r6, #1
          H_NEXT(fp) = H_NEXT(hp);
 8002166:	6819      	ldr	r1, [r3, #0]
          H_PAGES(fp) = NPAGES(H_LIMIT(hp), H_BLOCK(fp));
 8002168:	eba8 02c6 	sub.w	r2, r8, r6, lsl #3
        else {
          /* The block is bigger than required, must split the excess.*/
          heap_header_t *fp;

          fp = H_BLOCK(hp) + pages;
          H_NEXT(fp) = H_NEXT(hp);
 800216c:	f843 1036 	str.w	r1, [r3, r6, lsl #3]
          H_PAGES(fp) = NPAGES(H_LIMIT(hp), H_BLOCK(fp));
          H_NEXT(qp) = fp;
 8002170:	461f      	mov	r7, r3
          /* The block is bigger than required, must split the excess.*/
          heap_header_t *fp;

          fp = H_BLOCK(hp) + pages;
          H_NEXT(fp) = H_NEXT(hp);
          H_PAGES(fp) = NPAGES(H_LIMIT(hp), H_BLOCK(fp));
 8002172:	10d2      	asrs	r2, r2, #3
 8002174:	eb03 03c6 	add.w	r3, r3, r6, lsl #3
 8002178:	605a      	str	r2, [r3, #4]
          H_NEXT(qp) = fp;
 800217a:	6003      	str	r3, [r0, #0]
        }
      }

      /* Setting in the block owner heap and size.*/
      H_SIZE(hp) = size;
      H_HEAP(hp) = heapp;
 800217c:	4813      	ldr	r0, [pc, #76]	; (80021cc <chHeapAllocAligned.constprop.27+0xec>)
 800217e:	e887 0011 	stmia.w	r7, {r0, r4}

      /* Releasing heap mutex/semaphore.*/
      H_UNLOCK(heapp);
 8002182:	3010      	adds	r0, #16
 8002184:	f7ff fd1c 	bl	8001bc0 <chMtxUnlock>

      /*lint -save -e9087 [11.3] Safe cast.*/
      return (void *)H_BLOCK(hp);
 8002188:	4628      	mov	r0, r5
 800218a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      if (ahp > hp) {
        /* The block is not properly aligned, must split it.*/
        size_t bpages;

        bpages = NPAGES(H_LIMIT(hp), H_BLOCK(ahp));
        H_PAGES(hp) = NPAGES(ahp, H_BLOCK(hp));
 800218e:	1b7a      	subs	r2, r7, r5
 8002190:	10d2      	asrs	r2, r2, #3
        if (bpages > pages) {
 8002192:	42b1      	cmp	r1, r6
      if (ahp > hp) {
        /* The block is not properly aligned, must split it.*/
        size_t bpages;

        bpages = NPAGES(H_LIMIT(hp), H_BLOCK(ahp));
        H_PAGES(hp) = NPAGES(ahp, H_BLOCK(hp));
 8002194:	605a      	str	r2, [r3, #4]
        if (bpages > pages) {
 8002196:	d90b      	bls.n	80021b0 <chHeapAllocAligned.constprop.27+0xd0>
          /* The block is bigger than required, must split the excess.*/
          heap_header_t *fp;

          /* Creating the excess block.*/
          fp = H_BLOCK(ahp) + pages;
          H_PAGES(fp) = (bpages - pages) - 1U;
 8002198:	43f2      	mvns	r2, r6
        if (bpages > pages) {
          /* The block is bigger than required, must split the excess.*/
          heap_header_t *fp;

          /* Creating the excess block.*/
          fp = H_BLOCK(ahp) + pages;
 800219a:	3601      	adds	r6, #1
          H_PAGES(fp) = (bpages - pages) - 1U;
 800219c:	4411      	add	r1, r2
        if (bpages > pages) {
          /* The block is bigger than required, must split the excess.*/
          heap_header_t *fp;

          /* Creating the excess block.*/
          fp = H_BLOCK(ahp) + pages;
 800219e:	eb07 02c6 	add.w	r2, r7, r6, lsl #3
          H_PAGES(fp) = (bpages - pages) - 1U;
 80021a2:	6051      	str	r1, [r2, #4]

          /* Linking the excess block.*/
          H_NEXT(fp) = H_NEXT(hp);
 80021a4:	6819      	ldr	r1, [r3, #0]
 80021a6:	4675      	mov	r5, lr
 80021a8:	f847 1036 	str.w	r1, [r7, r6, lsl #3]
          H_NEXT(hp) = fp;
 80021ac:	601a      	str	r2, [r3, #0]
 80021ae:	e7e5      	b.n	800217c <chHeapAllocAligned.constprop.27+0x9c>
 80021b0:	4675      	mov	r5, lr
 80021b2:	e7e3      	b.n	800217c <chHeapAllocAligned.constprop.27+0x9c>
      else {
        /* The block is already properly aligned.*/

        if (H_PAGES(hp) == pages) {
          /* Exact size, getting the whole block.*/
          H_NEXT(qp) = H_NEXT(hp);
 80021b4:	681a      	ldr	r2, [r3, #0]
 80021b6:	461f      	mov	r7, r3
 80021b8:	6002      	str	r2, [r0, #0]
 80021ba:	e7df      	b.n	800217c <chHeapAllocAligned.constprop.27+0x9c>
      return (void *)H_BLOCK(hp);
      /*lint -restore*/
    }
  }

  return NULL;
 80021bc:	2000      	movs	r0, #0
 80021be:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80021c2:	bf00      	nop
 80021c4:	20000908 	.word	0x20000908
 80021c8:	20000900 	.word	0x20000900
 80021cc:	200008f8 	.word	0x200008f8

080021d0 <i2c_lld_start.constprop.24>:
 *
 * @param[in] i2cp      pointer to the @p I2CDriver object
 *
 * @notapi
 */
void i2c_lld_start(I2CDriver *i2cp) {
 80021d0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  I2C_TypeDef *dp = i2cp->i2c;
 80021d2:	4c4e      	ldr	r4, [pc, #312]	; (800230c <i2c_lld_start.constprop.24+0x13c>)

  i2cp->txdmamode = STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE |
 80021d4:	229a      	movs	r2, #154	; 0x9a
                    STM32_DMA_CR_MINC       | STM32_DMA_CR_DMEIE |
                    STM32_DMA_CR_TEIE       | STM32_DMA_CR_TCIE |
                    STM32_DMA_CR_DIR_P2M;

  /* If in stopped state then enables the I2C and DMA clocks.*/
  if (i2cp->state == I2C_STOP) {
 80021d6:	7826      	ldrb	r6, [r4, #0]

  i2cp->txdmamode = STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE |
                    STM32_DMA_CR_MINC       | STM32_DMA_CR_DMEIE |
                    STM32_DMA_CR_TEIE       | STM32_DMA_CR_TCIE |
                    STM32_DMA_CR_DIR_M2P;
  i2cp->rxdmamode = STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE |
 80021d8:	238a      	movs	r3, #138	; 0x8a
                    STM32_DMA_CR_MINC       | STM32_DMA_CR_DMEIE |
                    STM32_DMA_CR_TEIE       | STM32_DMA_CR_TCIE |
                    STM32_DMA_CR_DIR_P2M;

  /* If in stopped state then enables the I2C and DMA clocks.*/
  if (i2cp->state == I2C_STOP) {
 80021da:	2e01      	cmp	r6, #1
 * @notapi
 */
void i2c_lld_start(I2CDriver *i2cp) {
  I2C_TypeDef *dp = i2cp->i2c;

  i2cp->txdmamode = STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE |
 80021dc:	62a2      	str	r2, [r4, #40]	; 0x28
                    STM32_DMA_CR_MINC       | STM32_DMA_CR_DMEIE |
                    STM32_DMA_CR_TEIE       | STM32_DMA_CR_TCIE |
                    STM32_DMA_CR_DIR_M2P;
  i2cp->rxdmamode = STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE |
 80021de:	6263      	str	r3, [r4, #36]	; 0x24
 * @param[in] i2cp      pointer to the @p I2CDriver object
 *
 * @notapi
 */
void i2c_lld_start(I2CDriver *i2cp) {
  I2C_TypeDef *dp = i2cp->i2c;
 80021e0:	6b65      	ldr	r5, [r4, #52]	; 0x34
                    STM32_DMA_CR_MINC       | STM32_DMA_CR_DMEIE |
                    STM32_DMA_CR_TEIE       | STM32_DMA_CR_TCIE |
                    STM32_DMA_CR_DIR_P2M;

  /* If in stopped state then enables the I2C and DMA clocks.*/
  if (i2cp->state == I2C_STOP) {
 80021e2:	d047      	beq.n	8002274 <i2c_lld_start.constprop.24+0xa4>
 * @param[in] i2cp      pointer to the @p I2CDriver object
 *
 * @notapi
 */
void i2c_lld_start(I2CDriver *i2cp) {
  I2C_TypeDef *dp = i2cp->i2c;
 80021e4:	462b      	mov	r3, r5
  osalDbgCheck((i2cp != NULL) &&
               (clock_speed > 0) &&
               (clock_speed <= 4000000));

  /* CR2 Configuration.*/
  dp->CR2 &= (uint16_t)~I2C_CR2_FREQ;
 80021e6:	f64f 76c0 	movw	r6, #65472	; 0xffc0
#endif /* STM32_I2C_USE_I2C3 */
  }

  /* I2C registers pointed by the DMA.*/
  dmaStreamSetPeripheral(i2cp->dmarx, &dp->DR);
  dmaStreamSetPeripheral(i2cp->dmatx, &dp->DR);
 80021ea:	6b21      	ldr	r1, [r4, #48]	; 0x30
    }
#endif /* STM32_I2C_USE_I2C3 */
  }

  /* I2C registers pointed by the DMA.*/
  dmaStreamSetPeripheral(i2cp->dmarx, &dp->DR);
 80021ec:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
  dmaStreamSetPeripheral(i2cp->dmatx, &dp->DR);
 80021ee:	684f      	ldr	r7, [r1, #4]
    }
#endif /* STM32_I2C_USE_I2C3 */
  }

  /* I2C registers pointed by the DMA.*/
  dmaStreamSetPeripheral(i2cp->dmarx, &dp->DR);
 80021f0:	6852      	ldr	r2, [r2, #4]
 80021f2:	f105 0110 	add.w	r1, r5, #16
 80021f6:	6091      	str	r1, [r2, #8]
  dmaStreamSetPeripheral(i2cp->dmatx, &dp->DR);

  /* Reset i2c peripheral.*/
  dp->CR1 = I2C_CR1_SWRST;
 80021f8:	f44f 4000 	mov.w	r0, #32768	; 0x8000
#endif /* STM32_I2C_USE_I2C3 */
  }

  /* I2C registers pointed by the DMA.*/
  dmaStreamSetPeripheral(i2cp->dmarx, &dp->DR);
  dmaStreamSetPeripheral(i2cp->dmatx, &dp->DR);
 80021fc:	60b9      	str	r1, [r7, #8]

  /* Reset i2c peripheral.*/
  dp->CR1 = I2C_CR1_SWRST;
  dp->CR1 = 0;
 80021fe:	2200      	movs	r2, #0
  dp->CR2 = I2C_CR2_ITERREN | I2C_CR2_DMAEN;
 8002200:	f44f 6110 	mov.w	r1, #2304	; 0x900
  /* I2C registers pointed by the DMA.*/
  dmaStreamSetPeripheral(i2cp->dmarx, &dp->DR);
  dmaStreamSetPeripheral(i2cp->dmatx, &dp->DR);

  /* Reset i2c peripheral.*/
  dp->CR1 = I2C_CR1_SWRST;
 8002204:	6028      	str	r0, [r5, #0]
  dp->CR1 = 0;
 8002206:	602a      	str	r2, [r5, #0]
  dp->CR2 = I2C_CR2_ITERREN | I2C_CR2_DMAEN;
 8002208:	6069      	str	r1, [r5, #4]
  osalDbgCheck((i2cp != NULL) &&
               (clock_speed > 0) &&
               (clock_speed <= 4000000));

  /* CR2 Configuration.*/
  dp->CR2 &= (uint16_t)~I2C_CR2_FREQ;
 800220a:	6859      	ldr	r1, [r3, #4]
 800220c:	6864      	ldr	r4, [r4, #4]
 800220e:	400e      	ands	r6, r1
 * @notapi
 */
static void i2c_lld_set_clock(I2CDriver *i2cp) {
  I2C_TypeDef *dp = i2cp->i2c;
  uint16_t regCCR, clock_div;
  int32_t clock_speed = i2cp->config->clock_speed;
 8002210:	6860      	ldr	r0, [r4, #4]
  i2cdutycycle_t duty = i2cp->config->duty_cycle;
 8002212:	7a27      	ldrb	r7, [r4, #8]
  osalDbgCheck((i2cp != NULL) &&
               (clock_speed > 0) &&
               (clock_speed <= 4000000));

  /* CR2 Configuration.*/
  dp->CR2 &= (uint16_t)~I2C_CR2_FREQ;
 8002214:	605e      	str	r6, [r3, #4]
  dp->CR2 |= (uint16_t)I2C_CLK_FREQ;
 8002216:	6859      	ldr	r1, [r3, #4]

  /* CCR Configuration.*/
  regCCR = 0;
  clock_div = I2C_CCR_CCR;

  if (clock_speed <= 100000) {
 8002218:	4e3d      	ldr	r6, [pc, #244]	; (8002310 <i2c_lld_start.constprop.24+0x140>)
               (clock_speed > 0) &&
               (clock_speed <= 4000000));

  /* CR2 Configuration.*/
  dp->CR2 &= (uint16_t)~I2C_CR2_FREQ;
  dp->CR2 |= (uint16_t)I2C_CLK_FREQ;
 800221a:	f041 0124 	orr.w	r1, r1, #36	; 0x24

  /* CCR Configuration.*/
  regCCR = 0;
  clock_div = I2C_CCR_CCR;

  if (clock_speed <= 100000) {
 800221e:	42b0      	cmp	r0, r6
               (clock_speed > 0) &&
               (clock_speed <= 4000000));

  /* CR2 Configuration.*/
  dp->CR2 &= (uint16_t)~I2C_CR2_FREQ;
  dp->CR2 |= (uint16_t)I2C_CLK_FREQ;
 8002220:	6059      	str	r1, [r3, #4]

  /* CCR Configuration.*/
  regCCR = 0;
  clock_div = I2C_CCR_CCR;

  if (clock_speed <= 100000) {
 8002222:	dd1e      	ble.n	8002262 <i2c_lld_start.constprop.24+0x92>
    regCCR |= (clock_div & I2C_CCR_CCR);

    /* Sets the Maximum Rise Time for standard mode.*/
    dp->TRISE = I2C_CLK_FREQ + 1;
  }
  else if (clock_speed <= 400000) {
 8002224:	493b      	ldr	r1, [pc, #236]	; (8002314 <i2c_lld_start.constprop.24+0x144>)
 8002226:	4288      	cmp	r0, r1
 8002228:	dc07      	bgt.n	800223a <i2c_lld_start.constprop.24+0x6a>
    /* Configure clock_div in fast mode.*/
    osalDbgAssert((duty == FAST_DUTY_CYCLE_2) ||
                  (duty == FAST_DUTY_CYCLE_16_9),
                  "invalid fast mode duty cycle");

    if (duty == FAST_DUTY_CYCLE_2) {
 800222a:	2f02      	cmp	r7, #2
 800222c:	d063      	beq.n	80022f6 <i2c_lld_start.constprop.24+0x126>
      /* Fast mode clock_div calculate: Tlow/Thigh = 2/1.*/
      osalDbgAssert((STM32_PCLK1 % (clock_speed * 3)) == 0,
                    "PCLK1 must be divided without remainder");
      clock_div = (uint16_t)(STM32_PCLK1 / (clock_speed * 3));
    }
    else if (duty == FAST_DUTY_CYCLE_16_9) {
 800222e:	2f03      	cmp	r7, #3
 8002230:	d054      	beq.n	80022dc <i2c_lld_start.constprop.24+0x10c>
 8002232:	f648 72ff 	movw	r2, #36863	; 0x8fff
    osalDbgAssert(clock_div >= 0x01,
                  "clock divider less then 0x04 not allowed");
    regCCR |= (I2C_CCR_FS | (clock_div & I2C_CCR_CCR));

    /* Sets the Maximum Rise Time for fast mode.*/
    dp->TRISE = (I2C_CLK_FREQ * 300 / 1000) + 1;
 8002236:	210b      	movs	r1, #11
 8002238:	6219      	str	r1, [r3, #32]
  }

  osalDbgAssert((clock_div <= I2C_CCR_CCR), "the selected clock is too low");

  dp->CCR = regCCR;
 800223a:	61da      	str	r2, [r3, #28]
  I2C_TypeDef *dp = i2cp->i2c;
  i2copmode_t opmode = i2cp->config->op_mode;
  uint16_t regCR1;

  regCR1 = dp->CR1;
  switch (opmode) {
 800223c:	7821      	ldrb	r1, [r4, #0]
static void i2c_lld_set_opmode(I2CDriver *i2cp) {
  I2C_TypeDef *dp = i2cp->i2c;
  i2copmode_t opmode = i2cp->config->op_mode;
  uint16_t regCR1;

  regCR1 = dp->CR1;
 800223e:	681a      	ldr	r2, [r3, #0]
  switch (opmode) {
 8002240:	2902      	cmp	r1, #2
static void i2c_lld_set_opmode(I2CDriver *i2cp) {
  I2C_TypeDef *dp = i2cp->i2c;
  i2copmode_t opmode = i2cp->config->op_mode;
  uint16_t regCR1;

  regCR1 = dp->CR1;
 8002242:	b292      	uxth	r2, r2
  switch (opmode) {
 8002244:	d044      	beq.n	80022d0 <i2c_lld_start.constprop.24+0x100>
 8002246:	2903      	cmp	r1, #3
 8002248:	d03f      	beq.n	80022ca <i2c_lld_start.constprop.24+0xfa>
 800224a:	2901      	cmp	r1, #1
 800224c:	d005      	beq.n	800225a <i2c_lld_start.constprop.24+0x8a>
    break;
  case OPMODE_SMBUS_HOST:
    regCR1 |= (I2C_CR1_SMBUS|I2C_CR1_SMBTYPE);
    break;
  }
  dp->CR1 = regCR1;
 800224e:	601a      	str	r2, [r3, #0]
  /* Setup I2C parameters.*/
  i2c_lld_set_clock(i2cp);
  i2c_lld_set_opmode(i2cp);

  /* Ready to go.*/
  dp->CR1 |= I2C_CR1_PE;
 8002250:	682b      	ldr	r3, [r5, #0]
 8002252:	f043 0301 	orr.w	r3, r3, #1
 8002256:	602b      	str	r3, [r5, #0]
 8002258:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  uint16_t regCR1;

  regCR1 = dp->CR1;
  switch (opmode) {
  case OPMODE_I2C:
    regCR1 &= (uint16_t)~(I2C_CR1_SMBUS|I2C_CR1_SMBTYPE);
 800225a:	f022 020a 	bic.w	r2, r2, #10
 800225e:	b292      	uxth	r2, r2
 8002260:	e7f5      	b.n	800224e <i2c_lld_start.constprop.24+0x7e>
 8002262:	492d      	ldr	r1, [pc, #180]	; (8002318 <i2c_lld_start.constprop.24+0x148>)
 8002264:	0042      	lsls	r2, r0, #1
 8002266:	fb91 f2f2 	sdiv	r2, r1, r2
    osalDbgAssert(clock_div >= 0x04,
                  "clock divider less then 0x04 not allowed");
    regCCR |= (clock_div & I2C_CCR_CCR);

    /* Sets the Maximum Rise Time for standard mode.*/
    dp->TRISE = I2C_CLK_FREQ + 1;
 800226a:	2125      	movs	r1, #37	; 0x25
 800226c:	f3c2 020b 	ubfx	r2, r2, #0, #12
 8002270:	6219      	str	r1, [r3, #32]
 8002272:	e7e2      	b.n	800223a <i2c_lld_start.constprop.24+0x6a>

#if STM32_I2C_USE_I2C1
    if (&I2CD1 == i2cp) {
      bool b;

      rccResetI2C1();
 8002274:	4f29      	ldr	r7, [pc, #164]	; (800231c <i2c_lld_start.constprop.24+0x14c>)
 8002276:	2200      	movs	r2, #0
 8002278:	693b      	ldr	r3, [r7, #16]
      b = dmaStreamAllocate(i2cp->dmarx,
 800227a:	4929      	ldr	r1, [pc, #164]	; (8002320 <i2c_lld_start.constprop.24+0x150>)

#if STM32_I2C_USE_I2C1
    if (&I2CD1 == i2cp) {
      bool b;

      rccResetI2C1();
 800227c:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 8002280:	613b      	str	r3, [r7, #16]
      b = dmaStreamAllocate(i2cp->dmarx,
 8002282:	6ae0      	ldr	r0, [r4, #44]	; 0x2c

#if STM32_I2C_USE_I2C1
    if (&I2CD1 == i2cp) {
      bool b;

      rccResetI2C1();
 8002284:	613a      	str	r2, [r7, #16]
      b = dmaStreamAllocate(i2cp->dmarx,
 8002286:	f7ff fed3 	bl	8002030 <dmaStreamAllocate.constprop.25>
                            STM32_I2C_I2C1_IRQ_PRIORITY,
                            (stm32_dmaisr_t)i2c_lld_serve_rx_end_irq,
                            (void *)i2cp);
      osalDbgAssert(!b, "stream already allocated");
      b = dmaStreamAllocate(i2cp->dmatx,
 800228a:	4926      	ldr	r1, [pc, #152]	; (8002324 <i2c_lld_start.constprop.24+0x154>)
 800228c:	6b20      	ldr	r0, [r4, #48]	; 0x30
 800228e:	f7ff fecf 	bl	8002030 <dmaStreamAllocate.constprop.25>
                            STM32_I2C_I2C1_IRQ_PRIORITY,
                            (stm32_dmaisr_t)i2c_lld_serve_tx_end_irq,
                            (void *)i2cp);
      osalDbgAssert(!b, "stream already allocated");
      rccEnableI2C1(FALSE);
 8002292:	69f8      	ldr	r0, [r7, #28]
      nvicEnableVector(I2C1_EV_IRQn, STM32_I2C_I2C1_IRQ_PRIORITY);
      nvicEnableVector(I2C1_ER_IRQn, STM32_I2C_I2C1_IRQ_PRIORITY);

      i2cp->rxdmamode |= STM32_DMA_CR_CHSEL(I2C1_RX_DMA_CHANNEL) |
 8002294:	6a61      	ldr	r1, [r4, #36]	; 0x24
                       STM32_DMA_CR_PL(STM32_I2C_I2C1_DMA_PRIORITY);
      i2cp->txdmamode |= STM32_DMA_CR_CHSEL(I2C1_TX_DMA_CHANNEL) |
 8002296:	6aa3      	ldr	r3, [r4, #40]	; 0x28

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8002298:	4a23      	ldr	r2, [pc, #140]	; (8002328 <i2c_lld_start.constprop.24+0x158>)
      b = dmaStreamAllocate(i2cp->dmatx,
                            STM32_I2C_I2C1_IRQ_PRIORITY,
                            (stm32_dmaisr_t)i2c_lld_serve_tx_end_irq,
                            (void *)i2cp);
      osalDbgAssert(!b, "stream already allocated");
      rccEnableI2C1(FALSE);
 800229a:	f440 1000 	orr.w	r0, r0, #2097152	; 0x200000
 800229e:	61f8      	str	r0, [r7, #28]
 80022a0:	2050      	movs	r0, #80	; 0x50
 80022a2:	f882 031f 	strb.w	r0, [r2, #799]	; 0x31f
      nvicEnableVector(I2C1_EV_IRQn, STM32_I2C_I2C1_IRQ_PRIORITY);
      nvicEnableVector(I2C1_ER_IRQn, STM32_I2C_I2C1_IRQ_PRIORITY);

      i2cp->rxdmamode |= STM32_DMA_CR_CHSEL(I2C1_RX_DMA_CHANNEL) |
                       STM32_DMA_CR_PL(STM32_I2C_I2C1_DMA_PRIORITY);
      i2cp->txdmamode |= STM32_DMA_CR_CHSEL(I2C1_TX_DMA_CHANNEL) |
 80022a6:	f443 5340 	orr.w	r3, r3, #12288	; 0x3000
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 80022aa:	f04f 4700 	mov.w	r7, #2147483648	; 0x80000000
      osalDbgAssert(!b, "stream already allocated");
      rccEnableI2C1(FALSE);
      nvicEnableVector(I2C1_EV_IRQn, STM32_I2C_I2C1_IRQ_PRIORITY);
      nvicEnableVector(I2C1_ER_IRQn, STM32_I2C_I2C1_IRQ_PRIORITY);

      i2cp->rxdmamode |= STM32_DMA_CR_CHSEL(I2C1_RX_DMA_CHANNEL) |
 80022ae:	f441 5140 	orr.w	r1, r1, #12288	; 0x3000
 80022b2:	6261      	str	r1, [r4, #36]	; 0x24
 80022b4:	f8c2 7180 	str.w	r7, [r2, #384]	; 0x180
                       STM32_DMA_CR_PL(STM32_I2C_I2C1_DMA_PRIORITY);
      i2cp->txdmamode |= STM32_DMA_CR_CHSEL(I2C1_TX_DMA_CHANNEL) |
 80022b8:	62a3      	str	r3, [r4, #40]	; 0x28
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 80022ba:	6017      	str	r7, [r2, #0]
 80022bc:	6b63      	ldr	r3, [r4, #52]	; 0x34

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 80022be:	f882 0320 	strb.w	r0, [r2, #800]	; 0x320
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 80022c2:	f8c2 6184 	str.w	r6, [r2, #388]	; 0x184
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 80022c6:	6056      	str	r6, [r2, #4]
 80022c8:	e78d      	b.n	80021e6 <i2c_lld_start.constprop.24+0x16>
  case OPMODE_SMBUS_DEVICE:
    regCR1 |= I2C_CR1_SMBUS;
    regCR1 &= (uint16_t)~(I2C_CR1_SMBTYPE);
    break;
  case OPMODE_SMBUS_HOST:
    regCR1 |= (I2C_CR1_SMBUS|I2C_CR1_SMBTYPE);
 80022ca:	f042 020a 	orr.w	r2, r2, #10
 80022ce:	e7be      	b.n	800224e <i2c_lld_start.constprop.24+0x7e>
 80022d0:	f022 0208 	bic.w	r2, r2, #8
 80022d4:	b292      	uxth	r2, r2
  case OPMODE_I2C:
    regCR1 &= (uint16_t)~(I2C_CR1_SMBUS|I2C_CR1_SMBTYPE);
    break;
  case OPMODE_SMBUS_DEVICE:
    regCR1 |= I2C_CR1_SMBUS;
    regCR1 &= (uint16_t)~(I2C_CR1_SMBTYPE);
 80022d6:	f042 0202 	orr.w	r2, r2, #2
 80022da:	e7b8      	b.n	800224e <i2c_lld_start.constprop.24+0x7e>
 80022dc:	eb00 0280 	add.w	r2, r0, r0, lsl #2
 80022e0:	490d      	ldr	r1, [pc, #52]	; (8002318 <i2c_lld_start.constprop.24+0x148>)
 80022e2:	eb02 0282 	add.w	r2, r2, r2, lsl #2
 80022e6:	fb91 f2f2 	sdiv	r2, r1, r2
 80022ea:	ea6f 4282 	mvn.w	r2, r2, lsl #18
 80022ee:	ea6f 4292 	mvn.w	r2, r2, lsr #18
 80022f2:	b292      	uxth	r2, r2
 80022f4:	e79f      	b.n	8002236 <i2c_lld_start.constprop.24+0x66>
 80022f6:	4908      	ldr	r1, [pc, #32]	; (8002318 <i2c_lld_start.constprop.24+0x148>)
 80022f8:	eb00 0240 	add.w	r2, r0, r0, lsl #1
 80022fc:	fb91 f2f2 	sdiv	r2, r1, r2
 8002300:	ea6f 4242 	mvn.w	r2, r2, lsl #17
 8002304:	ea6f 4252 	mvn.w	r2, r2, lsr #17
 8002308:	b292      	uxth	r2, r2
 800230a:	e794      	b.n	8002236 <i2c_lld_start.constprop.24+0x66>
 800230c:	20000a04 	.word	0x20000a04
 8002310:	000186a0 	.word	0x000186a0
 8002314:	00061a80 	.word	0x00061a80
 8002318:	02255100 	.word	0x02255100
 800231c:	40021000 	.word	0x40021000
 8002320:	08000b61 	.word	0x08000b61
 8002324:	080005e1 	.word	0x080005e1
 8002328:	e000e100 	.word	0xe000e100
 800232c:	00000000 	.word	0x00000000

08002330 <i2cStop.constprop.20>:
 *
 * @param[in] i2cp      pointer to the @p I2CDriver object
 *
 * @api
 */
void i2cStop(I2CDriver *i2cp) {
 8002330:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8002332:	2320      	movs	r3, #32
 8002334:	f383 8811 	msr	BASEPRI, r3
 * @notapi
 */
void i2c_lld_stop(I2CDriver *i2cp) {

  /* If not in stopped state then disables the I2C clock.*/
  if (i2cp->state != I2C_STOP) {
 8002338:	4c1f      	ldr	r4, [pc, #124]	; (80023b8 <i2cStop.constprop.20+0x88>)
 800233a:	7823      	ldrb	r3, [r4, #0]
 800233c:	2b01      	cmp	r3, #1
 800233e:	d033      	beq.n	80023a8 <i2cStop.constprop.20+0x78>
  dp->CR1 = 0;
  dp->CR2 = 0;
  dp->SR1 = 0;

  /* Stops the associated DMA streams.*/
  dmaStreamDisable(i2cp->dmatx);
 8002340:	6b20      	ldr	r0, [r4, #48]	; 0x30
 * @param[in] i2cp      pointer to the @p I2CDriver object
 *
 * @notapi
 */
static void i2c_lld_abort_operation(I2CDriver *i2cp) {
  I2C_TypeDef *dp = i2cp->i2c;
 8002342:	6b63      	ldr	r3, [r4, #52]	; 0x34
  dp->CR1 = 0;
  dp->CR2 = 0;
  dp->SR1 = 0;

  /* Stops the associated DMA streams.*/
  dmaStreamDisable(i2cp->dmatx);
 8002344:	6841      	ldr	r1, [r0, #4]
static void i2c_lld_abort_operation(I2CDriver *i2cp) {
  I2C_TypeDef *dp = i2cp->i2c;

  /* Stops the I2C peripheral.*/
  dp->CR1 = I2C_CR1_SWRST;
  dp->CR1 = 0;
 8002346:	2500      	movs	r5, #0
 */
static void i2c_lld_abort_operation(I2CDriver *i2cp) {
  I2C_TypeDef *dp = i2cp->i2c;

  /* Stops the I2C peripheral.*/
  dp->CR1 = I2C_CR1_SWRST;
 8002348:	f44f 4200 	mov.w	r2, #32768	; 0x8000
 800234c:	601a      	str	r2, [r3, #0]
  dp->CR1 = 0;
 800234e:	601d      	str	r5, [r3, #0]
  dp->CR2 = 0;
 8002350:	605d      	str	r5, [r3, #4]
  dp->SR1 = 0;
 8002352:	615d      	str	r5, [r3, #20]

  /* Stops the associated DMA streams.*/
  dmaStreamDisable(i2cp->dmatx);
 8002354:	680b      	ldr	r3, [r1, #0]
  dmaStreamDisable(i2cp->dmarx);
 8002356:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
  dp->CR1 = 0;
  dp->CR2 = 0;
  dp->SR1 = 0;

  /* Stops the associated DMA streams.*/
  dmaStreamDisable(i2cp->dmatx);
 8002358:	f023 030f 	bic.w	r3, r3, #15
 800235c:	600b      	str	r3, [r1, #0]
 800235e:	7c01      	ldrb	r1, [r0, #16]
 8002360:	6806      	ldr	r6, [r0, #0]
 8002362:	230f      	movs	r3, #15
  dmaStreamDisable(i2cp->dmarx);
 8002364:	6857      	ldr	r7, [r2, #4]
  dp->CR1 = 0;
  dp->CR2 = 0;
  dp->SR1 = 0;

  /* Stops the associated DMA streams.*/
  dmaStreamDisable(i2cp->dmatx);
 8002366:	fa03 f101 	lsl.w	r1, r3, r1
 800236a:	6071      	str	r1, [r6, #4]
  dmaStreamDisable(i2cp->dmarx);
 800236c:	6839      	ldr	r1, [r7, #0]
 800236e:	f021 010f 	bic.w	r1, r1, #15
 8002372:	6039      	str	r1, [r7, #0]
 8002374:	7c11      	ldrb	r1, [r2, #16]
 8002376:	6812      	ldr	r2, [r2, #0]
 8002378:	408b      	lsls	r3, r1
 800237a:	6053      	str	r3, [r2, #4]
  /* If not in stopped state then disables the I2C clock.*/
  if (i2cp->state != I2C_STOP) {

    /* I2C disable.*/
    i2c_lld_abort_operation(i2cp);
    dmaStreamRelease(i2cp->dmatx);
 800237c:	f7fe fd58 	bl	8000e30 <dmaStreamRelease>
    dmaStreamRelease(i2cp->dmarx);
 8002380:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 8002382:	f7fe fd55 	bl	8000e30 <dmaStreamRelease>
 *
 * @param[in] n         the interrupt number
 */
void nvicDisableVector(uint32_t n) {

  NVIC->ICER[n >> 5U] = 1U << (n & 0x1FU);
 8002386:	4b0d      	ldr	r3, [pc, #52]	; (80023bc <i2cStop.constprop.20+0x8c>)

#if STM32_I2C_USE_I2C1
    if (&I2CD1 == i2cp) {
      nvicDisableVector(I2C1_EV_IRQn);
      nvicDisableVector(I2C1_ER_IRQn);
      rccDisableI2C1(FALSE);
 8002388:	4a0d      	ldr	r2, [pc, #52]	; (80023c0 <i2cStop.constprop.20+0x90>)
 800238a:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
 800238e:	2101      	movs	r1, #1
 8002390:	f8c3 0080 	str.w	r0, [r3, #128]	; 0x80
#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = 0U;
 8002394:	f883 531f 	strb.w	r5, [r3, #799]	; 0x31f
 *
 * @param[in] n         the interrupt number
 */
void nvicDisableVector(uint32_t n) {

  NVIC->ICER[n >> 5U] = 1U << (n & 0x1FU);
 8002398:	f8c3 1084 	str.w	r1, [r3, #132]	; 0x84
#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = 0U;
 800239c:	f883 5320 	strb.w	r5, [r3, #800]	; 0x320
 80023a0:	69d3      	ldr	r3, [r2, #28]
 80023a2:	f423 1300 	bic.w	r3, r3, #2097152	; 0x200000
 80023a6:	61d3      	str	r3, [r2, #28]

  osalDbgAssert((i2cp->state == I2C_STOP) || (i2cp->state == I2C_READY) ||
                (i2cp->state == I2C_LOCKED), "invalid state");

  i2c_lld_stop(i2cp);
  i2cp->config = NULL;
 80023a8:	2300      	movs	r3, #0
  i2cp->state  = I2C_STOP;
 80023aa:	2201      	movs	r2, #1

  osalDbgAssert((i2cp->state == I2C_STOP) || (i2cp->state == I2C_READY) ||
                (i2cp->state == I2C_LOCKED), "invalid state");

  i2c_lld_stop(i2cp);
  i2cp->config = NULL;
 80023ac:	6063      	str	r3, [r4, #4]
  i2cp->state  = I2C_STOP;
 80023ae:	7022      	strb	r2, [r4, #0]
 80023b0:	f383 8811 	msr	BASEPRI, r3
 80023b4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80023b6:	bf00      	nop
 80023b8:	20000a04 	.word	0x20000a04
 80023bc:	e000e100 	.word	0xe000e100
 80023c0:	40021000 	.word	0x40021000
	...

080023d0 <i2cMasterTransmitTimeout.constprop.18>:
 *                      be retrieved using @p i2cGetErrors().
 * @retval MSG_TIMEOUT  if a timeout occurred before operation end.
 *
 * @api
 */
msg_t i2cMasterTransmitTimeout(I2CDriver *i2cp,
 80023d0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 80023d4:	4691      	mov	r9, r2
 80023d6:	2420      	movs	r4, #32
 80023d8:	f384 8811 	msr	BASEPRI, r4
               (timeout != TIME_IMMEDIATE));

  osalDbgAssert(i2cp->state == I2C_READY, "not ready");

  osalSysLock();
  i2cp->errors = I2C_NO_ERROR;
 80023dc:	4e2d      	ldr	r6, [pc, #180]	; (8002494 <i2cMasterTransmitTimeout.constprop.18+0xc4>)

  /* Resetting error flags for this transfer.*/
  i2cp->errors = I2C_NO_ERROR;

  /* Initializes driver fields, LSB = 0 -> transmit.*/
  i2cp->addr = (addr << 1);
 80023de:	0040      	lsls	r0, r0, #1
  i2cp->state = I2C_ACTIVE_TX;
 80023e0:	2503      	movs	r5, #3
               (timeout != TIME_IMMEDIATE));

  osalDbgAssert(i2cp->state == I2C_READY, "not ready");

  osalSysLock();
  i2cp->errors = I2C_NO_ERROR;
 80023e2:	2300      	movs	r3, #0
 80023e4:	8430      	strh	r0, [r6, #32]
  i2cp->state = I2C_ACTIVE_TX;
 80023e6:	7035      	strb	r5, [r6, #0]
               (timeout != TIME_IMMEDIATE));

  osalDbgAssert(i2cp->state == I2C_READY, "not ready");

  osalSysLock();
  i2cp->errors = I2C_NO_ERROR;
 80023e8:	60b3      	str	r3, [r6, #8]
 */
msg_t i2c_lld_master_transmit_timeout(I2CDriver *i2cp, i2caddr_t addr,
                                      const uint8_t *txbuf, size_t txbytes,
                                      uint8_t *rxbuf, size_t rxbytes,
                                      systime_t timeout) {
  I2C_TypeDef *dp = i2cp->i2c;
 80023ea:	6b70      	ldr	r0, [r6, #52]	; 0x34
 80023ec:	f383 8811 	msr	BASEPRI, r3

  /* Releases the lock from high level driver.*/
  osalSysUnlock();

  /* TX DMA setup.*/
  dmaStreamSetMode(i2cp->dmatx, i2cp->txdmamode);
 80023f0:	6b32      	ldr	r2, [r6, #48]	; 0x30
  dmaStreamSetMemory0(i2cp->dmatx, txbuf);
  dmaStreamSetTransactionSize(i2cp->dmatx, txbytes);

  /* RX DMA setup.*/
  dmaStreamSetMode(i2cp->dmarx, i2cp->rxdmamode);
 80023f2:	f8d6 e02c 	ldr.w	lr, [r6, #44]	; 0x2c

  /* Releases the lock from high level driver.*/
  osalSysUnlock();

  /* TX DMA setup.*/
  dmaStreamSetMode(i2cp->dmatx, i2cp->txdmamode);
 80023f6:	f8d2 c004 	ldr.w	ip, [r2, #4]
 80023fa:	6ab2      	ldr	r2, [r6, #40]	; 0x28
  dmaStreamSetMemory0(i2cp->dmatx, txbuf);
  dmaStreamSetTransactionSize(i2cp->dmatx, txbytes);

  /* RX DMA setup.*/
  dmaStreamSetMode(i2cp->dmarx, i2cp->rxdmamode);
 80023fc:	f8de e004 	ldr.w	lr, [lr, #4]

  /* Releases the lock from high level driver.*/
  osalSysUnlock();

  /* TX DMA setup.*/
  dmaStreamSetMode(i2cp->dmatx, i2cp->txdmamode);
 8002400:	f8cc 2000 	str.w	r2, [ip]
  dmaStreamSetMemory0(i2cp->dmatx, txbuf);
  dmaStreamSetTransactionSize(i2cp->dmatx, txbytes);

  /* RX DMA setup.*/
  dmaStreamSetMode(i2cp->dmarx, i2cp->rxdmamode);
 8002404:	6a72      	ldr	r2, [r6, #36]	; 0x24
  /* Releases the lock from high level driver.*/
  osalSysUnlock();

  /* TX DMA setup.*/
  dmaStreamSetMode(i2cp->dmatx, i2cp->txdmamode);
  dmaStreamSetMemory0(i2cp->dmatx, txbuf);
 8002406:	f8cc 100c 	str.w	r1, [ip, #12]
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 800240a:	f04f 4880 	mov.w	r8, #1073741824	; 0x40000000
  dmaStreamSetTransactionSize(i2cp->dmatx, txbytes);
 800240e:	f8cc 9004 	str.w	r9, [ip, #4]

  /* RX DMA setup.*/
  dmaStreamSetMode(i2cp->dmarx, i2cp->rxdmamode);
 8002412:	f8ce 2000 	str.w	r2, [lr]
  dmaStreamSetMemory0(i2cp->dmarx, rxbuf);
 8002416:	f8ce 300c 	str.w	r3, [lr, #12]
  dmaStreamSetTransactionSize(i2cp->dmarx, rxbytes);
 800241a:	f8ce 3004 	str.w	r3, [lr, #4]
 800241e:	f8d8 2024 	ldr.w	r2, [r8, #36]	; 0x24
 8002422:	461f      	mov	r7, r3
 8002424:	4645      	mov	r5, r8
 8002426:	b292      	uxth	r2, r2
 8002428:	e001      	b.n	800242e <i2cMasterTransmitTimeout.constprop.18+0x5e>
 800242a:	f387 8811 	msr	BASEPRI, r7
 800242e:	f384 8811 	msr	BASEPRI, r4
  while (true) {
    osalSysLock();

    /* If the bus is not busy then the operation can continue, note, the
       loop is exited in the locked state.*/
    if (!(dp->SR2 & I2C_SR2_BUSY) && !(dp->CR1 & I2C_CR1_STOP))
 8002432:	6983      	ldr	r3, [r0, #24]
 8002434:	079b      	lsls	r3, r3, #30
 8002436:	d402      	bmi.n	800243e <i2cMasterTransmitTimeout.constprop.18+0x6e>
 8002438:	6803      	ldr	r3, [r0, #0]
 800243a:	0599      	lsls	r1, r3, #22
 800243c:	d50d      	bpl.n	800245a <i2cMasterTransmitTimeout.constprop.18+0x8a>
 800243e:	6a6b      	ldr	r3, [r5, #36]	; 0x24
      break;

    /* If the system time went outside the allowed window then a timeout
       condition is returned.*/
    if (!osalOsIsTimeWithinX(osalOsGetSystemTimeX(), start, end))
 8002440:	1a9b      	subs	r3, r3, r2
 8002442:	b29b      	uxth	r3, r3
 8002444:	2b63      	cmp	r3, #99	; 0x63
 8002446:	d9f0      	bls.n	800242a <i2cMasterTransmitTimeout.constprop.18+0x5a>
  i2cp->state = I2C_ACTIVE_TX;
  rdymsg = i2c_lld_master_transmit_timeout(i2cp, addr, txbuf, txbytes,
                                           rxbuf, rxbytes, timeout);
  if (rdymsg == MSG_TIMEOUT) {
    i2cp->state = I2C_LOCKED;
 8002448:	2305      	movs	r3, #5
 800244a:	7033      	strb	r3, [r6, #0]
 800244c:	f04f 30ff 	mov.w	r0, #4294967295
 8002450:	2300      	movs	r3, #0
 8002452:	f383 8811 	msr	BASEPRI, r3
  else {
    i2cp->state = I2C_READY;
  }
  osalSysUnlock();
  return rdymsg;
}
 8002456:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

    osalSysUnlock();
  }

  /* Starts the operation.*/
  dp->CR2 |= I2C_CR2_ITEVTEN;
 800245a:	6843      	ldr	r3, [r0, #4]
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 800245c:	4a0e      	ldr	r2, [pc, #56]	; (8002498 <i2cMasterTransmitTimeout.constprop.18+0xc8>)
 800245e:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 8002462:	6043      	str	r3, [r0, #4]
  dp->CR1 |= I2C_CR1_START;
 8002464:	6803      	ldr	r3, [r0, #0]

  if (TIME_IMMEDIATE == timeout) {
    return MSG_TIMEOUT;
  }

  *trp = tp;
 8002466:	4c0b      	ldr	r4, [pc, #44]	; (8002494 <i2cMasterTransmitTimeout.constprop.18+0xc4>)
 8002468:	6992      	ldr	r2, [r2, #24]
 800246a:	f443 7380 	orr.w	r3, r3, #256	; 0x100
  tp->u.wttrp = trp;
 800246e:	f104 051c 	add.w	r5, r4, #28
 8002472:	6003      	str	r3, [r0, #0]

  return chSchGoSleepTimeoutS(CH_STATE_SUSPENDED, timeout);
 8002474:	2114      	movs	r1, #20
  if (TIME_IMMEDIATE == timeout) {
    return MSG_TIMEOUT;
  }

  *trp = tp;
  tp->u.wttrp = trp;
 8002476:	6255      	str	r5, [r2, #36]	; 0x24

  return chSchGoSleepTimeoutS(CH_STATE_SUSPENDED, timeout);
 8002478:	2003      	movs	r0, #3

  if (TIME_IMMEDIATE == timeout) {
    return MSG_TIMEOUT;
  }

  *trp = tp;
 800247a:	61f2      	str	r2, [r6, #28]
  tp->u.wttrp = trp;

  return chSchGoSleepTimeoutS(CH_STATE_SUSPENDED, timeout);
 800247c:	f7ff fad8 	bl	8001a30 <chSchGoSleepTimeoutS>
  osalSysLock();
  i2cp->errors = I2C_NO_ERROR;
  i2cp->state = I2C_ACTIVE_TX;
  rdymsg = i2c_lld_master_transmit_timeout(i2cp, addr, txbuf, txbytes,
                                           rxbuf, rxbytes, timeout);
  if (rdymsg == MSG_TIMEOUT) {
 8002480:	1c43      	adds	r3, r0, #1
 8002482:	d0e1      	beq.n	8002448 <i2cMasterTransmitTimeout.constprop.18+0x78>
    i2cp->state = I2C_LOCKED;
  }
  else {
    i2cp->state = I2C_READY;
 8002484:	2302      	movs	r3, #2
 8002486:	7023      	strb	r3, [r4, #0]
 8002488:	2300      	movs	r3, #0
 800248a:	f383 8811 	msr	BASEPRI, r3
  }
  osalSysUnlock();
  return rdymsg;
}
 800248e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8002492:	bf00      	nop
 8002494:	20000a04 	.word	0x20000a04
 8002498:	20000918 	.word	0x20000918
 800249c:	00000000 	.word	0x00000000

080024a0 <_pal_lld_setgroupmode.constprop.15>:
    0xF,        /* PAL_MODE_STM32_ALTERNATE_OPENDRAIN, 50MHz.*/
  };
  uint32_t mh, ml, crh, crl, cfg;
  unsigned i;

  if (mode == PAL_MODE_INPUT_PULLUP)
 80024a0:	2903      	cmp	r1, #3
 * @param[in] mask      the group mask
 * @param[in] mode      the mode
 *
 * @notapi
 */
void _pal_lld_setgroupmode(ioportid_t port,
 80024a2:	b4f0      	push	{r4, r5, r6, r7}
    0xF,        /* PAL_MODE_STM32_ALTERNATE_OPENDRAIN, 50MHz.*/
  };
  uint32_t mh, ml, crh, crl, cfg;
  unsigned i;

  if (mode == PAL_MODE_INPUT_PULLUP)
 80024a4:	d02b      	beq.n	80024fe <_pal_lld_setgroupmode.constprop.15+0x5e>
    port->BSRR = mask;
  else if (mode == PAL_MODE_INPUT_PULLDOWN)
 80024a6:	2904      	cmp	r1, #4
    port->BRR = mask;
 80024a8:	bf04      	itt	eq
 80024aa:	4b16      	ldreq	r3, [pc, #88]	; (8002504 <_pal_lld_setgroupmode.constprop.15+0x64>)
 80024ac:	6158      	streq	r0, [r3, #20]
  cfg = cfgtab[mode];
  mh = ml = crh = crl = 0;
 80024ae:	2300      	movs	r3, #0
 80024b0:	461a      	mov	r2, r3
 80024b2:	461d      	mov	r5, r3
 80024b4:	461c      	mov	r4, r3

  if (mode == PAL_MODE_INPUT_PULLUP)
    port->BSRR = mask;
  else if (mode == PAL_MODE_INPUT_PULLDOWN)
    port->BRR = mask;
  cfg = cfgtab[mode];
 80024b6:	4f14      	ldr	r7, [pc, #80]	; (8002508 <_pal_lld_setgroupmode.constprop.15+0x68>)
 80024b8:	2608      	movs	r6, #8
 80024ba:	5c79      	ldrb	r1, [r7, r1]
  for (i = 0; i < 8; i++) {
    ml <<= 4;
    mh <<= 4;
    crl <<= 4;
    crh <<= 4;
    if ((mask & 0x0080) == 0)
 80024bc:	0607      	lsls	r7, r0, #24
  else if (mode == PAL_MODE_INPUT_PULLDOWN)
    port->BRR = mask;
  cfg = cfgtab[mode];
  mh = ml = crh = crl = 0;
  for (i = 0; i < 8; i++) {
    ml <<= 4;
 80024be:	ea4f 1404 	mov.w	r4, r4, lsl #4
    mh <<= 4;
    crl <<= 4;
 80024c2:	ea4f 1202 	mov.w	r2, r2, lsl #4
    port->BRR = mask;
  cfg = cfgtab[mode];
  mh = ml = crh = crl = 0;
  for (i = 0; i < 8; i++) {
    ml <<= 4;
    mh <<= 4;
 80024c6:	ea4f 1505 	mov.w	r5, r5, lsl #4
    crl <<= 4;
    crh <<= 4;
 80024ca:	ea4f 1303 	mov.w	r3, r3, lsl #4
    if ((mask & 0x0080) == 0)
      ml |= 0xf;
 80024ce:	bf54      	ite	pl
 80024d0:	f044 040f 	orrpl.w	r4, r4, #15
    else
      crl |= cfg;
 80024d4:	430a      	orrmi	r2, r1
    if ((mask & 0x8000) == 0)
 80024d6:	0407      	lsls	r7, r0, #16
      mh |= 0xf;
 80024d8:	bf54      	ite	pl
 80024da:	f045 050f 	orrpl.w	r5, r5, #15
    else
      crh |= cfg;
 80024de:	430b      	orrmi	r3, r1
    port->BSRR = mask;
  else if (mode == PAL_MODE_INPUT_PULLDOWN)
    port->BRR = mask;
  cfg = cfgtab[mode];
  mh = ml = crh = crl = 0;
  for (i = 0; i < 8; i++) {
 80024e0:	3e01      	subs	r6, #1
      crl |= cfg;
    if ((mask & 0x8000) == 0)
      mh |= 0xf;
    else
      crh |= cfg;
    mask <<= 1;
 80024e2:	ea4f 0040 	mov.w	r0, r0, lsl #1
    port->BSRR = mask;
  else if (mode == PAL_MODE_INPUT_PULLDOWN)
    port->BRR = mask;
  cfg = cfgtab[mode];
  mh = ml = crh = crl = 0;
  for (i = 0; i < 8; i++) {
 80024e6:	d1e9      	bne.n	80024bc <_pal_lld_setgroupmode.constprop.15+0x1c>
      mh |= 0xf;
    else
      crh |= cfg;
    mask <<= 1;
  }
  port->CRH = (port->CRH & mh) | crh;
 80024e8:	4906      	ldr	r1, [pc, #24]	; (8002504 <_pal_lld_setgroupmode.constprop.15+0x64>)
 80024ea:	6848      	ldr	r0, [r1, #4]
 80024ec:	4005      	ands	r5, r0
 80024ee:	432b      	orrs	r3, r5
 80024f0:	604b      	str	r3, [r1, #4]
  port->CRL = (port->CRL & ml) | crl;
 80024f2:	680b      	ldr	r3, [r1, #0]
 80024f4:	401c      	ands	r4, r3
 80024f6:	4322      	orrs	r2, r4
 80024f8:	600a      	str	r2, [r1, #0]
}
 80024fa:	bcf0      	pop	{r4, r5, r6, r7}
 80024fc:	4770      	bx	lr
  };
  uint32_t mh, ml, crh, crl, cfg;
  unsigned i;

  if (mode == PAL_MODE_INPUT_PULLUP)
    port->BSRR = mask;
 80024fe:	4b01      	ldr	r3, [pc, #4]	; (8002504 <_pal_lld_setgroupmode.constprop.15+0x64>)
 8002500:	6118      	str	r0, [r3, #16]
 8002502:	e7d4      	b.n	80024ae <_pal_lld_setgroupmode.constprop.15+0xe>
 8002504:	40010c00 	.word	0x40010c00
 8002508:	08003f20 	.word	0x08003f20
 800250c:	00000000 	.word	0x00000000

08002510 <menu_draw>:
	}
	if(ms->DRAW_AUTO) menu_draw(ms);
}

void menu_draw(menu_state * ms)
{
 8002510:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	font_t font;
	coord_t width = gdispGetWidth();
 8002514:	4b9f      	ldr	r3, [pc, #636]	; (8002794 <menu_draw+0x284>)
	coord_t height = gdispGetHeight() / ms->MAX_ROWS;
 8002516:	7802      	ldrb	r2, [r0, #0]
}

void menu_draw(menu_state * ms)
{
	font_t font;
	coord_t width = gdispGetWidth();
 8002518:	681e      	ldr	r6, [r3, #0]
	}
	if(ms->DRAW_AUTO) menu_draw(ms);
}

void menu_draw(menu_state * ms)
{
 800251a:	4601      	mov	r1, r0
unsigned gdispGetDisplayCount(void) {
	return gdriverInstanceCount(GDRIVER_TYPE_DISPLAY);
}

coord_t gdispGGetWidth(GDisplay *g)				{ return g->g.Width; }
coord_t gdispGGetHeight(GDisplay *g)			{ return g->g.Height; }
 800251c:	f9b6 800a 	ldrsh.w	r8, [r6, #10]
}

font_t gdispOpenFont(const char *name) {
	const struct mf_font_list_s *fp;
	
	if (!fontList)
 8002520:	4b9d      	ldr	r3, [pc, #628]	; (8002798 <menu_draw+0x288>)
	font_t font;
	coord_t width = gdispGetWidth();
	coord_t height = gdispGetHeight() / ms->MAX_ROWS;
 8002522:	fb98 f2f2 	sdiv	r2, r8, r2
	}
	if(ms->DRAW_AUTO) menu_draw(ms);
}

void menu_draw(menu_state * ms)
{
 8002526:	b08f      	sub	sp, #60	; 0x3c
 8002528:	9002      	str	r0, [sp, #8]
 800252a:	681c      	ldr	r4, [r3, #0]

unsigned gdispGetDisplayCount(void) {
	return gdriverInstanceCount(GDRIVER_TYPE_DISPLAY);
}

coord_t gdispGGetWidth(GDisplay *g)				{ return g->g.Width; }
 800252c:	f9b6 0008 	ldrsh.w	r0, [r6, #8]
	font_t font;
	coord_t width = gdispGetWidth();
	coord_t height = gdispGetHeight() / ms->MAX_ROWS;
 8002530:	9207      	str	r2, [sp, #28]
 8002532:	b212      	sxth	r2, r2
 8002534:	9005      	str	r0, [sp, #20]
 8002536:	9208      	str	r2, [sp, #32]

	color_t color_text = White;
	color_t color_bg = Black;

	font = gdispOpenFont(ms->font);
 8002538:	684d      	ldr	r5, [r1, #4]
 800253a:	2c00      	cmp	r4, #0
 800253c:	f000 8126 	beq.w	800278c <menu_draw+0x27c>
		fontList = mf_get_font_list();
		
	// Try the long names first
	for(fp = fontList; fp; fp = fp->next) {
 8002540:	4627      	mov	r7, r4
 8002542:	46a1      	mov	r9, r4
 8002544:	e003      	b.n	800254e <menu_draw+0x3e>
 8002546:	683f      	ldr	r7, [r7, #0]
 8002548:	2f00      	cmp	r7, #0
 800254a:	f000 8108 	beq.w	800275e <menu_draw+0x24e>
		if (matchfont(name, fp->font->full_name))
 800254e:	687c      	ldr	r4, [r7, #4]
 8002550:	4628      	mov	r0, r5
 8002552:	6821      	ldr	r1, [r4, #0]
 8002554:	f7fe fbc4 	bl	8000ce0 <matchfont.lto_priv.38>
 8002558:	2800      	cmp	r0, #0
 800255a:	d0f4      	beq.n	8002546 <menu_draw+0x36>
 800255c:	46a3      	mov	fp, r4
			for (col = sx; col <= ex; col++)
				base[col] |= mask;
		}

        */
		g->flags |= GDISP_FLG_NEEDFLUSH;
 800255e:	8bf3      	ldrh	r3, [r6, #30]
		#if GDISP_HARDWARE_FILLS == HARDWARE_AUTODETECT
			if (gvmt(g)->fill)
		#endif
		{
			g->p.x = g->p.y = 0;
			g->p.cx = g->g.Width;
 8002560:	f8bd 2014 	ldrh.w	r2, [sp, #20]
	#if GDISP_HARDWARE_CLEARS != TRUE && GDISP_HARDWARE_FILLS
		#if GDISP_HARDWARE_FILLS == HARDWARE_AUTODETECT
			if (gvmt(g)->fill)
		#endif
		{
			g->p.x = g->p.y = 0;
 8002564:	2700      	movs	r7, #0
 8002566:	f043 0304 	orr.w	r3, r3, #4
			g->p.cx = g->g.Width;
 800256a:	84b2      	strh	r2, [r6, #36]	; 0x24
 800256c:	83f3      	strh	r3, [r6, #30]
			g->p.cy = g->g.Height;
			g->p.color = color;
			gdisp_lld_fill_area(g);
			autoflush_stopdone(g);
 800256e:	4630      	mov	r0, r6
			if (gvmt(g)->fill)
		#endif
		{
			g->p.x = g->p.y = 0;
			g->p.cx = g->g.Width;
			g->p.cy = g->g.Height;
 8002570:	f8a6 8026 	strh.w	r8, [r6, #38]	; 0x26
	#if GDISP_HARDWARE_CLEARS != TRUE && GDISP_HARDWARE_FILLS
		#if GDISP_HARDWARE_FILLS == HARDWARE_AUTODETECT
			if (gvmt(g)->fill)
		#endif
		{
			g->p.x = g->p.y = 0;
 8002574:	8477      	strh	r7, [r6, #34]	; 0x22
 8002576:	8437      	strh	r7, [r6, #32]
			g->p.cx = g->g.Width;
			g->p.cy = g->g.Height;
			g->p.color = color;
 8002578:	f886 7030 	strb.w	r7, [r6, #48]	; 0x30
			gdisp_lld_fill_area(g);
			autoflush_stopdone(g);
 800257c:	f7fe fe48 	bl	8001210 <gdisp_lld_flush>
	coord_t i;
	coord_t y = 0;

	gdispClear(Black);

	for (i = ms->top; i < ms->top + ms->MAX_ROWS; ++i) {
 8002580:	9902      	ldr	r1, [sp, #8]
 8002582:	7a0a      	ldrb	r2, [r1, #8]
 8002584:	7808      	ldrb	r0, [r1, #0]
 8002586:	b213      	sxth	r3, r2
 8002588:	1881      	adds	r1, r0, r2
 800258a:	428a      	cmp	r2, r1
 800258c:	461c      	mov	r4, r3
 800258e:	4613      	mov	r3, r2
 8002590:	f280 80dc 	bge.w	800274c <menu_draw+0x23c>
        render_left(font, x0, y0, text, count, callback, state);
    }
    if (align == MF_ALIGN_CENTER)
    {
        string_width = mf_get_string_width(font, text, count, false);
        x0 -= string_width / 2;
 8002594:	9905      	ldr	r1, [sp, #20]
    mf_char c1 = 0, c2;
    
    x = x0 - font->baseline_x;
    while (count--)
    {
        c2 = mf_getchar(&text);
 8002596:	46a0      	mov	r8, r4
        render_left(font, x0, y0, text, count, callback, state);
    }
    if (align == MF_ALIGN_CENTER)
    {
        string_width = mf_get_string_width(font, text, count, false);
        x0 -= string_width / 2;
 8002598:	3101      	adds	r1, #1
 800259a:	eb01 71d1 	add.w	r1, r1, r1, lsr #31
 800259e:	f3c1 014f 	ubfx	r1, r1, #1, #16
 80025a2:	9109      	str	r1, [sp, #36]	; 0x24
		if(i < ms->current_menu->count_items) {
			color_text = (ms->current_item == i) ? Black : White;
			color_bg   = (color_text == White)   ? Black : White;
			gdispFillStringBox(0,  (y * (height + 1)), width, height, ms->current_menu->items[i]->label, font, color_text, color_bg, justifyCenter);
 80025a4:	9907      	ldr	r1, [sp, #28]
 80025a6:	3101      	adds	r1, #1
 80025a8:	9104      	str	r1, [sp, #16]
 80025aa:	e00d      	b.n	80025c8 <menu_draw+0xb8>
 80025ac:	b2bb      	uxth	r3, r7
 80025ae:	9301      	str	r3, [sp, #4]
	coord_t i;
	coord_t y = 0;

	gdispClear(Black);

	for (i = ms->top; i < ms->top + ms->MAX_ROWS; ++i) {
 80025b0:	f108 0801 	add.w	r8, r8, #1
		if(i < ms->current_menu->count_items) {
			color_text = (ms->current_item == i) ? Black : White;
			color_bg   = (color_text == White)   ? Black : White;
			gdispFillStringBox(0,  (y * (height + 1)), width, height, ms->current_menu->items[i]->label, font, color_text, color_bg, justifyCenter);
		}
		y++;
 80025b4:	9f01      	ldr	r7, [sp, #4]
	coord_t i;
	coord_t y = 0;

	gdispClear(Black);

	for (i = ms->top; i < ms->top + ms->MAX_ROWS; ++i) {
 80025b6:	fa0f f888 	sxth.w	r8, r8
 80025ba:	1811      	adds	r1, r2, r0
		if(i < ms->current_menu->count_items) {
			color_text = (ms->current_item == i) ? Black : White;
			color_bg   = (color_text == White)   ? Black : White;
			gdispFillStringBox(0,  (y * (height + 1)), width, height, ms->current_menu->items[i]->label, font, color_text, color_bg, justifyCenter);
		}
		y++;
 80025bc:	3701      	adds	r7, #1
	coord_t i;
	coord_t y = 0;

	gdispClear(Black);

	for (i = ms->top; i < ms->top + ms->MAX_ROWS; ++i) {
 80025be:	4588      	cmp	r8, r1
		if(i < ms->current_menu->count_items) {
			color_text = (ms->current_item == i) ? Black : White;
			color_bg   = (color_text == White)   ? Black : White;
			gdispFillStringBox(0,  (y * (height + 1)), width, height, ms->current_menu->items[i]->label, font, color_text, color_bg, justifyCenter);
		}
		y++;
 80025c0:	b23f      	sxth	r7, r7
	coord_t i;
	coord_t y = 0;

	gdispClear(Black);

	for (i = ms->top; i < ms->top + ms->MAX_ROWS; ++i) {
 80025c2:	4643      	mov	r3, r8
 80025c4:	f280 80c2 	bge.w	800274c <menu_draw+0x23c>
		if(i < ms->current_menu->count_items) {
 80025c8:	9902      	ldr	r1, [sp, #8]
 80025ca:	68c9      	ldr	r1, [r1, #12]
 80025cc:	7c0c      	ldrb	r4, [r1, #16]
 80025ce:	429c      	cmp	r4, r3
 80025d0:	ddec      	ble.n	80025ac <menu_draw+0x9c>
			color_text = (ms->current_item == i) ? Black : White;
 80025d2:	9a02      	ldr	r2, [sp, #8]
			color_bg   = (color_text == White)   ? Black : White;
			gdispFillStringBox(0,  (y * (height + 1)), width, height, ms->current_menu->items[i]->label, font, color_text, color_bg, justifyCenter);
 80025d4:	9d04      	ldr	r5, [sp, #16]

	gdispClear(Black);

	for (i = ms->top; i < ms->top + ms->MAX_ROWS; ++i) {
		if(i < ms->current_menu->count_items) {
			color_text = (ms->current_item == i) ? Black : White;
 80025d6:	7a90      	ldrb	r0, [r2, #10]
		MUTEX_ENTER(g);

		g->p.cx = cx;
		g->p.cy = cy;
		g->t.font = font;
		g->t.clipx0 = g->p.x = x;
 80025d8:	2200      	movs	r2, #0
			color_bg   = (color_text == White)   ? Black : White;
 80025da:	4298      	cmp	r0, r3
 80025dc:	bf14      	ite	ne
 80025de:	4610      	movne	r0, r2
		g->t.clipy0 = g->p.y = y;
		g->t.clipx1 = x+cx;
		g->t.clipy1 = y+cy;
		g->t.color = color;
 80025e0:	4696      	moveq	lr, r2
				mf_wordwrap(font, cx, str, mf_countline_callback, &nbrLines);
				wrapParameters.y += (cy+1 - nbrLines*font->height)/2;

				mf_wordwrap(font, cx, str, mf_fillline_callback, &wrapParameters);
			#else
				y += (cy+1 - font->height)/2;
 80025e2:	4614      	mov	r4, r2
			gdispFillStringBox(0,  (y * (height + 1)), width, height, ms->current_menu->items[i]->label, font, color_text, color_bg, justifyCenter);
 80025e4:	b2bb      	uxth	r3, r7
 80025e6:	9301      	str	r3, [sp, #4]
 80025e8:	fb05 f303 	mul.w	r3, r5, r3
 80025ec:	68c9      	ldr	r1, [r1, #12]
 80025ee:	4e69      	ldr	r6, [pc, #420]	; (8002794 <menu_draw+0x284>)
 80025f0:	f851 c028 	ldr.w	ip, [r1, r8, lsl #2]
 80025f4:	6837      	ldr	r7, [r6, #0]
 80025f6:	b29b      	uxth	r3, r3
 80025f8:	b21e      	sxth	r6, r3
 80025fa:	f8dc 5000 	ldr.w	r5, [ip]
 80025fe:	8bf9      	ldrh	r1, [r7, #30]

		g->p.cx = cx;
		g->p.cy = cy;
		g->t.font = font;
		g->t.clipx0 = g->p.x = x;
		g->t.clipy0 = g->p.y = y;
 8002600:	847e      	strh	r6, [r7, #34]	; 0x22
 8002602:	f8a7 6040 	strh.w	r6, [r7, #64]	; 0x40
		g->t.clipx1 = x+cx;
		g->t.clipy1 = y+cy;
 8002606:	9e07      	ldr	r6, [sp, #28]

		if (!font)
			return;
		MUTEX_ENTER(g);

		g->p.cx = cx;
 8002608:	f8dd c014 	ldr.w	ip, [sp, #20]
		g->p.cy = cy;
 800260c:	f8bd 9020 	ldrh.w	r9, [sp, #32]
		g->t.font = font;
		g->t.clipx0 = g->p.x = x;
		g->t.clipy0 = g->p.y = y;
		g->t.clipx1 = x+cx;
		g->t.clipy1 = y+cy;
 8002610:	441e      	add	r6, r3
	gdispClear(Black);

	for (i = ms->top; i < ms->top + ms->MAX_ROWS; ++i) {
		if(i < ms->current_menu->count_items) {
			color_text = (ms->current_item == i) ? Black : White;
			color_bg   = (color_text == White)   ? Black : White;
 8002612:	bf08      	it	eq
 8002614:	2001      	moveq	r0, #1
 8002616:	f041 0104 	orr.w	r1, r1, #4
		g->t.color = color;
 800261a:	bf18      	it	ne
 800261c:	f04f 0e01 	movne.w	lr, #1
		if (!font)
			return;
		MUTEX_ENTER(g);

		g->p.cx = cx;
		g->p.cy = cy;
 8002620:	f8a7 9026 	strh.w	r9, [r7, #38]	; 0x26
		g->t.font = font;
		g->t.clipx0 = g->p.x = x;
		g->t.clipy0 = g->p.y = y;
		g->t.clipx1 = x+cx;
		g->t.clipy1 = y+cy;
 8002624:	f8a7 6044 	strh.w	r6, [r7, #68]	; 0x44
 8002628:	83f9      	strh	r1, [r7, #30]

		if (!font)
			return;
		MUTEX_ENTER(g);

		g->p.cx = cx;
 800262a:	f8a7 c024 	strh.w	ip, [r7, #36]	; 0x24
		g->p.cy = cy;
		g->t.font = font;
 800262e:	f8c7 b038 	str.w	fp, [r7, #56]	; 0x38
		g->t.clipx0 = g->p.x = x;
		g->t.clipy0 = g->p.y = y;
		g->t.clipx1 = x+cx;
 8002632:	f8a7 c042 	strh.w	ip, [r7, #66]	; 0x42
		g->t.clipy1 = y+cy;
		g->t.color = color;
 8002636:	f887 e03c 	strb.w	lr, [r7, #60]	; 0x3c
		MUTEX_ENTER(g);

		g->p.cx = cx;
		g->p.cy = cy;
		g->t.font = font;
		g->t.clipx0 = g->p.x = x;
 800263a:	843a      	strh	r2, [r7, #32]
 800263c:	87fa      	strh	r2, [r7, #62]	; 0x3e
		g->t.clipy0 = g->p.y = y;
		g->t.clipx1 = x+cx;
		g->t.clipy1 = y+cy;
		g->t.color = color;
		g->t.bgcolor = g->p.color = bgcolor;
 800263e:	f887 0030 	strb.w	r0, [r7, #48]	; 0x30
 8002642:	f887 003d 	strb.w	r0, [r7, #61]	; 0x3d
				mf_wordwrap(font, cx, str, mf_countline_callback, &nbrLines);
				wrapParameters.y += (cy+1 - nbrLines*font->height)/2;

				mf_wordwrap(font, cx, str, mf_fillline_callback, &wrapParameters);
			#else
				y += (cy+1 - font->height)/2;
 8002646:	f89b 2009 	ldrb.w	r2, [fp, #9]
 800264a:	9904      	ldr	r1, [sp, #16]
 800264c:	f10d 0a38 	add.w	sl, sp, #56	; 0x38
 8002650:	1a8a      	subs	r2, r1, r2
 8002652:	eb02 72d2 	add.w	r2, r2, r2, lsr #31
 8002656:	eb03 0262 	add.w	r2, r3, r2, asr #1
 800265a:	b213      	sxth	r3, r2
 800265c:	f84a 5d0c 	str.w	r5, [sl, #-12]!
			gdispFillStringBox(0,  (y * (height + 1)), width, height, ms->current_menu->items[i]->label, font, color_text, color_bg, justifyCenter);
 8002660:	9503      	str	r5, [sp, #12]
 8002662:	9306      	str	r3, [sp, #24]
 8002664:	46a1      	mov	r9, r4
 8002666:	462b      	mov	r3, r5
    mf_char tmp = 0;
    
    if (!count)
        count = 0xFFFF;
    
    while (count-- && *text)
 8002668:	f64f 76ff 	movw	r6, #65535	; 0xffff
 800266c:	4655      	mov	r5, sl
 800266e:	e000      	b.n	8002672 <menu_draw+0x162>
 8002670:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8002672:	781b      	ldrb	r3, [r3, #0]
    {
        i++;
 8002674:	f109 0901 	add.w	r9, r9, #1
 8002678:	fa1f f989 	uxth.w	r9, r9
    mf_char tmp = 0;
    
    if (!count)
        count = 0xFFFF;
    
    while (count-- && *text)
 800267c:	b183      	cbz	r3, 80026a0 <menu_draw+0x190>
    {
        i++;
        tmp = mf_getchar(&text);
 800267e:	4628      	mov	r0, r5
 8002680:	f7fe fad6 	bl	8000c30 <mf_getchar>
        if (tmp != ' ' && tmp != (mf_char)0xA0 && tmp != '\n' &&
 8002684:	f020 0380 	bic.w	r3, r0, #128	; 0x80
 8002688:	b29b      	uxth	r3, r3
 800268a:	2b20      	cmp	r3, #32
 800268c:	d006      	beq.n	800269c <menu_draw+0x18c>
 800268e:	280a      	cmp	r0, #10
 8002690:	d004      	beq.n	800269c <menu_draw+0x18c>
 8002692:	280d      	cmp	r0, #13
 8002694:	d002      	beq.n	800269c <menu_draw+0x18c>
    if (!count)
        count = 0xFFFF;
    
    while (count-- && *text)
    {
        i++;
 8002696:	2809      	cmp	r0, #9
 8002698:	bf18      	it	ne
 800269a:	464c      	movne	r4, r9
    mf_char tmp = 0;
    
    if (!count)
        count = 0xFFFF;
    
    while (count-- && *text)
 800269c:	45b1      	cmp	r9, r6
 800269e:	d1e7      	bne.n	8002670 <menu_draw+0x160>
                            uint16_t count, bool kern)
{
    int16_t result = 0;
    uint16_t c1 = 0, c2;
    
    if (!count)
 80026a0:	f64f 79ff 	movw	r9, #65535	; 0xffff
 80026a4:	9b03      	ldr	r3, [sp, #12]
        count = 0xFFFF;
 80026a6:	2500      	movs	r5, #0
 80026a8:	f10d 0a38 	add.w	sl, sp, #56	; 0x38
 80026ac:	f84a 3d04 	str.w	r3, [sl, #-4]!
                            uint16_t count, bool kern)
{
    int16_t result = 0;
    uint16_t c1 = 0, c2;
    
    if (!count)
 80026b0:	42ac      	cmp	r4, r5
 80026b2:	bf18      	it	ne
 80026b4:	46a1      	movne	r9, r4
        count = 0xFFFF;
 80026b6:	462e      	mov	r6, r5
 80026b8:	e008      	b.n	80026cc <menu_draw+0x1bc>
        }
        
        if (kern && c1 != 0)
            result += mf_compute_kerning(font, c1, c2);

        result += mf_character_width(font, c2);
 80026ba:	4601      	mov	r1, r0
 80026bc:	4658      	mov	r0, fp
 80026be:	f7fe fa87 	bl	8000bd0 <mf_character_width>
 80026c2:	3601      	adds	r6, #1
 80026c4:	4428      	add	r0, r5
    uint16_t c1 = 0, c2;
    
    if (!count)
        count = 0xFFFF;
    
    while (count-- && *text)
 80026c6:	45b1      	cmp	r9, r6
        }
        
        if (kern && c1 != 0)
            result += mf_compute_kerning(font, c1, c2);

        result += mf_character_width(font, c2);
 80026c8:	b205      	sxth	r5, r0
    uint16_t c1 = 0, c2;
    
    if (!count)
        count = 0xFFFF;
    
    while (count-- && *text)
 80026ca:	d010      	beq.n	80026ee <menu_draw+0x1de>
 80026cc:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 80026ce:	781b      	ldrb	r3, [r3, #0]
 80026d0:	b16b      	cbz	r3, 80026ee <menu_draw+0x1de>
    {
        c2 = mf_getchar(&text);
 80026d2:	4650      	mov	r0, sl
 80026d4:	f7fe faac 	bl	8000c30 <mf_getchar>

        if (c2 == '\t')
 80026d8:	2809      	cmp	r0, #9
 80026da:	d1ee      	bne.n	80026ba <menu_draw+0x1aa>
        {
#if MF_USE_TABS
            result = mf_round_to_tab(font, 0, result);
 80026dc:	462a      	mov	r2, r5
 80026de:	2100      	movs	r1, #0
 80026e0:	4658      	mov	r0, fp
 80026e2:	f7fe fa85 	bl	8000bf0 <mf_round_to_tab.lto_priv.37>
 80026e6:	3601      	adds	r6, #1
    uint16_t c1 = 0, c2;
    
    if (!count)
        count = 0xFFFF;
    
    while (count-- && *text)
 80026e8:	45b1      	cmp	r9, r6
        c2 = mf_getchar(&text);

        if (c2 == '\t')
        {
#if MF_USE_TABS
            result = mf_round_to_tab(font, 0, result);
 80026ea:	4605      	mov	r5, r0
    uint16_t c1 = 0, c2;
    
    if (!count)
        count = 0xFFFF;
    
    while (count-- && *text)
 80026ec:	d1ee      	bne.n	80026cc <menu_draw+0x1bc>
        render_left(font, x0, y0, text, count, callback, state);
    }
    if (align == MF_ALIGN_CENTER)
    {
        string_width = mf_get_string_width(font, text, count, false);
        x0 -= string_width / 2;
 80026ee:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80026f0:	eb05 75d5 	add.w	r5, r5, r5, lsr #31
 80026f4:	eba3 0565 	sub.w	r5, r3, r5, asr #1
                        void *state)
{
    int16_t x;
    mf_char c1 = 0, c2;
    
    x = x0 - font->baseline_x;
 80026f8:	f89b 600c 	ldrb.w	r6, [fp, #12]
        render_left(font, x0, y0, text, count, callback, state);
    }
    if (align == MF_ALIGN_CENTER)
    {
        string_width = mf_get_string_width(font, text, count, false);
        x0 -= string_width / 2;
 80026fc:	b2ad      	uxth	r5, r5
 80026fe:	9b03      	ldr	r3, [sp, #12]
                        void *state)
{
    int16_t x;
    mf_char c1 = 0, c2;
    
    x = x0 - font->baseline_x;
 8002700:	1bae      	subs	r6, r5, r6
 8002702:	930c      	str	r3, [sp, #48]	; 0x30
 8002704:	b236      	sxth	r6, r6
        render_left(font, x0, y0, text, count, callback, state);
    }
    if (align == MF_ALIGN_CENTER)
    {
        string_width = mf_get_string_width(font, text, count, false);
        x0 -= string_width / 2;
 8002706:	b22d      	sxth	r5, r5
 8002708:	f8dd 9018 	ldr.w	r9, [sp, #24]
{
    int16_t x;
    mf_char c1 = 0, c2;
    
    x = x0 - font->baseline_x;
    while (count--)
 800270c:	b184      	cbz	r4, 8002730 <menu_draw+0x220>
    {
        c2 = mf_getchar(&text);
 800270e:	a80c      	add	r0, sp, #48	; 0x30
 8002710:	f7fe fa8e 	bl	8000c30 <mf_getchar>
        
        if (c2 == '\t')
 8002714:	2809      	cmp	r0, #9
 8002716:	d012      	beq.n	800273e <menu_draw+0x22e>
        }
        
        if (c1 != 0)
            x += mf_compute_kerning(font, c1, c2);

        x += callback(x, y0, c2, state);
 8002718:	4602      	mov	r2, r0
 800271a:	463b      	mov	r3, r7
 800271c:	4630      	mov	r0, r6
 800271e:	4649      	mov	r1, r9
 8002720:	f7fd ff1e 	bl	8000560 <fillcharglyph.lto_priv.36>
 8002724:	4430      	add	r0, r6
 8002726:	b206      	sxth	r6, r0
 8002728:	3c01      	subs	r4, #1
 800272a:	b2a4      	uxth	r4, r4
{
    int16_t x;
    mf_char c1 = 0, c2;
    
    x = x0 - font->baseline_x;
    while (count--)
 800272c:	2c00      	cmp	r4, #0
 800272e:	d1ee      	bne.n	800270e <menu_draw+0x1fe>
				mf_render_aligned(font, x, y, justify, str, 0, fillcharglyph, g);
			#endif
		}

		autoflush(g);
 8002730:	4638      	mov	r0, r7
 8002732:	f7fe fd6d 	bl	8001210 <gdisp_lld_flush>
 8002736:	9a02      	ldr	r2, [sp, #8]
 8002738:	7810      	ldrb	r0, [r2, #0]
 800273a:	7a12      	ldrb	r2, [r2, #8]
 800273c:	e738      	b.n	80025b0 <menu_draw+0xa0>
        c2 = mf_getchar(&text);
        
        if (c2 == '\t')
        {
#if MF_USE_TABS
            x = mf_round_to_tab(font, x0, x);
 800273e:	4632      	mov	r2, r6
 8002740:	4629      	mov	r1, r5
 8002742:	4658      	mov	r0, fp
 8002744:	f7fe fa54 	bl	8000bf0 <mf_round_to_tab.lto_priv.37>
 8002748:	4606      	mov	r6, r0
 800274a:	e7ed      	b.n	8002728 <menu_draw+0x218>
	/* Return default builtin font.. better than nothing. */
	return mf_get_font_list()->font;
}

void gdispCloseFont(font_t font) {
	if ((font->flags & (FONT_FLAG_DYNAMIC|FONT_FLAG_UNLISTED)) == (FONT_FLAG_DYNAMIC|FONT_FLAG_UNLISTED)) {
 800274c:	f89b 300f 	ldrb.w	r3, [fp, #15]
 8002750:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
 8002754:	2bc0      	cmp	r3, #192	; 0xc0
 8002756:	d012      	beq.n	800277e <menu_draw+0x26e>
		}
		y++;
	}

	gdispCloseFont(font);
 8002758:	b00f      	add	sp, #60	; 0x3c
 800275a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800275e:	464c      	mov	r4, r9
 8002760:	e001      	b.n	8002766 <menu_draw+0x256>
		if (matchfont(name, fp->font->full_name))
			return fp->font;
	}

	// Try the short names if no long names match
	for(fp = fontList; fp; fp = fp->next) {
 8002762:	6824      	ldr	r4, [r4, #0]
 8002764:	b144      	cbz	r4, 8002778 <menu_draw+0x268>
		if (matchfont(name, fp->font->short_name))
 8002766:	6867      	ldr	r7, [r4, #4]
 8002768:	4628      	mov	r0, r5
 800276a:	6879      	ldr	r1, [r7, #4]
 800276c:	f7fe fab8 	bl	8000ce0 <matchfont.lto_priv.38>
 8002770:	2800      	cmp	r0, #0
 8002772:	d0f6      	beq.n	8002762 <menu_draw+0x252>
 8002774:	46bb      	mov	fp, r7
 8002776:	e6f2      	b.n	800255e <menu_draw+0x4e>
		if (matchfont(name, fp->font->full_name))
			return fp->font;
	}

	// Try the short names if no long names match
	for(fp = fontList; fp; fp = fp->next) {
 8002778:	f8df b024 	ldr.w	fp, [pc, #36]	; 80027a0 <menu_draw+0x290>
 800277c:	e6ef      	b.n	800255e <menu_draw+0x4e>
}

void gdispCloseFont(font_t font) {
	if ((font->flags & (FONT_FLAG_DYNAMIC|FONT_FLAG_UNLISTED)) == (FONT_FLAG_DYNAMIC|FONT_FLAG_UNLISTED)) {
		/* Make sure that no-one can successfully use font after closing */
		((struct mf_font_s *)font)->render_character = 0;
 800277e:	2300      	movs	r3, #0
 8002780:	f8cb 3018 	str.w	r3, [fp, #24]
		
		/* Release the allocated memory */
		gfxFree((void *)font);
 8002784:	4658      	mov	r0, fp
 8002786:	f7ff fabb 	bl	8001d00 <chHeapFree>
 800278a:	e7e5      	b.n	8002758 <menu_draw+0x248>

font_t gdispOpenFont(const char *name) {
	const struct mf_font_list_s *fp;
	
	if (!fontList)
		fontList = mf_get_font_list();
 800278c:	4c03      	ldr	r4, [pc, #12]	; (800279c <menu_draw+0x28c>)
 800278e:	601c      	str	r4, [r3, #0]
 8002790:	e6d6      	b.n	8002540 <menu_draw+0x30>
 8002792:	bf00      	nop
 8002794:	200009fc 	.word	0x200009fc
 8002798:	20000a00 	.word	0x20000a00
 800279c:	08003efc 	.word	0x08003efc
 80027a0:	0800409c 	.word	0x0800409c
	...

080027b0 <memset>:
 80027b0:	b470      	push	{r4, r5, r6}
 80027b2:	0784      	lsls	r4, r0, #30
 80027b4:	d046      	beq.n	8002844 <memset+0x94>
 80027b6:	1e54      	subs	r4, r2, #1
 80027b8:	2a00      	cmp	r2, #0
 80027ba:	d041      	beq.n	8002840 <memset+0x90>
 80027bc:	b2cd      	uxtb	r5, r1
 80027be:	4603      	mov	r3, r0
 80027c0:	e002      	b.n	80027c8 <memset+0x18>
 80027c2:	1e62      	subs	r2, r4, #1
 80027c4:	b3e4      	cbz	r4, 8002840 <memset+0x90>
 80027c6:	4614      	mov	r4, r2
 80027c8:	f803 5b01 	strb.w	r5, [r3], #1
 80027cc:	079a      	lsls	r2, r3, #30
 80027ce:	d1f8      	bne.n	80027c2 <memset+0x12>
 80027d0:	2c03      	cmp	r4, #3
 80027d2:	d92e      	bls.n	8002832 <memset+0x82>
 80027d4:	b2cd      	uxtb	r5, r1
 80027d6:	ea45 2505 	orr.w	r5, r5, r5, lsl #8
 80027da:	2c0f      	cmp	r4, #15
 80027dc:	ea45 4505 	orr.w	r5, r5, r5, lsl #16
 80027e0:	d919      	bls.n	8002816 <memset+0x66>
 80027e2:	4626      	mov	r6, r4
 80027e4:	f103 0210 	add.w	r2, r3, #16
 80027e8:	3e10      	subs	r6, #16
 80027ea:	2e0f      	cmp	r6, #15
 80027ec:	f842 5c10 	str.w	r5, [r2, #-16]
 80027f0:	f842 5c0c 	str.w	r5, [r2, #-12]
 80027f4:	f842 5c08 	str.w	r5, [r2, #-8]
 80027f8:	f842 5c04 	str.w	r5, [r2, #-4]
 80027fc:	f102 0210 	add.w	r2, r2, #16
 8002800:	d8f2      	bhi.n	80027e8 <memset+0x38>
 8002802:	f1a4 0210 	sub.w	r2, r4, #16
 8002806:	f022 020f 	bic.w	r2, r2, #15
 800280a:	f004 040f 	and.w	r4, r4, #15
 800280e:	3210      	adds	r2, #16
 8002810:	2c03      	cmp	r4, #3
 8002812:	4413      	add	r3, r2
 8002814:	d90d      	bls.n	8002832 <memset+0x82>
 8002816:	461e      	mov	r6, r3
 8002818:	4622      	mov	r2, r4
 800281a:	3a04      	subs	r2, #4
 800281c:	2a03      	cmp	r2, #3
 800281e:	f846 5b04 	str.w	r5, [r6], #4
 8002822:	d8fa      	bhi.n	800281a <memset+0x6a>
 8002824:	1f22      	subs	r2, r4, #4
 8002826:	f022 0203 	bic.w	r2, r2, #3
 800282a:	3204      	adds	r2, #4
 800282c:	4413      	add	r3, r2
 800282e:	f004 0403 	and.w	r4, r4, #3
 8002832:	b12c      	cbz	r4, 8002840 <memset+0x90>
 8002834:	b2c9      	uxtb	r1, r1
 8002836:	441c      	add	r4, r3
 8002838:	f803 1b01 	strb.w	r1, [r3], #1
 800283c:	42a3      	cmp	r3, r4
 800283e:	d1fb      	bne.n	8002838 <memset+0x88>
 8002840:	bc70      	pop	{r4, r5, r6}
 8002842:	4770      	bx	lr
 8002844:	4614      	mov	r4, r2
 8002846:	4603      	mov	r3, r0
 8002848:	e7c2      	b.n	80027d0 <memset+0x20>
 800284a:	bf00      	nop
